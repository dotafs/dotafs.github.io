<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>modeling 笔记</title>
    <link href="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="modeling"><a href="#modeling" class="headerlink" title="modeling"></a>modeling</h1><h2 id="line"><a href="#line" class="headerlink" title="line"></a>line</h2><p>polyline: 连续的折线</p><p>line: 不管啥样的线都是1D的。line 包含curve。</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/1.jpeg" width="400" height="50"> <br></center><p>左边的公式适用于在曲线上生成点（为了pipeline）</p><p>右边的公式适用于描述trajectories(轨道)。可以用来延续一条curve。</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/2.jpeg" width="400" height="50"> <br></center><p>define 1D curve in 3D space.</p><h2 id="Speedline"><a href="#Speedline" class="headerlink" title="Speedline"></a>Speedline</h2><p>curve上取两个及以上个数的点。</p><p>interpolation : curve经过了所有的specify points</p><p>approxmiation : curve没有必要经过所有的点</p><h2 id="cubic-bezier-curves"><a href="#cubic-bezier-curves" class="headerlink" title="cubic bezier curves"></a>cubic bezier curves</h2><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/3.jpeg" width="400" height="200"> <br></center><p>这种曲线总是被control points 组成的convex包裹着 </p><p>注： 曲线在endpoint 正切</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/4.jpeg" width="400" height="200"> <br></center><p>图像描述了每一个基于T的点的权重值</p><p>性质: partition of unity : 相加得1 ; T [0,1] .  所以被convew包裹着</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/5.jpeg" width="400" height="50"> <br></center><p>matrix1： control points</p><p>matrix2: coefficient</p><p>matrix3: Bernstein polynomials</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/6.jpeg" width="400" height="200"> <br></center><p>使曲线变得更复杂。如图采取中点。给曲线由3个control points 变成7 个。 </p><p>注: 也可以不是中点 而是任意的radio。</p><h2 id="continuity"><a href="#continuity" class="headerlink" title="continuity"></a>continuity</h2><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/7.jpeg" width="400" height="200"> <br></center><p>C0 : 两条curve相交点是sharp kink。</p><p>G1 : 两条curve相交点tan是同一个direction。</p><p>C1 : 两条curve相交点tan完全相同。</p><p>C2 : 两条curve相交点tan完全相同，导数也完全相同。</p><h2 id="cubic-BSP-line"><a href="#cubic-BSP-line" class="headerlink" title="cubic BSP line"></a>cubic BSP line</h2><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/8.jpeg" width="400" height="200"> <br></center><h2 id="BSP-vs-Bezier"><a href="#BSP-vs-Bezier" class="headerlink" title="BSP vs Bezier"></a>BSP vs Bezier</h2><p>BSP 不经过endpoints</p><p>Bezier 经过</p>]]></content>
    
    
    
    <tags>
      
      <tag>37111</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>games 笔记1</title>
    <link href="/2022/09/24/game-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/24/game-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><p>考虑移动成本的搜索。文明中单位经过不同地形移动的举例不同。 用一个 priority queue。</p><p>优先队列里存放着各个地点。因为有可能多个路径经过同一个地点，所以如果当前loop中该地点在queue中已经有值，则只存放相对较好的值。</p><p>注： 相对于 Dijkstra ， BFS 就无法判断成本，只能寻找最短路径。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">priority</span> <span class="hljs-operator">=</span> new_cost<br></code></pre></td></tr></table></figure><h1 id="Heuristic-search-（Greedy-Best-First-Search）"><a href="#Heuristic-search-（Greedy-Best-First-Search）" class="headerlink" title="Heuristic search （Greedy Best First Search）"></a>Heuristic search （Greedy Best First Search）</h1><p>经典的贪婪。 Dijkstra 可以寻找多个路径，但我们往往只需要一个。优先队列，但不加入cost so far 改为distance to goal （两点间距离公式）。</p><p>也不判断成本，且结果不一定最好，不适合复杂路径，但速度快很多。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">priority</span> = heuristic(goal, next)<br></code></pre></td></tr></table></figure><p>在这里用property queue </p><p>注： </p><ol><li>heuristic(启发式)这里采用了距离公式，每种类型的图启发式是不一样的，需要自己寻找。</li><li>有可能找不到解，甚至是一个。</li><li>没有backtrack，有可能stack。</li></ol><h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><p>A* will tell you to move from one location to another but it won’t tell you how.</p><p>把前两个合起来。比Dijstra快且结果是正确的。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">priority = <span class="hljs-keyword">new</span><span class="hljs-type">_cost</span> + heuristic(goal, next)<br></code></pre></td></tr></table></figure><h3 id="good-heuristic-monotoic"><a href="#good-heuristic-monotoic" class="headerlink" title="good heuristic - monotoic"></a>good heuristic - monotoic</h3><center><img src="/2022/09/24/game-%E7%AC%94%E8%AE%B0/1.jpeg" width="400" height="300"> <br></center>]]></content>
    
    
    
    <tags>
      
      <tag>34111</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
