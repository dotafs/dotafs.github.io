<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>games101-笔记-光栅化</title>
    <link href="/2022/08/30/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <url>/2022/08/30/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E6%A0%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>orthographic projection（正交投影）:</p><p>忽略深度信息。相机无限远</p><p>perspective projection （透视）:</p><p>有近大远小的效果</p><p>先变为正交投影。然后透视。</p><p>早期的屏幕：（Cathode Ray Tube）阴极射线管。电子打出来射到屏幕上。工作原理是每一行每一行从上往下打电子。隔行扫描（raster scan）我第一帧扫描1，3，5行。第二帧扫描第2，4，6行。问题：对于高速运动视频会造成严重的画面撕裂。</p><p>中期：（Liquid Crystal Display）液晶显示器。<br>(LED) 发光二极管。 只有发光和不发光。之前灯已经确定好颜色了。</p><h3 id="三角形："><a href="#三角形：" class="headerlink" title="三角形："></a>三角形：</h3><ol><li>最基础多边形且三个点肯定在一个平面内。</li><li>任何多边形都可以拆解成三角形。</li></ol><h3 id="判断："><a href="#判断：" class="headerlink" title="判断："></a>判断：</h3><p>像素的中心点与三角形的位置关系。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>蒙特卡罗积分</title>
    <link href="/2022/08/26/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%A7%AF%E5%88%86/"/>
    <url>/2022/08/26/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%A7%AF%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>给任何一个函数，求定积分（面积）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>games101-笔记-辐射度量学</title>
    <link href="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"/>
    <url>/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>radiant energy : energy of electromagnetic radation.<br>Q(J)</p><p>radiant flux（power） : energy emitted per unit time. P &#x3D; Q&#x2F;t (W) , lm (流明)</p><h2 id="Intensity"><a href="#Intensity" class="headerlink" title="Intensity"></a>Intensity</h2><p>power per unit solid angle (立体角对应的能量)</p><p>I &#x3D; P&#x2F;w (P&#x3D; power , w &#x3D; 立体角)</p><h4 id="solid-angle"><a href="#solid-angle" class="headerlink" title="solid angle :"></a>solid angle :</h4><p>angle:</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/1.jpeg" width="200" height="200"> <br></center><p>solid angle:</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/2.jpeg" width="200" height="200"> <br></center><h2 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h2><p>power per unit area (面积所对应的能量)</p><p>E &#x3D; dP&#x2F;dA (P &#x3D; power  , A &#x3D;area) </p><h4 id="Irradiance-Falloff"><a href="#Irradiance-Falloff" class="headerlink" title="Irradiance Falloff"></a>Irradiance Falloff</h4><p>光在传播路程中会衰减。radient Intensity 不会衰减。因为立体角的光就那些不会变。 但是Irradiance 会衰减。因为随着光传播越来越远。area 越来越大。单位面积对应的power越来越小。</p><h2 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h2><p>power per unit solid angle, per unit area. </p><p>做两次微分。跟立体角和单位面积都有关系。</p><ol><li>radiance &#x3D; Irradiance per soild angle</li><li>radiance &#x3D; Intensity per projected unit area</li></ol><h4 id="incident-radiance"><a href="#incident-radiance" class="headerlink" title="incident radiance"></a>incident radiance</h4><p>从一个方向过来而被吸收的能量叫做incident radiance。</p><p>irradiance 和 radiance的区别就是是否有方向性。我们描述一块区域上面有多少的能量是irradiance，但一个区域上面的能量可以是从四面八方吸收而来的，我们只考虑在这个区域中能吸收多少能量从特定角度而来的就是incident radiance。</p><h4 id="exiting-radiance"><a href="#exiting-radiance" class="headerlink" title="exiting radiance"></a>exiting radiance</h4><p>从一个方向出去的光强度从特定的区域和特定的角度。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/3.jpeg" width="500" height="200"> <br></center><p>如下图所示如果我们想判断所有方向射入目标面的光只需要积分即可。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/4.jpeg" width="500" height="300"> <br></center><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><h3 id="step-1-BRDF"><a href="#step-1-BRDF" class="headerlink" title="step 1 (BRDF)"></a>step 1 (BRDF)</h3><p>简单来说：如何把从一个方向接收到的能量反射到另一个方向去。</p><ol><li>是一个比例，一个area 从某一个方向接收到的radience乘以入射角后得到它的irridence。在反射成radience出去。</li><li>BRDF定义如何去分配向各个角度反射的光强弱。这也就区分了镜面反射还是漫反射。如果是漫反射各个方向大致相同。镜面反射的话会有一个着重点光线很强。</li></ol><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/5.jpeg" width="500" height="300"> <br></center><h3 id="step-2-refection-equation"><a href="#step-2-refection-equation" class="headerlink" title="step 2 (refection equation)"></a>step 2 (refection equation)</h3><p>刚才只考虑了一个方向现在考虑所有方向了。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/7.jpeg" width="500" height="300"> <br></center><h3 id="step-3-rendering-equation"><a href="#step-3-rendering-equation" class="headerlink" title="step 3 (rendering equation)"></a>step 3 (rendering equation)</h3><p>如果当前物体自己会发光。反射方程+自己的发光项</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/8.jpeg" width="500" height="300"> <br></center><h3 id="step-4-进一步运算"><a href="#step-4-进一步运算" class="headerlink" title="step 4 (进一步运算)"></a>step 4 (进一步运算)</h3><p>如果有多个光源。 反射方程递归。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/9.jpeg" width="600" height="300"> <br></center><p>如果光源并非点光源而存在面光源，积分上面的公式。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/10.jpeg" width="600" height="300"> <br></center><p>还需要考虑从其他物体上反射过来的光线（我们在这里就可以给其他物体上反射过来的光线当成是一种光源）。并且这是一个位置量。从下图可以看到。目前我们有两个未知量。所以采用递归。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/11.jpeg" width="600" height="300"> <br></center><p>简写渲染方程。最终得到：</p><p>我们想求的能量 &#x3D; 本身光源的能量 + K（反射能量符，可以讲能量反射掉）* L（能量）</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/12.jpeg" width="600" height="300"> <br></center><p>我们讲公式简化得到。</p><p>不弹射：   自己的光</p><p>弹射一次： 直接光照</p><p>弹射两次： 间接光照</p><p>弹射三次： 全局光照</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/13.jpeg" width="600" height="300"> <br></center><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/14.jpeg" width="600" height="300"> <br></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于图形学中渲染的光线追踪算法综述</title>
    <link href="/2022/08/19/%E5%85%B3%E4%BA%8E%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    <url>/2022/08/19/%E5%85%B3%E4%BA%8E%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract:"></a>abstract:</h3><p>Ray tracing is a method which could approximates real-world light sources.  With the rapid development of graphic cards , ray tracing is become p </p><p>光线追踪是一种可以模拟出近似与现实光照的方法，相较于传统光栅化它消耗的算力更为巨大但模拟的光源也更接近于现实。 近些年来随着硬件发展的迅速，计算机的算力已经可以允许我们大规模使用复杂的光线追踪进行渲染。把光线追踪分为。。。。 本文列举一些当前比较主流的光线追踪算法，并且详细描述了不同方法的优缺点与对整个CG领域的贡献。并在结尾总结了光线追踪的未来发展趋势。</p><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction:"></a>introduction:</h3><p> To compare it with rasterization , it cost more time to render.</p><p>关于现实生活中的光线得到历史。。</p><p>关于ray tarcing 的历史 。。最早的ray tracing 模型 LINKS-1 Computer 的简要介绍。。 </p><p>目前主流的ray tracing model 介绍 ： whitted-style。。 通常ray tracing 需要大量的算力进行计算。 但我们可以用一些加速方法。 比如BVH 。。。。</p><p>总的来说ray tracing 的基本流程是。。  我们首先有一个model 首先选用合适的加速方法。。 然后进行光追渲染。。。</p><h3 id="light-in-CG-VS-light-in-real-life"><a href="#light-in-CG-VS-light-in-real-life" class="headerlink" title="light in CG  VS light in real life"></a>light in CG  VS light in real life</h3><p>尽管光追能做到拟真是世界光源，但光线追踪和物理上光的反射不太一样，在cg中我们这么定义：</p><ol><li>光沿直线传播</li><li>光线相交互不影响</li><li>光路可逆，光线传入眼睛可以当作眼睛发出光线。</li></ol><p>但现实中的光源特点：</p><ol><li>接近于无限反射。直到电磁波消耗殆尽。</li><li>现实中的光是由一种电磁波。</li><li>不可能被计算机模拟。</li></ol><h3 id="光栅化-VS-光线追踪"><a href="#光栅化-VS-光线追踪" class="headerlink" title="光栅化 VS 光线追踪"></a>光栅化 VS 光线追踪</h3><p>因为光栅化没法做到很真实的物理效果，所以我们尝试使用光线追踪， 因为光追会显现出来更加真实的物理效果，反之会消耗更多的时间去渲染。</p><ol><li>光栅化只能反射2次。但光线追踪可以反射任意多次。</li></ol><h3 id="第一种类别的model-（whitted-style）"><a href="#第一种类别的model-（whitted-style）" class="headerlink" title="第一种类别的model （whitted-style）"></a>第一种类别的model （whitted-style）</h3><p>（在这里应该写出来这种model 属于那种类别。 对此类别进行分析 。 距离处whitted-style的优缺点）</p><p>就是将单一的pinhole camera model 进行递归 ，从而模拟出光线多次反射的效果 ，命名为recurive ray tracing 。但需要注意以下两点：</p><ol><li>光线强度会随着反射次数的增加而逐渐衰减。 </li><li>每个三角形的光都有可能是由很多个光源复合而成的。这里就涉及到了权重值问题，比如黄色光和红色光同时射入，这个三角形应该被渲染成橘色。但由于入射光的亮度可能不同，橘色的深浅也有不同。通过不断的累加颜色最终得到像素应该呈现的颜色。</li></ol><p>优点是：</p><p>缺点是：</p><h3 id="第二种类别的model-（）："><a href="#第二种类别的model-（）：" class="headerlink" title="第二种类别的model （）："></a>第二种类别的model （）：</h3><h3 id="关于model的加速结构-："><a href="#关于model的加速结构-：" class="headerlink" title="关于model的加速结构 ："></a>关于model的加速结构 ：</h3><p>BVM: </p><p>Oct-Tree (八叉树): 有不同的分法。比如不停的划分，直到其中有一块包围盒不包含物品位置。</p><p>KD-Tree(二叉树): 拼多多树，先横砍一刀沿物品切线。再每个包围盒竖直砍一刀。 目的是保持包围盒的均匀。三纬xyzxyz不断重复切。</p><p>BSP-Tree(二叉树): 也是不断砍。但是不好计算。之前我们提到的包围盒AABB就是因为沿着xyz轴的包围盒好被计算。</p><p>其他加速结构：</p><h3 id="应用辐射度量学来增强光线追踪的真实性："><a href="#应用辐射度量学来增强光线追踪的真实性：" class="headerlink" title="应用辐射度量学来增强光线追踪的真实性："></a>应用辐射度量学来增强光线追踪的真实性：</h3><p>\</p><h3 id="神经网络用于-ray-tracing-加速"><a href="#神经网络用于-ray-tracing-加速" class="headerlink" title="神经网络用于 ray tracing 加速"></a>神经网络用于 ray tracing 加速</h3><p>面临问题： 算法过于复杂。无法解决 。但我们可以引入机器学习model来加速</p><h3 id="总结与展望："><a href="#总结与展望：" class="headerlink" title="总结与展望："></a>总结与展望：</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dragon_model</title>
    <link href="/2022/08/19/dragon-model/"/>
    <url>/2022/08/19/dragon-model/</url>
    
    <content type="html"><![CDATA[<center><img src="/2022/08/19/dragon-model/1.mp4" alt="GAM GLM ..." width="900" height="300"> <br></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>games101_笔记(光追)</title>
    <link href="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/"/>
    <url>/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="intro-："><a href="#intro-：" class="headerlink" title="intro ："></a>intro ：</h2><p>因为光栅化(rasterization)没法做到很真实的物理效果，所以我们尝试使用光线追踪(ray tracing)， 因为光追会显现出来更加真实的物理效果，反之会消耗更多的时间去渲染。</p><h2 id="step-1-light-rays-："><a href="#step-1-light-rays-：" class="headerlink" title="step 1 (light rays)："></a>step 1 (light rays)：</h2><p>尽管光追能做到拟真是世界光源，但光线追踪和物理上光的反射不太一样，在cg中我们这么定义：</p><ol><li>光沿直线传播</li><li>光线相交互不影响</li><li>光路可逆，光线传入眼睛可以当作眼睛发出光线。</li></ol><h2 id="step-2（pinhole-camera-model"><a href="#step-2（pinhole-camera-model" class="headerlink" title="step 2（pinhole camera model):"></a>step 2（pinhole camera model):</h2><p>每一个像素（pixel）投射一个光线，寻找这条光线所经过的路径，并判断与光源之间有没有被遮挡。如图所示，从light source返回一条光束，在之后通过镜面反射进入人眼。<br>但这个模型只有一次反射，和光栅化区别不大。于是whitted提出下面的模型。</p><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/1.jpeg" alt="GAM GLM ..." width="450" height="300"> <br></center><h2 id="step-3-whitted-style"><a href="#step-3-whitted-style" class="headerlink" title="step 3 (whitted-style):"></a>step 3 (whitted-style):</h2><p>就是将单一的pinhole camera model 进行递归 ，从而模拟出光线多次反射的效果 ，命名为recurive ray tracing 。但需要注意以下两点：</p><ol><li>光线强度会随着反射次数的增加而逐渐衰减。 </li><li>每个三角形的光都有可能是由很多个光源复合而成的。这里就涉及到了权重值问题，比如黄色光和红色光同时射入，这个三角形应该被渲染成橘色。但由于入射光的亮度可能不同，橘色的深浅也有不同。通过不断的累加颜色最终得到像素应该呈现的颜色。</li></ol><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/2.jpeg" alt="GAM GLM ..." width="450" height="300"> <br></center><p>如上图所示，</p><ol><li>primary ray: 最终到达像素的光线。</li><li>secondary ray: 中间所有一系列反射的光线。（我不确定是不是只限定于第二次反射）</li><li>shadow ray: 从光源处发出的所有光线。</li></ol><h2 id="step-4-equation"><a href="#step-4-equation" class="headerlink" title="step 4 (equation):"></a>step 4 (equation):</h2><ol><li>Ray: r(t) &#x3D; o + td, 0 &lt;&#x3D; t &lt;&#x3D; ♾️</li></ol><p>任何光线上一点，可以用光线初始强度o + 时间t * 方向d 来表示。</p><ol start="2"><li>Sphere： p: (p-c)^2 - R^2 &#x3D; 0</li></ol><p>球上任何一个点p 到球心c 的距离为 R。</p><ol start="3"><li>联立上面两个公式得到：p: (o + td-c)^2 - R^2 &#x3D; 0</li></ol><p>公式之中只有t 是未知量。 直接可以求得。</p><ol start="4"><li>Plane Equation: p: (p - p’) . N &#x3D; 0</li></ol><p>通过法线N 和 平面上确定一点p‘ 来确定一个平面。 判断目标点p 到 p’的 向量是否垂直于法线N 来判断p 是否在目标平面上。</p><ol start="5"><li>把plane 和 ray equation 结合起来呢？</li></ol><p>我们得知光线上任意一点可以用r(t)来表示。如果这个点在我们的平面上， 也就是r(t)&#x3D;p。我们可以通过这个等式求得光在什么时间(t)能打到平面上进行折射。联立可以得到：t &#x3D; (p’ - o) . N &#x2F; d . N</p><p>注意： 我们需要检查一下t是不是非负数。</p><h2 id="step-5-Moller-Trumbore-Algorithm"><a href="#step-5-Moller-Trumbore-Algorithm" class="headerlink" title="step 5 (Moller Trumbore Algorithm):"></a>step 5 (Moller Trumbore Algorithm):</h2><p>所消耗时间更短。</p><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/3.jpeg" alt="GAM GLM ..." width="450" height="300"> <br></center><h2 id="step-6-（bounding-volumes）："><a href="#step-6-（bounding-volumes）：" class="headerlink" title="step 6 （bounding volumes）："></a>step 6 （bounding volumes）：</h2><p>如果一束光不与包围盒相交，那么他也不与物品相交。</p><p>我们需要尽可能的避免不必要的运算。方法是给每个物体装进一个长方形里面。如果光无法碰触到这个长方形。则我们不需要考虑这个物体余光的碰撞。我们通常设置这种长方形的长宽高沿着xyz轴。</p><p>如果光于包围盒相交：<br>包围盒里面有很多小包围盒。因为计算包围盒与光线是否相交的时间复杂度是高于光与物品相交的。如果光与小包围盒相交。然后进行反射计算。</p><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/4.jpeg" alt="GAM GLM ..." width="300" height="300"> <br></center><h2 id="step7-划分包围盒空间的结构"><a href="#step7-划分包围盒空间的结构" class="headerlink" title="step7 (划分包围盒空间的结构):"></a>step7 (划分包围盒空间的结构):</h2><p>Oct-Tree (八叉树): 有不同的分法。比如不停的划分，直到其中有一块包围盒不包含物品位置。</p><p>KD-Tree(二叉树): 拼多多树，先横砍一刀沿物品切线。再每个包围盒竖直砍一刀。 目的是保持包围盒的均匀。三纬xyzxyz不断重复切。</p><p>BSP-Tree(二叉树): 也是不断砍。但是不好计算。之前我们提到的包围盒AABB就是因为沿着xyz轴的包围盒好被计算。</p><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/5.jpeg" alt="GAM GLM ..." width="900" height="300"> <br></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于NeuralTalk2</title>
    <link href="/2022/07/17/%E5%85%B3%E4%BA%8ENeuralTalk2/"/>
    <url>/2022/07/17/%E5%85%B3%E4%BA%8ENeuralTalk2/</url>
    
    <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>参考的步骤进行配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/karpathy/</span>neuraltalk2<span class="hljs-regexp">/tree/</span><span class="hljs-number">3</span>c81602809b8b9e5bd3e9e213bf955986485dda7\<br></code></pre></td></tr></table></figure><p>我的环境是macOS + M1</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">$ curl -s https://raw.githubusercontent.com/torch/ezinstall/master/install-deps | bash<br>$ git clone https://github.com/torch/distro.git ~/torch --recursive<br>$ cd ~/torch; <br>$ ./install.sh      # and enter &quot;yes&quot; at the end to modify your bashrc<br>$ source ~/.bashrc <br></code></pre></td></tr></table></figure><p>接下来</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">$ luarocks install nn<br>$ luarocks install nngraph <br>$ luarocks install image <br></code></pre></td></tr></table></figure><p>在上面进行luarock安装的时候报错</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">Installing https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/torch/</span>rocks<span class="hljs-regexp">/master/</span>nn-scm-<span class="hljs-number">1</span>.rockspec...<br>Using https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/torch/</span>rocks<span class="hljs-regexp">/master/</span>nn-scm-<span class="hljs-number">1</span>.rockspec... switching to <span class="hljs-string">&#x27;build&#x27;</span> mode<br>正克隆到 <span class="hljs-string">&#x27;nn&#x27;</span>...<br>fatal: 无法连接到 github.com：<br>github.com[<span class="hljs-number">0</span>: <span class="hljs-number">140.82</span>.<span class="hljs-number">121.4</span>]: errno=Operation timed out<br></code></pre></td></tr></table></figure><p>我的解决方案有两个步骤</p><ol><li>(我觉得这个问题和这个步骤没关系) 我首先安装了lua</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">curl</span> <span class="hljs-literal">-R</span> <span class="hljs-literal">-O</span> http://www.lua.org/ftp/lua<span class="hljs-literal">-5</span>.<span class="hljs-number">4.3</span>.tar.gz<br><span class="hljs-variable">$</span> tar <span class="hljs-literal">-zxvf</span> lua<span class="hljs-literal">-5</span>.<span class="hljs-number">4.3</span>.tar.gz<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> lua<span class="hljs-literal">-5</span>.<span class="hljs-number">4.3</span><br><span class="hljs-variable">$</span> make<br></code></pre></td></tr></table></figure><ol start="2"><li>还是stackoverflow好用（不是 ，加这个命令行就好了。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git config --global url.https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/.insteadOf git:/</span><span class="hljs-regexp">/github.com/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>openGL学习笔记(1)</title>
    <link href="/2022/07/08/openGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2022/07/08/openGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<h1 id="“GLShaderManager-h”-和-“GLTools-h”"><a href="#“GLShaderManager-h”-和-“GLTools-h”" class="headerlink" title="“GLShaderManager.h” 和 “GLTools.h”"></a>“GLShaderManager.h” 和 “GLTools.h”</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>openGL的学习笔记</title>
    <link href="/2022/07/02/openGL%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/02/openGL%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模型的透明度</title>
    <link href="/2022/06/24/%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6/"/>
    <url>/2022/06/24/%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="explainable-AI-（XAI）"><a href="#explainable-AI-（XAI）" class="headerlink" title="explainable AI （XAI）"></a>explainable AI （XAI）</h1><h3 id="XAI"><a href="#XAI" class="headerlink" title="XAI"></a>XAI</h3><p>指的是让人们明白这个模型是为什么得到这个结果的。因为AI有可能会作弊。比如通过看图片是否有copyright里面是不是有马的字段来判断图片是不是马。</p><p>XAI 我们就可以不断的人为优化模型。</p><p>black-box AI， 与XAI相反。 我们不知道模型通过什么得到的结果也不知道如何优化。</p><h3 id="各种learning"><a href="#各种learning" class="headerlink" title="各种learning"></a>各种learning</h3><p>监督学习(supervised learning):<br>  每个数据都有对应的label。良性肿瘤和恶性肿瘤。</p><p>无监督学习(unsupervised learning):<br>  数据没有labels。我们不知道每一个数据对应的什么意思。比如google有上千个新闻。我们没发给每一个加上label。我们就可以通过”聚类”的形式来将相似的定为一个专栏，达成新闻分类。</p><p>表示学习(representation learning):<br>  不同方法来表示学习。比如hsv和rgb都可以表示颜色。</p><center><img src="/2022/06/24/%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6/1.jpeg" alt="各种学习的精准度和可解释度" width="256" height="256"> <br>各种学习的精准度和可解释度</center><h3 id="各种model"><a href="#各种model" class="headerlink" title="各种model"></a>各种model</h3><h4 id="Interpretable-Models"><a href="#Interpretable-Models" class="headerlink" title="Interpretable Models"></a>Interpretable Models</h4><p>• Decision Trees, Lists a ,Sets and rules <br>基本的if else</p><p>• GAMs <br>• GLMs <br>• Linear regression <br>• Logistic regression \</p><center><img src="/2022/06/24/%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6/2.jpeg" alt="GAM GLM ..." width="1300" height="150"> <br>GAM GLM ...</center><p>• KNNs</p><h3 id="End-to-End-XAI"><a href="#End-to-End-XAI" class="headerlink" title="End-to-End XAI"></a>End-to-End XAI</h3><p>比传统的represtation learning 多了更多的不同等级的特征。 比如：<br>simple feature -&gt; complex feature -&gt; more complex feature。<br>这种结构对模型参数的调节空间更大。</p><h3 id="Shapley-Additive-Explanation"><a href="#Shapley-Additive-Explanation" class="headerlink" title="Shapley Additive Explanation"></a>Shapley Additive Explanation</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BIG-bench</title>
    <link href="/2022/06/24/BIG-bench/"/>
    <url>/2022/06/24/BIG-bench/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>我的笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习如何使用openai</title>
    <link href="/2022/06/21/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8openai/"/>
    <url>/2022/06/21/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8openai/</url>
    
    <content type="html"><![CDATA[<h3 id="text-davinci-002"><a href="#text-davinci-002" class="headerlink" title="text-davinci-002"></a>text-davinci-002</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>never ending learning 笔记</title>
    <link href="/2022/06/07/never_ending_learning/"/>
    <url>/2022/06/07/never_ending_learning/</url>
    
    <content type="html"><![CDATA[<p> NELL 早期采用 Carlson et al. 模型。它的作用是阅读Web来获取信息。<br><p>输入：<br></p><ol><li>一个初始的 ontology 里面存放着很多categories （运动，运动员）。一个二原组的realtion 表示着 categories之间的关系。 比如：  哪个运动员在玩什么运动（x,y）。<br></li><li>每一个relation 或者是 categories 都有差不多12个labels， 比如运动有足球篮球一类的名词。<br></li><li>Web 从ClueWeb（一个有着1亿个网页的数据集）中获得。并且Google授权了NELL 10万个搜索问题的api。<br></li><li>偶尔会有人为参与。<br></li></ol><p>做什么：<br></p><ol><li>抓去更多的信息从web 并且移除老的不正确的信息。在这个过程中数据集不断的增长并且每一个information都有着出处和可信度。</li><li>每天学习如何比昨天读得更好</li></ol><p>总体来讲，NELL软件层面上的架构是：beliefs通过NEIL，OntExt 等一些辨别手段来选出一些候选的beliefs 再通过knowledge integrator 来对原有的beliefs 进行更新。</p><p>期望最大化算法（EM）:在概率模型中寻找最大似然<br><br>似然 (likelihood):对于模型的不同参数出现目标样本的概率是多少<br><br>知识整合 (Knowledge Integration): 就是将多个知识模型转化为一个公用的模型。像是通过多种角度判断一个游戏的好坏，比如画面模型，剧情模型。 将这些模型整合起来来得到一个评判游戏的好坏程度的模型。</p><p>NELL 的学习过程类似于EM用于半监督学习。每一次循环都有E-like step 和 M-like step。<br></p><ol><li>E-like step : 所有的beliefs 都需要重新被估计。在NELL中的每一个reading和inference 模型 都需要更新到KB之中（曾加或者减少一些beliefs）。通过知识整合（KI）我们将一大堆独立的建议转化为对每一个潜在kb 里面的 belief 的可信度。<br></li><li>M-like step :对上面更新的每一个模型都做一个针对于他们的学习算法。得到了一个上千个互相关联的学习任务。<br></li></ol><p>NELL因为做不到完全EM算法。所以我们在进行E-like的时候设置一个upperbound。那些有高可信度的新的belief才会被我们考虑并更新到KB之中。<br>并且当我们更新的时候，采用limited-radius fashion的方式。简单来说就是我们只考虑当前更新的belief直接相关的beliefs的更新，不再做进一步的考虑。</p><h2 id="Knowledge-Integrator"><a href="#Knowledge-Integrator" class="headerlink" title="Knowledge Integrator"></a>Knowledge Integrator</h2><p>KI只考虑类别类型一致的beliefs。比如他只检验在relation triple中的实体类型是不是与realtion一致。而不是考虑用一个新的triple作为一个触发器来更新beliefs在同一次循环之中。</p><h2 id="新增学习任务和实体"><a href="#新增学习任务和实体" class="headerlink" title="新增学习任务和实体"></a>新增学习任务和实体</h2><h3 id="OntExt"><a href="#OntExt" class="headerlink" title="OntExt"></a>OntExt</h3><p>OntExt 创建新realtion。他通过寻找像所有已经有的实体，去寻找那个最新最经常被考虑的relation，把他用于链接两个实体。实现这个过程分为三步：</p><ol><li>一个句子中如果有已经存在的category pair了。就将它直接提取出。像是&lt;动物，食物&gt;。狗在吃肉。 狗和肉就被提取出来了。</li><li>把一个文章构建出一个2D矩阵用来寻找新的relation。</li><li>OntExt自动发现新的relations。发现了之后立刻做为一个触发器用来适应于新的句子。</li></ol><h3 id="VerbKB"><a href="#VerbKB" class="headerlink" title="VerbKB"></a>VerbKB</h3><p>动词和动词短语经常用于表达名词之间的关系。有点像是一个动词的模式，用来分析主语，宾语还有动词短语之间的关系。作为一个三元组。&lt;主语category，动词短语，宾语category&gt;。NELL已经有6.5w个动词了。覆盖了ClueWeb2010的98%。现在正在寻找扩大这个动词规模的方法。</p><h3 id="关于自我评估和自我反思"><a href="#关于自我评估和自我反思" class="headerlink" title="关于自我评估和自我反思"></a>关于自我评估和自我反思</h3><p>期望NELL可以针对于他应该着重学习的地方进行学习而不是像现在这样只会检测没有。目前的研究目标就是把未标记的数据用作数据集。我们可以这么来做：通过Platanios et al.32我们知道如果我们有三个或者更多的funciton用来求解。我们判断是否所有的函数得到的都是同一个名词，因为他们判断成功与否是独立的。所以可以通过他们的精准度来判断模型的好坏。通过这种方式精准度在逐年增加。<br>NELL对于不同种类的词语表现相差很多。比如对河流，身体部分这种精准度能到95% 但是对于国家的首都精准度就很低。原因有两种：</p><ol><li>有可能我们的目标得到的结果并不在我们想要的集合里面，我们就给他新定义一个集合。可能这个集合只能被他自己所用，并且会误导别的我们想要测试的目标的正确性。</li><li>可能NELL已经弄错了，由于错误的传播谓语。就比如我们目前的NELL他判定所有的星球名字都以什么什么球为结尾。如果我们拿出来一个不是以球结尾的他就没法正确判断了。</li></ol><p>有一些很简单的词汇被复杂化了。比如开心 -&gt; 难以置信的开心。这使得学习任务变得越来越多。未来的研究就是让他有自我反思的能力。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>NELL 作为一个早期的案例有很多我们吸取教训的地方：</p><ol><li>coupling constraints限制了后续学习其他任务。</li><li>允许去学习新的coupling constraints。</li><li>现阶段模型是a-b c-d ， a-b-c-d是一个全新的模型。未来需要做到的是把a-b 作为一个谓词短语 来使用。 已达成（a-b）- (c-d)的目的。</li></ol><p>NELL的限制：</p><ol><li>没有反思。他不会意识到自己做错了很久且没有任何进展。也没有监控自己性能的能力。</li><li>有些方法是固定的。可塑性很差。比如寻找名词或者名词短语这种方法。我们是无法进行学习或者更改的。</li><li>目前NELL只用了一个简单的frame base。 他没有框架去推到时间和空间。</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>我的笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
