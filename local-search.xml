<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>CS5010-notes</title>
    <link href="/2023/09/12/CS5010-notes/"/>
    <url>/2023/09/12/CS5010-notes/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CS5800 notes</title>
    <link href="/2023/09/11/CS5800-notes/"/>
    <url>/2023/09/11/CS5800-notes/</url>
    
    <content type="html"><![CDATA[<h1 id="week-1"><a href="#week-1" class="headerlink" title="week 1"></a>week 1</h1><h2 id="1-1-linear-x2F-chunk-x2F-binear-search"><a href="#1-1-linear-x2F-chunk-x2F-binear-search" class="headerlink" title="1.1 linear&#x2F;chunk&#x2F;binear  search"></a>1.1 linear&#x2F;chunk&#x2F;binear  search</h2><p>这三种方法都是有序查找使用的</p><h3 id="chunk"><a href="#chunk" class="headerlink" title="chunk"></a>chunk</h3><p>分割成一堆block，每一个block都是一个linear<br><img src="/2023/09/11/CS5800-notes/1.jpg"></p><p>Chunk的复杂度 $O(\frac{n}{c} + c)$,把所有的循环都走一边，再走一遍步长。</p><p>让$O(\frac{n}{c} + c)$尽可能的小，也就是$\frac{n}{c}$ &#x3D;&#x3D; $c$ </p><p>最终得到时间复杂度为 $O(\sqrt{n})$</p><h3 id="binary"><a href="#binary" class="headerlink" title="binary"></a>binary</h3><p>经典二分<br><img src="/2023/09/11/CS5800-notes/2.jpg"><br>时间复杂度用递归法(recursive algorithm)，<br>$T(n) &#x3D; T(\frac{n}{2})+1 , T(1) &#x3D; 1$<br>最终为 $O(log_2n)$</p><h2 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h2><ul><li>Linear time  ep. $O(1)$</li><li>Logarithmic time ep. $O(logn)$</li><li>Polynamial time ep. $O(n^1+n^2+n^3)$</li><li>Exponential time ep. $$O(2^n)$$</li><li>factorial time ep. $O(n!)$ 5! &#x3D; 5x4x3x2x1</li></ul><p>不考虑constants</p><ul><li>big-$O$ : upper bound</li><li>big-$\Omega$ : lower bound</li><li>big-$\Theta$ : tight bound</li></ul><h2 id="lecture"><a href="#lecture" class="headerlink" title="lecture"></a>lecture</h2><ul><li>efficiency Time and Space 消耗</li><li>effectiness 证明是对的</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>my journey of UE5</title>
    <link href="/2023/09/10/my-journey-of-UE5/"/>
    <url>/2023/09/10/my-journey-of-UE5/</url>
    
    <content type="html"><![CDATA[<ul><li></li></ul><h1 id="Chapter-1"><a href="#Chapter-1" class="headerlink" title="Chapter 1"></a>Chapter 1</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>IOT</title>
    <link href="/2023/05/14/IOT/"/>
    <url>/2023/05/14/IOT/</url>
    
    <content type="html"><![CDATA[<h1 id="last-dance"><a href="#last-dance" class="headerlink" title="last dance"></a>last dance</h1><h2 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h2><p>定义了key management , security protocols(AH,ESP), security policies(type of encryption and authentication to be used), direction of traffic(one-direction , inbound and outbound 都需要).</p><p>SA one-direction</p><p>Initiator(I) -&gt; Responder(R)</p><p><img src="/2023/05/14/IOT/34.jpeg"></p><p>transport mode<br><img src="/2023/05/14/IOT/35.jpeg"><br>tunnel mode<br><img src="/2023/05/14/IOT/36.jpeg"></p><h3 id="IPsecs"><a href="#IPsecs" class="headerlink" title="IPsecs"></a>IPsecs</h3><ul><li>Transport Mode vs Tunnel Mode: transport只加密payload(数据),tunnel model 同时加密head和payload。 AH 无论用哪个model都不可以加密。上诉情况是指ESP。</li><li>AH(Authentication Header): <ul><li>data origin authentication  数据来源认证</li><li>data integrity 完整性</li><li>anti-replay 防重放 (SequenceNumber),IPsec header中有一个每个data package 的唯一序列号。从SA第一个数据报开始。</li><li>does not provide confidentiality protection  不提供保密性保护</li><li>outboard(sender)<ul><li>SA lookup : SA 由key , security protocal(AH, ESP), security parameters index(SPI)组成。</li><li>生成序列号</li><li>计算MAC</li></ul></li><li>inboard(receiver)<ul><li>Resumably(重组):较大数据需要被分割fragmented, 所以收到后要reassemble重组。</li><li>SA lookup : receiver 确定是正确的SA.</li><li>Sequence Number Verification</li><li>MAC 验证: 确保信息没有被修改。</li></ul></li></ul></li><li>ESP(Encapsulating Security Payload):<ul><li>outboard SA lookup 后面加密。 encrypt-then-mac 比mac-then-encrypt 或者mac-and-encrypt 更安全。在密码文本上计算mac，防止padding oracle attack(填充神谕攻击)</li><li>inboard MAC 之后解密。</li><li>比AH authentication认证更窄,因为AH保护所有数据，ESP不保护head。不需要confidentiality保密的时候AH是一个合适的协议。</li></ul></li></ul><h3 id="CA-和-KDC"><a href="#CA-和-KDC" class="headerlink" title="CA 和 KDC"></a>CA 和 KDC</h3><p>CA 是 asymmetric 的 , KDC 是 symmetric的。</p><h2 id="Hash-MAC-HMAC"><a href="#Hash-MAC-HMAC" class="headerlink" title="Hash , MAC , HMAC"></a>Hash , MAC , HMAC</h2><p>Mac 不能提供 confidentiality, 因为没有加密<br>HMAC 加密的Hash function 和 key</p><h3 id="Security-Requirements-x2F-Properties-of-Hahs-安全特性"><a href="#Security-Requirements-x2F-Properties-of-Hahs-安全特性" class="headerlink" title="Security Requirements&#x2F;Properties of Hahs(安全特性)"></a>Security Requirements&#x2F;Properties of Hahs(安全特性)</h3><ol><li>Preimage resistant(one-way单向性): 无法反向。</li><li>2nd preimage resistant(week coliision resistance弱碰撞性): hash 很难对应两个plaintext。</li><li>Collision resistance (strong collision resistance强抗碰撞): 两个plaintext 很难找到相同的hash。<h3 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h3></li></ol><p>HMAC(K, M)&#x3D; H[(K+ XOR opad) || H[(K+ XOR ipad) || M]]; </p><h3 id="CBC-MAC"><a href="#CBC-MAC" class="headerlink" title="CBC-MAC"></a>CBC-MAC</h3><h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><ul><li><p>Replay attack: eve拦截了data package 并且transmit很多次，让recipient以为自己收到了很多次。</p></li><li><p>padding oracle attack填充神谕攻击: eve利用解密过程中的错误信息来得到plaintext的内容。通常是mac直接通过plaintext得到而造成的。</p></li><li><p>meet-in-the-middle attack: 发生在双重加密之中。对前半段解密，后半段猜测为加密的信息进行加密。两者重合，寻找密钥。证明了双重加密无法提供两倍的安全性，所以三重。</p></li><li><p>cookie hijacking: 会话劫持，如果信息都暴露通常也伴随着被会话劫持。</p></li><li><p>brute force attack:</p></li><li><p>dictionary Attack: eve尝试生日，常见组合来破解密码。</p></li><li><p>rainbow table attack : 预先计算好的表，反转加密的hash function, 就是破解hash值的dictonary attack.</p><h2 id="security-properties"><a href="#security-properties" class="headerlink" title="security properties"></a>security properties</h2></li><li><p>integrity : 完整性 Hash.</p></li><li><p>confidentiality :  保密性</p></li><li><p>authenticity : 验证来源，CA.</p></li><li><p>non-repudiation: 不可抵赖性, 通常通过digit signature.</p></li><li><p>authorization: 授权。不同的用户有不同的权限。</p></li></ul><h2 id="AES-block-cipher"><a href="#AES-block-cipher" class="headerlink" title="AES(block cipher)"></a>AES(block cipher)</h2><p>DES 8 bytes block , AES 16 bytes block.</p><p><img src="/2023/05/14/IOT/17.jpeg"></p><h3 id="formula"><a href="#formula" class="headerlink" title="formula"></a>formula</h3><ol><li>EDE2(triple DES using 2 keys) : C &#x3D; EK1(DK2(EK1(M)))   </li><li>EDE3(triple DES using three keys):  C &#x3D; EK3(DK2(EK1(M)))   </li><li>AES</li><li>ECB : Cn &#x3D; E(K, Mn) ;  Mn &#x3D; D(K, Cn); n &#x3D; {1, 2, …}. (别忘了padding)</li><li>CBC : Ci &#x3D; E(K , Mi XORCi-1), where C0 &#x3D; IV (Initialization Vector) ; Mi &#x3D; D(K, Ci) XOR Ci-1 , M0 &#x3D; IV (别忘了padding)</li><li>CTR : Ci &#x3D; E(K, Counter + i) XOR Mi; i &#x3D; {1, 2, …}. Mi &#x3D; E(K, Counter + i) XOR Ci ; i &#x3D; {1, 2, …}.<h2 id="Stream-Cipher"><a href="#Stream-Cipher" class="headerlink" title="Stream Cipher"></a>Stream Cipher</h2>流密码是一种对称密钥加密算法，一次对明文数据进行加密，每次加密一个比特或字节。它们通过生成一个密钥流进行操作，密钥流是由秘密密钥产生的一个比特或字节序列。然后，密钥流与明文使用位XOR操作相结合，产生密码文本。å</li></ol><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>Bitwise XOR 效率高</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>Key length 密钥必须和明文一样长，这在大多数应用场景中是不现实的</li><li>如果同一个密钥被用于多个明文，流密码就会受到攻击。能够获得两个明文的XOR（M1 XOR M2）的攻击者，如果能够获得另一个plaintext及其相应的密码文本（M1和C1），就可以恢复其中一个明文。这是因为将M1与C1进行XOR（即M1 XOR K）会得到密钥K，然后攻击者可以使用K来解密C2（即M2 XOR K）并恢复M2。</li></ol><h3 id="stream和block-的区别"><a href="#stream和block-的区别" class="headerlink" title="stream和block 的区别"></a>stream和block 的区别</h3><ol><li>block 对字符块进行加密，stream对单个bit\character进行加密。</li></ol><h3 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h3><p>etc&#x2F;shadow 存放password,只有root才有权限查看</p><p>croe: 14mo31bmRY0Yg: 12:31:Cathy Roe: &#x2F;home&#x2F;croe:&#x2F;bin&#x2F;csh</p><ul><li>unix password file: &#x2F;etc&#x2F;passwd</li><li>User Name : croe</li><li>Password (14mo31bmRY0Yg) : salt value(14) + hash password </li><li>User ID(UID) : 12</li><li>Group ID(GID) : 31</li><li>Home Directory (&#x2F;home&#x2F;croe)</li><li>Shell (&#x2F;bin&#x2F;csh)</li></ul><h3 id="RSA-step"><a href="#RSA-step" class="headerlink" title="RSA step"></a>RSA step</h3><p>two prime number p,q<br>f(n) &#x3D; (p-1)(q-1)<br>1 &lt; e &lt; f(n)<br>d x e &#x3D; 1 mod f(n)<br>KPU &#x3D;  {e,n}<br>KPR &#x3D;  {d,n}<br>encrypt: message M &lt; n , C &#x3D; M^e mod n<br>decrypt: M &#x3D; C^d mod n</p><h2 id="attack-tree"><a href="#attack-tree" class="headerlink" title="attack tree"></a>attack tree</h2><p>shoulder surfing<br>false terminal<br>insiders<br>maintenacnce contractor<br>cryptanalysis DES<br>protocol failure   </p><h2 id="malware"><a href="#malware" class="headerlink" title="malware"></a>malware</h2><h3 id="stack-overflow-attack"><a href="#stack-overflow-attack" class="headerlink" title="stack overflow attack"></a>stack overflow attack</h3><p>攻击者向你的程序发送数据，通常是通过输入字段，其数量超过你的程序所期望的或可以处理的。</p><p>这些多余的数据会溢出到堆栈的邻近部分。如果攻击者精心设计了他们的输入，他们可以用他们输入的一些恶意代码的地址覆盖堆栈上的一个函数的返回地址。</p><p>当函数执行完毕后，它不是返回到它被调用的地方，而是返回到新的返回地址所指定的位置–这就是恶意代码。这可能允许攻击者获得对系统的未授权访问或造成其他类型的损害。</p><p>这就是为什么它被称为堆栈溢出攻击 – 因为攻击者用数据溢出了堆栈的一部分，导致它溢出并覆盖了关键信息。</p><p>这是对堆栈溢出攻击如何工作的一个非常基本的描述。这种攻击有许多变化，防御它可能很复杂。</p><h3 id="prevent"><a href="#prevent" class="headerlink" title="prevent"></a>prevent</h3><p>Stackguard: 这个系统在函数的执行过程中，在返回地址之前的内存空间中插入一个已知的值，通常称为金丝雀。当函数结束时，将检查金丝雀的值。如果该值发生了变化，程序就知道发生了缓冲区溢出，可以停止执行，防止溢出造成更大的破坏</p><p>Data Execution Prevention: 这种机制将内存的区域标记为不可执行。这意味着，即使攻击者成功地将恶意代码注入这些区域，系统也不会执行它，从而挫败了攻击</p><p>Address Space Randomization: 这种技术将内存中不同元素（如堆栈、库等）的位置随机化。这使得攻击者更难预测在哪里注入恶意代码，或关键数据结构的位置，增加了成功执行缓冲区溢出攻击的难度</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Cyber_security</title>
    <link href="/2023/04/24/Cyber-security/"/>
    <url>/2023/04/24/Cyber-security/</url>
    
    <content type="html"><![CDATA[<h1 id="PGP"><a href="#PGP" class="headerlink" title="PGP"></a>PGP</h1><h2 id="digital-signatures"><a href="#digital-signatures" class="headerlink" title="digital signatures"></a>digital signatures</h2><p>sender 用一个cryptographic function(比如SHA-256)来计算发送信息的hash(digest)，这个hash表示的message是独一无二的，定长的。再使用sender自己的private key使用 asymmetric algorithm (比如RSA&#x2F;DSA)对这个hash进行签名, recipient 再用sender的public key进行验证。</p><h2 id="message-encryption-x2F-confidentiality"><a href="#message-encryption-x2F-confidentiality" class="headerlink" title="message encryption &#x2F; confidentiality"></a>message encryption &#x2F; confidentiality</h2><p>PGP 使用hybird encryption(混合加密), symmetric encryption(对称加密) 用于encrypt实际信息, asymmetric encryption(非对称加密) 用于加密session key和digital signatures.</p><h2 id="完整步骤"><a href="#完整步骤" class="headerlink" title="完整步骤"></a>完整步骤</h2><p><img src="/2023/04/24/Cyber-security/2.jpeg"></p><h2 id="PGP-Services"><a href="#PGP-Services" class="headerlink" title="PGP Services"></a>PGP Services</h2><h3 id="confidentiality-only"><a href="#confidentiality-only" class="headerlink" title="confidentiality only"></a>confidentiality only</h3><p>If you only use PGP to encrypt your information (confidentiality(保密性)), you protect the message from unauthorized access, but you do not guarantee its integrity(完整性).</p><p>Z&#x2F;Z-1: 压缩和解压操作。PGP在加密前对信息进行压缩，以节省空间和减少传输时间。<br>EC&#x2F;DC: 对称密钥的加密和解密操作。这些操作是使用会话密钥进行的。<br>EP&#x2F;DP： 公钥加密和解密操作。这些操作使用收件人的公共和私人密钥进行。<br>‘||’: 连接，即把两个或多个数据连接在一起。<br>综上所述，描述了PGP如何通过用对称会话密钥加密信息内容，然后用收件人的公开密钥加密会话密钥来为信息提供保密性。这个过程不涉及数字签名或消息认证和完整性检查。<br><img src="/2023/04/24/Cyber-security/1.jpeg"></p><h3 id="Confidentiality-and-Authentication"><a href="#Confidentiality-and-Authentication" class="headerlink" title="Confidentiality and Authentication"></a>Confidentiality and Authentication</h3><p>Authentication(digital signatures(数字签名))，就可以保证了integrity(完整性)。<br><img src="/2023/04/24/Cyber-security/3.jpeg"></p><h2 id="PGP-Message-Format"><a href="#PGP-Message-Format" class="headerlink" title="PGP Message Format"></a>PGP Message Format</h2><ol><li>Session key component: 该组件包含会话密钥和发件人用于加密会话密钥的收件人公钥的标识符。会话密钥是为每条信息生成的唯一的、一次性的密钥，用于使用对称加密算法（如AES）对信息内容进行加密。为了安全地将会话密钥传输给收件人，发件人使用收件人的公钥和非对称加密算法（如RSA）对其进行加密。包括收件人公钥的标识符，确保收件人知道他们的公钥中哪一个被使用，以防他们有多个公钥。</li><li>Message component: 该组件包含要传输的实际数据，使用会话密钥进行加密。除了加密的信息内容外，信息组件还包括元数据，如文件名和指定信息创建时间的时间戳。文件名可以帮助收件人了解消息的背景或目的，而时间戳则有助于跟踪消息的年龄并确保其相关性。</li><li>Signature component: Timestamp(时间戳)目的是产生签名时间。Message digest(信息摘要)，结合签名时间，可以用来验证消息的完整性。</li><li>前两个字节: 当收件人使用发件人的公钥对信息摘要（数字签名）进行解密时，他们将获得信息内容的原始哈希值和签名的时间戳。然后，他们可以将这个解密的哈希值的前两个字节与包含在签名组件中的消息摘要的前两个字节的明文副本进行比较。<br>如果这前两个字节相匹配，就表明解密时使用了正确的公钥，并且该信息被认为是真实的。然后，收件人可以继续对收到的消息内容结合签名时间戳生成一个新的哈希值，并将其与解密后的哈希值进行比较。如果两个哈希值相匹配，就可以确认该消息在传输过程中没有被篡改，可以安全使用。<br>通过这种方式，PGP消息格式确保了消息的认证和完整性，使收件人可以验证发件人的身份和消息的完整性。</li></ol><h2 id="key-rings"><a href="#key-rings" class="headerlink" title="key rings"></a>key rings</h2><p>PGP使用key rings来存储公钥和私钥。key rings是一个文件，包含了公钥和私钥。key rings可以分为两类：public key rings和private key rings。public key rings包含了公钥，private key rings包含了私钥。 sender 和 recipients 都有自己的key rings。</p><h3 id="key-identifiers-key-ID"><a href="#key-identifiers-key-ID" class="headerlink" title="key identifiers (key ID)"></a>key identifiers (key ID)</h3><p>recipients 怎么知道一条接受的message是用哪个public key?</p><ol><li>message和public key同时发送给recipients</li><li>使用key identifier 去识别一个public key特别是在key server上的。</li></ol><p>PGP 使用后者，UserID x key ID。key ID 是public key的hash，用来识别public key。ie. KeyID &#x3D; $KU_a mod 2^{64}$. 私钥(KR),公钥(KU), 特定用户a,所以KU_a指的是用户a的公钥。这句话的意思是指就指计算一个private key的时候，应该使用用户KU中最没有意义的64位。</p><p>A private-key ring to store the private&#x2F;public key pairs owned<br>by this user.<br>A public-key ring to store the public keys of other users known<br>to this user.  </p><p>Both key rings can be indexed by either User ID or Key ID.</p><h3 id="encryption-private-key"><a href="#encryption-private-key" class="headerlink" title="encryption private key"></a>encryption private key</h3><p>encencrypted private key &#x3D; $EC_{H(Pi)}[PR_i]$</p><p>$PR_i$ : User i’s private key  </p><p>CAST-128(C): A symmetric algorithm</p><p>Key-encryption key: 用于加密User’s private key($PR_i$)的key，是由用户选择的passphrase(口令): $Pi$生成的。  </p><p>Passphrase(口令 Pi): 类似于密码，但是比密码更长，更复杂。每一个private key应该有与之对应的一个passphrase。  </p><p>Hash function(H): 输入Passphrase(Pi),输出一个hash code(H)，这个hash code(H)用于求出key-encryption key。</p><p>encryption process(E): 加密过程</p><h3 id="private-key-rings"><a href="#private-key-rings" class="headerlink" title="private-key rings"></a>private-key rings</h3><p>pairs : {private key : public key}</p><p>有点类似于windows，每一行就是windows的一个user，我可以有多个user。</p><p>Timestep 是创建这个用户的时间。</p><p><img src="/2023/04/24/Cyber-security/4.jpeg"></p><h3 id="PGP-Trust-Model"><a href="#PGP-Trust-Model" class="headerlink" title="PGP Trust Model"></a>PGP Trust Model</h3><h4 id="Web-of-Trust"><a href="#Web-of-Trust" class="headerlink" title="Web-of-Trust"></a>Web-of-Trust</h4><p>Owner Trust: PGP user 信任key’s owner to sign public-key certificates(public key签署的公共密钥证书的信任程度).<br>e.g.</p><ul><li>ounknown user</li><li>opartially trusted user</li><li>ofully trusted user</li></ul><p>Signature Trust: 证书的签名者(certificate signer)对用户身份的信任程度。这个值在key server(钥匙服务器)与certificate signed 一起公开。比如Ailice signs(certifies) Bob‘s key，也就是她生命信任Bob的身份。</p><p>Key Legitimacy: 该PGP用户对public key的拥有者的身份的信任程度。至少有一个Signature fully trusted , 或者两个Signature partially trusted.</p><p><img src="/2023/04/24/Cyber-security/5.jpeg"></p><h4 id="Public-key-revocation-公钥废止"><a href="#Public-key-revocation-公钥废止" class="headerlink" title="Public key revocation(公钥废止)"></a>Public key revocation(公钥废止)</h4><ol><li>与公钥相关的私钥被破坏</li><li>所有者不再需要该证书</li></ol><p>这个步骤是右所有者发出一个废止证书(revocation certificate)。这个证书中包含着public key to be revoked，和private key’s signature.</p><p><img src="/2023/04/24/Cyber-security/6.jpeg"></p><h3 id="Generation-of-the-signature-component"><a href="#Generation-of-the-signature-component" class="headerlink" title="Generation of the signature component"></a>Generation of the signature component</h3><ol><li>Signing a message : sender 决定使用PGP对信息进行签名从而提供Authenticity 和 integrity.</li><li>Retrieving the sender’s private key: sender 从key ring中找到自己的private key.</li><li>prompting for passpharse: sender 输入passphrase，用于解密private key.</li><li>constructing the signature component: 在private key 被解密之后，PGP会结合message’s content生成一个signature component。然后这个签名会被添加到信息之中。</li><li>recipient 收到信息之后，可以用签名和public key来验证信息完整性切没有被修改，和确实来自用户ID这个人。</li></ol><h3 id="generation-of-the-session-key-component"><a href="#generation-of-the-session-key-component" class="headerlink" title="generation of the session key component"></a>generation of the session key component</h3><ol><li>generating a session key: sender 生成一个session key，用于加密信息。</li><li>encrypting the Message: sender 用session key加密信息。</li><li>retrieving the recipient’s public key: sender 从key ring中通过User ID 作为index来找到recipient的public key。</li><li>constructing the session key component: PGP 对session key进行加密。</li><li>recipient 收到的message由两部分组成，session key component（使用recipient的public key加密的） 和 加密信息本身。</li><li>recipient 用自己的private key解密session key component，然后用session key解密信息本身。</li></ol><h2 id="Exercise-Question-–-E10-1"><a href="#Exercise-Question-–-E10-1" class="headerlink" title="Exercise Question – E10.1"></a>Exercise Question – E10.1</h2><p>In secure email systems, such as PGP (pretty good privacy), the order<br>of message protection operations performed by a sending entity is to<br>first sign the outgoing&#x2F;email message, then compress the signed<br>message, and finally encrypt the compressed message. Answer the<br>following questions:  </p><p>(i) What are the justifications (or benefits) for using this order of<br>operations?</p><p>(ii) Would this order of operations be suitable for all cases of<br>applications?</p><p>(iii) Assuming that Alice sends Bob an email, M. Express the whole<br>message that is sent by Alice using protocol notation format?</p><ol><li>Signature verification can only be carried out after two decryption<br>operations and this makes the solution vulnerable to DoS attacks.<br>However, as this is an end user to end user communication at the<br>application level, so the issue of DoS attacks is considered not as<br>important as users’ preference of record-keeping a signed email (on<br>plaintext). Compression-then-encryption can bring two benefits, one is<br>security (harder to break a text that is not recognisible) and the other is<br>performance (cheaper to encrypt a shorter message)</li></ol><h1 id="Software-security-Malware"><a href="#Software-security-Malware" class="headerlink" title="Software security (Malware)"></a>Software security (Malware)</h1><h2 id="Viruses-病毒"><a href="#Viruses-病毒" class="headerlink" title="Viruses(病毒)"></a>Viruses(病毒)</h2><h3 id="Viruses-Classifications-病毒分类"><a href="#Viruses-Classifications-病毒分类" class="headerlink" title="Viruses Classifications(病毒分类)"></a>Viruses Classifications(病毒分类)</h3><h4 id="Classification-by-concealment-strategy-隐蔽性策略分类"><a href="#Classification-by-concealment-strategy-隐蔽性策略分类" class="headerlink" title="Classification by concealment strategy(隐蔽性策略分类)"></a>Classification by concealment strategy(隐蔽性策略分类)</h4><ol><li>Polymorphic virus(多态性病毒): changees its appearance, control flow or other characteristics 当infects a new host.</li><li>Metamorphic virus(变态病毒): 更牛逼，传播的时候还改变了自己的代码，不仅改变了外观，还改变了行为。</li></ol><h4 id="Classification-by-target-目标分类"><a href="#Classification-by-target-目标分类" class="headerlink" title="Classification by target(目标分类)"></a>Classification by target(目标分类)</h4><ol><li>Boot sector viruses: infects the boot sector of a disk.(这个区域是包含计算机启动时候执行的代码的区域。感染后，可以确保病毒开机自动加载和执行，并将自己传递到其他磁盘上)</li><li>File viruses: 针对executable file(可执行文件)，比如.exe,.bat.感染文件被执行，病毒被执行。</li><li>Multipartitle virusees: 前两者结合起来。</li><li>Macro viruses: 利用Word 和 Excel等的内置编程语言。感染后，会在打开文档的时候执行病毒代码。</li><li>scripting viruses: JS或者VB，网页或者电子邮件附件上。</li></ol><h3 id="structrure-of-a-virus-病毒结构"><a href="#structrure-of-a-virus-病毒结构" class="headerlink" title="structrure of a virus(病毒结构)"></a>structrure of a virus(病毒结构)</h3><h4 id="Propagation-传播"><a href="#Propagation-传播" class="headerlink" title="Propagation(传播)"></a>Propagation(传播)</h4><p>将病毒从一个系统传播到另一个系统，过程通常需要人为干预，打开垃圾邮件，非正规网站下载资源。</p><h4 id="Triggering-触发"><a href="#Triggering-触发" class="headerlink" title="Triggering(触发)"></a>Triggering(触发)</h4><p>导致病毒执行的事件，比如打开文件，启动计算机，或者特定的日期。</p><h4 id="Payload-载荷"><a href="#Payload-载荷" class="headerlink" title="Payload(载荷)"></a>Payload(载荷)</h4><p>病毒的主要功能，比如delete files，steal information, encrypting data(赎金软件)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-built_in">Virus</span>() &#123;<br><span class="hljs-built_in">infectExecutable</span>();<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">triggered</span>()) &#123;<br><span class="hljs-built_in">doDamage</span>();<br>&#125;<br>jump to main of infected program;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">infectExecutable</span><span class="hljs-params">()</span> </span>&#123;<br>file = choose an uninfected executable<br>file;<br>prepend/postpend/embed V to file;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">doDamage</span><span class="hljs-params">()</span> </span>&#123; ... &#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">triggered</span><span class="hljs-params">()</span> </span>&#123; <span class="hljs-keyword">return</span> (some test? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>); &#125; <br></code></pre></td></tr></table></figure><h2 id="Worms-蠕虫"><a href="#Worms-蠕虫" class="headerlink" title="Worms(蠕虫)"></a>Worms(蠕虫)</h2><p>与病毒的区别是，不需要人的互动,通过软件或者服务器漏洞传播。</p><h3 id="Target-Discovery"><a href="#Target-Discovery" class="headerlink" title="Target Discovery"></a>Target Discovery</h3><ol><li>Port scanning(端口扫描): 扫描网络上的所有端口，找到开放的端口，然后尝试连接，如果连接成功，就可以传播。</li><li>External hit-list: 通过外部来源(meta-servers)获得有可能被感染的目标列表。</li><li>Internal topological information : 已经感染的受害者及其上发现更多的目标主机。比如硬盘存的url，电子邮件。</li><li>local subnet address structure : 如果Worm已经渗透到了防火墙内部，他就可以感染子网中其他的主机。</li></ol><h3 id="Propagation-传播-1"><a href="#Propagation-传播-1" class="headerlink" title="Propagation (传播)"></a>Propagation (传播)</h3><ol><li>Exploiting communitcation&#x2F;networking facilities or services(利用通信网络设施&#x2F;服务): 比如利用邮件，RPC(远程程序调用)。</li><li>Exploiting vulnerabilities or bugs in operating system(操作系统漏洞): 比如buffer overflow, code injection, SQL injection.</li><li>Taking advantage of mobile code characteristics(利用移动代码的特点)： 电子邮件附件，互动，动态内容。</li><li>Insecured file sharing facilities.(不安全的文件共享设施)。</li></ol><h3 id="Activation-and-Payload"><a href="#Activation-and-Payload" class="headerlink" title="Activation and Payload"></a>Activation and Payload</h3><ol><li>Activation(激活): 打开电子邮件附件，点击网络链接。分为Human activity-based activation, Human activation, Scheduled process activation, self-activation.</li><li>Payload: worm被激活开始工作，比如Dos(as a botnet),Data theft,Data integrity attack。</li></ol><p><img src="/2023/04/24/Cyber-security/7.jpeg"></p><h2 id="其他种类"><a href="#其他种类" class="headerlink" title="其他种类"></a>其他种类</h2><ol><li>Trapdoor (backdoor 后门): developers for maintenance or testing purpose or maliciously inserted by attackers.</li><li>Trojan horse (木马): 伪装成正常程序，但是实际上是恶意程序。</li><li>Malicious Mobile Code(恶性移动代码): 从远程主机传送到本机。</li><li>Zombies(bots僵尸): 被攻击者控制的主机，用来进行DDoS(分布式拒绝服务攻击) DDos 有一个Botnet，但DOS没有因为只是一个bot。</li><li>Blended Attacks:  混合式攻击是指采用多种感染和&#x2F;或传输方法来破坏系统或网络的恶意活动。</li></ol><h2 id="APTS-Advanced-Persistent-Threats-高级持续性威胁"><a href="#APTS-Advanced-Persistent-Threats-高级持续性威胁" class="headerlink" title="APTS(Advanced Persistent Threats 高级持续性威胁)"></a>APTS(Advanced Persistent Threats 高级持续性威胁)</h2><ol><li>Crimeware toolkits(犯罪软件包): APT攻击者通常使用软件包。没啥好说的，任何人都用。</li><li>Persistence and stealth(持续性和隐蔽性); 攻击者渗透到目标网络之中并很长时间不被发现。</li><li>Organized and dangerous attack source: 有组织的危险和攻击来源，从以前为了装逼的个人或者小团地转变成了正式的攻击组织&#x2F;国家。</li><li>Targeted attacks: APTs通常具有高度的针对性，比如国防，政府，金融。</li></ol><h2 id="Buffer-Overflow"><a href="#Buffer-Overflow" class="headerlink" title="Buffer Overflow"></a>Buffer Overflow</h2><p>buffer是一个pre-allocated data storage area in computer’s memory. 用来暂时的保存数据，如果overflow了，缓冲区溢出，导致多余的数据已出道了邻近的内存位置，导致覆盖了重要的代码，从而有安全行为或者漏洞。</p><p><img src="/2023/04/24/Cyber-security/8.jpeg"></p><ol><li>Consequence: 正常情况会给程序干崩溃，通常用一个指向自己的恶意代码(shellcode)的指针覆盖返回地址，或者攻击者可以在函数返回的时候控制程序的执行流程。</li><li>如果登陆需要填写Authenticated才会进入，编译器在str之后立刻存储变量，攻击者可以通过提供21个字节的数据，覆盖掉返回地址，然后在后面加上shellcode，就可以控制程序的执行流程。</li></ol><h2 id="Program-Memory-Layout"><a href="#Program-Memory-Layout" class="headerlink" title="Program Memory Layout"></a>Program Memory Layout</h2><ol><li>Stack: 用来存储局部变量，函数参数，返回地址，函数调用的上下文信息。</li><li>Heap: 用来存储动态分配的内存，比如malloc, new。</li><li>BSS (Block Start by Symbol) segment : 存储未初始化的全局&#x2F;静态变量。</li><li>Data segment: 用来存储全局变量，静态变量，常量。</li><li>Text segment : 用来存可执行文件的可执行代码。</li></ol><p>buffer 可以是stack或者heap。</p><h3 id="Heap-Based-attacks"><a href="#Heap-Based-attacks" class="headerlink" title="Heap-Based attacks"></a>Heap-Based attacks</h3><p>如果成功，会导致任意代码饿执行访问崩溃，更具有挑战，需要更加了解目标陈旭的内存布局和管理。</p><h3 id="Stack-Based-attacks"><a href="#Stack-Based-attacks" class="headerlink" title="Stack-Based attacks"></a>Stack-Based attacks</h3><p>LIFO（先进后出）的结构组织的，新添加的项目第一个被删除。<br><img src="/2023/04/24/Cyber-security/9.jpeg"></p><h3 id="Stack-based-on-x86"><a href="#Stack-based-on-x86" class="headerlink" title="Stack(based on x86)"></a>Stack(based on x86)</h3><ol><li>Instruction Pointer(register %eip): 处理器执行的下体条命令。</li><li>Stack Pointer(%esp): 指向栈顶的指针。</li><li>(Current) Frame Pointer(%ebp): The Frame Pointer 是当一个函数被调用，新的Stack frame 被创建。</li></ol><h1 id="VPN-Virtual-Private-Network"><a href="#VPN-Virtual-Private-Network" class="headerlink" title="VPN(Virtual Private Network)"></a>VPN(Virtual Private Network)</h1><ol><li>Tunneling(隧道): VPN在你的设备和VPN服务器之间创建一个隧道，将你的数据密封在其中。包括encapsulation, transmission and decapsulation。</li><li>Private Intranet: 一个私有网络，只有内部的设备可以访问，外部的设备无法访问。</li><li>IP-in-IP Tunnel: 允许两个网络(Private Intranet)&#x2F;设备之间建立安全的隧道链接，通过在原始IP数据包的头部添加一个新的IP头部来实现。可以让两个IP在公共网络中也可以安全的通信。工作原理如下图所示。</li></ol><p><img src="/2023/04/24/Cyber-security/10.jpeg"></p><h3 id="VPN-routers-gateways-路由器"><a href="#VPN-routers-gateways-路由器" class="headerlink" title="VPN routers(gateways 路由器)"></a>VPN routers(gateways 路由器)</h3><ol><li>Standalone VPNs: 转饿为提供VPN功能而设计的专用网络设备。  </li><li>Integrated VPNs: 把VPN功能添加到现有设备，不需要专业设备。比如添加到路由器或者防火墙上。</li></ol><h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><h2 id="Cybersecurity-Domains"><a href="#Cybersecurity-Domains" class="headerlink" title="Cybersecurity Domains"></a>Cybersecurity Domains</h2><ol><li>Critical Infrastructure Security 关键基础设施安全: 保护国家的基础设施，比如电力，交通，通信，金融。</li><li>Network&#x2F;Internet Security 网络&#x2F;互联网安全: 授权访问，防火墙，入侵检测系统(IDS),入侵防御系统(IPS)和安全的网络架构。</li><li>Application Security 软件安全: 保护应用程序，比如web应用程序，数据库，操作系统。</li><li>Cloud Security yunanquan: 保护云计算环境。</li><li>Information Security 信息安全: 保护信息，比如数据，文件，邮件，通信。</li><li>End-User Education 用户教育: 保护用户，比如安全意识，安全培训，安全政策。</li><li>Disaster Recovery&#x2F;Business Continuity 恢复&#x2F;业务连续性: 保护组织的业务，比如备份，恢复，灾难恢复计划，业务连续性计划。</li></ol><h2 id="E1-1"><a href="#E1-1" class="headerlink" title="E1.1"></a>E1.1</h2><p>Respectively assuming yourself as</p><ul><li>the owner&#x2F;director of an SME (Small and medium-sized<br>enterprise),</li><li>the IT manager in an organization, managing the IT facilities in<br>the organization, and</li><li>the manager of the development team in an IT company, in<br>charge of developing an app for on-line shopping,<br>carry out some research and identify</li></ul><ol><li>cybersecurity challenges and</li><li>measures to tackle the challenges.</li></ol><h2 id="E1-1-solution"><a href="#E1-1-solution" class="headerlink" title="E1.1 solution"></a>E1.1 solution</h2><h3 id="Owner-x2F-director-of-an-SME"><a href="#Owner-x2F-director-of-an-SME" class="headerlink" title="Owner&#x2F;director of an SME:"></a>Owner&#x2F;director of an SME:</h3><h4 id="Cybersecurity-challenges"><a href="#Cybersecurity-challenges" class="headerlink" title="Cybersecurity challenges:"></a>Cybersecurity challenges:</h4><p>Limited budget and resources for cybersecurity measures.<br>Lack of cybersecurity awareness among employees.<br>Vulnerability to ransomware, phishing, and other types of cyberattacks.</p><h4 id="Measures-to-tackle-the-challenges"><a href="#Measures-to-tackle-the-challenges" class="headerlink" title="Measures to tackle the challenges:"></a>Measures to tackle the challenges:</h4><p>Invest in essential security measures such as firewalls, antivirus software, and data backups.<br>Provide cybersecurity awareness training for employees.<br>Implement strong access control and password policies.</p><h3 id="IT-manager-in-an-organization"><a href="#IT-manager-in-an-organization" class="headerlink" title="IT manager in an organization:"></a>IT manager in an organization:</h3><h4 id="Cybersecurity-challenges-1"><a href="#Cybersecurity-challenges-1" class="headerlink" title="Cybersecurity challenges:"></a>Cybersecurity challenges:</h4><p>Securing a growing number of devices and endpoints.<br>Managing software and hardware updates to address vulnerabilities.<br>Ensuring compliance with data protection regulations.</p><h4 id="Measures-to-tackle-the-challenges-1"><a href="#Measures-to-tackle-the-challenges-1" class="headerlink" title="Measures to tackle the challenges:"></a>Measures to tackle the challenges:</h4><p>Implement a comprehensive endpoint security strategy, including regular patch management and vulnerability assessments.<br>Establish a clear incident response plan to handle potential cybersecurity incidents.<br>Collaborate with other departments to ensure data protection policies are adhered to.</p><h3 id="Manager-of-the-development-team-in-an-IT-company-developing-an-online-shopping-app"><a href="#Manager-of-the-development-team-in-an-IT-company-developing-an-online-shopping-app" class="headerlink" title="Manager of the development team in an IT company (developing an online shopping app):"></a>Manager of the development team in an IT company (developing an online shopping app):</h3><h4 id="Cybersecurity-challenges-2"><a href="#Cybersecurity-challenges-2" class="headerlink" title="Cybersecurity challenges:"></a>Cybersecurity challenges:</h4><p>Protecting user personal information and payment data.<br>Preventing fraudulent activities, such as malicious refunds.<br>Mitigating the risk of Distributed Denial of Service (DDoS) attacks and other types of cyberattacks that can disrupt service availability.</p><h4 id="Measures-to-tackle-the-challenges-2"><a href="#Measures-to-tackle-the-challenges-2" class="headerlink" title="Measures to tackle the challenges:"></a>Measures to tackle the challenges:</h4><p>Implement strong encryption and secure coding practices to protect sensitive data.<br>Use secure and reliable payment processing services, and implement fraud detection mechanisms.<br>Deploy DDoS protection services and use cloud-based solutions with built-in redundancy to mitigate service disruptions.</p><h1 id="Security-Basic"><a href="#Security-Basic" class="headerlink" title="Security Basic"></a>Security Basic</h1><h2 id="Cybersecurity-Threats"><a href="#Cybersecurity-Threats" class="headerlink" title="Cybersecurity Threats"></a>Cybersecurity Threats</h2><ul><li>Malware (virus, trojan, worm, …)</li><li>Ransomware</li><li>Adware</li><li>Hacking</li><li>Spoofing</li><li>Phishing</li><li>Pharming</li><li>DDoS (Distributed Denial of Service) attacks (Botnets attacks)</li><li>Identity theft</li><li>SQL injection</li><li>Social engineering</li><li>Cryptojacking (Cryptocurrency Hijacking)</li><li>etc, the list goes on …</li></ul><h3 id="CIA-Confidentiality-Integrity-and-Availability"><a href="#CIA-Confidentiality-Integrity-and-Availability" class="headerlink" title="CIA(Confidentiality,Integrity and Availability)"></a>CIA(Confidentiality,Integrity and Availability)</h3><ol><li><p>Discolosure(threats to confidentiality): confidentiality是防止对敏感信息的未授权访问，Discolosure是值对敏感信息的未授权访问。</p><ol><li>Snooping，sniffing(data in transit):在数据上传的时候拦截和读取数据的手段,加密可以有效防止。</li><li>Unauthorized access(systems, data at rest):未经授权的访问系统和数据。</li></ol></li><li><p>Deception(fraud and forgeries; threats to integrity): 保证数据没有被篡改。</p><ol><li>Spoofing(identify theft): 攻击者模仿他人的证书通信模式假装成其他人。</li><li>Unauthorized data modification: 未经允许的数据修改。</li><li>Replay(intercept and retransmit): 涉及拦截和重传有效的数据传输</li><li>Repudiation(false denial) of origin, repudiation of recipt: 当参与交易的一方否认他们是交易的一部分。</li></ol></li><li><p>Disruption: 使得系统无法正常工作。</p><ol><li>Modification: 对系统活数据的未经允许的改变。</li><li>Delay: 影响服务的延迟。</li><li>Denial of service: 使得系统无法正常工作。</li></ol></li></ol><h3 id="Security-Properties"><a href="#Security-Properties" class="headerlink" title="Security Properties"></a>Security Properties</h3><ol><li>Freshness : 保证数据不是就数据的重放</li><li>Non-repudiation: 防止虚假拒绝</li><li>Fairness: 要么双方都收到认同的东西，活着都收不到东西</li></ol><h2 id="Achieving-Security-life-cycle"><a href="#Achieving-Security-life-cycle" class="headerlink" title="Achieving Security: life-cycle"></a>Achieving Security: life-cycle</h2><p>没有绝对的安全。<br>Life-cycle分为三个步骤: </p><ol><li>threats analysis: 识别威胁</li><li>design and implementation: 设计和实现</li><li>security assurance: 确保安全</li></ol><h3 id="Attack-Tree-Threat-Tree"><a href="#Attack-Tree-Threat-Tree" class="headerlink" title="Attack Tree (Threat Tree)"></a>Attack Tree (Threat Tree)</h3><p>root 是攻击目标，child是攻击方法。每一个节点都有一个likelihood 可能性，象征着入侵成功的概率。即货币成本，或者完成攻击所需要的成本。</p><p><img src="/2023/04/24/Cyber-security/11.jpeg"></p><h2 id="Security-models"><a href="#Security-models" class="headerlink" title="Security models"></a>Security models</h2><h3 id="A-distributed-system-security-model"><a href="#A-distributed-system-security-model" class="headerlink" title="A distributed system security model"></a>A distributed system security model</h3><ul><li>认证： 验证网络中用户和系统的身份，确保他们被授权访问资源。</li><li>授权： 根据用户或系统的权限，授予或拒绝对特定资源的访问。</li><li>完整性： 确保数据和系统组件不被未授权方篡改或改变。</li><li>保密性： 保护敏感数据免受未经授权的访问和披露。</li><li>可用性： 确保系统及其资源在需要时能被授权用户访问。</li></ul><h3 id="A-communication-security-model"><a href="#A-communication-security-model" class="headerlink" title="A communication security model"></a>A communication security model</h3><ul><li>加密： 对数据进行编码，以便只有拥有适当解密密钥的授权方才能访问该信息。</li><li>认证： 验证通信各方的身份，以确保他们被授权参与通信。</li><li>不可否认性： 提供一种手段来证明特定的一方参与了一项通信或交易，防止他们事后否认他们的参与。</li><li>完整性： 确保传输的数据在传输过程中没有被改变或篡改。</li><li>密钥管理： 安全地生成、分发和管理通信过程中使用的加密密钥。</li></ul><h3 id="An-e-commerce-security-model"><a href="#An-e-commerce-security-model" class="headerlink" title="An e-commerce security model"></a>An e-commerce security model</h3><ul><li>安全通信： 利用加密协议，如SSL&#x2F;TLS，来保护客户和服务器之间传输的敏感数据。</li><li>认证： 验证用户、商家和系统的身份，以确保对资源和交易的安全和授权访问。</li><li>授权： 根据用户角色和权限控制对资源和功能的访问。</li><li>数据隐私： 通过加密和安全存储，确保保护敏感的用户信息，如信用卡号码和个人详细资料。</li><li>欺诈检测和预防： 实施检测和减少欺诈性交易的系统，如监测可疑活动和实施强大的认证机制。</li></ul><h2 id="E2-1"><a href="#E2-1" class="headerlink" title="E2.1"></a>E2.1</h2><p>Comment on the implications to risks (i.e. whether risks are increased or decreased) in<br>terms of Confidentiality, Integrity and Availability in each of the following cases:</p><ol><li><p>Disconnect a computer from the Internet<br>Disconnecting a computer from the Internet reduces risks to confidentiality, but availability<br>suffers. Integrity may also suffer due to loss of updates.</p></li><li><p>Have extensive data checks by different people&#x2F;systems<br>Have extensive data checks by different people&#x2F;systems can reduce risks to integrity, but<br>confidentiality suffers as more people will be able to see the data. Availability will also suffer<br>due to locks on data under verification</p></li></ol><h2 id="E2-2"><a href="#E2-2" class="headerlink" title="E2.2"></a>E2.2</h2><ol><li>In this exercise, you are asked to identify, via literature research,<br>potential cyber attack threats to mobile banking (i.e. perform<br>banking transactions using your mobile phone). You are expected to<br>be able to explain the attacking mechanism of each of your<br>identified threats (i.e. how the attack is performed) and try to name<br>any countermeasures to your identified threats.</li><li>Draw a threat tree for ‘reading your best friend’s email without<br>authorisation’.</li></ol><h1 id="Symmetric"><a href="#Symmetric" class="headerlink" title="Symmetric"></a>Symmetric</h1><p>$C &#x3D; E_K(M) (or C &#x3D; E(K, M)) \<br>M &#x3D; D_K(C) (or M &#x3D; D(K, C))<br>$  </p><ul><li>encryption function E_K(.), or a decryption function,<br>D_K(.).  </li><li>M is a plaintext block and C is a ciphertext block<br>is a secret (a symmetric or a private key)</li></ul><h2 id="Block-cipher-design-criteria-区块密码设计标准"><a href="#Block-cipher-design-criteria-区块密码设计标准" class="headerlink" title="Block cipher design criteria(区块密码设计标准)"></a>Block cipher design criteria(区块密码设计标准)</h2><ol><li><p>Completeness（完整性）： cipher text（密码文本）应该完全取决于 plain text(纯文本)。</p></li><li><p>Avalanche effect (Diffusion雪崩效应，扩散): 输入text或者private key的任何一个微小的变化应该导致输出text的巨大变化。目的是防止暴力破解。</p><ol><li>改变信息的一个bit 对应的输出信息很多个bit 得到改变。</li><li>改变private key的一个bit 对应的输出信息很多个bit 得到改变。</li></ol></li><li><p>Statistical independence (Confusion 混淆): 输入和输出的关系非常复杂，非线性函数或混合函数来实现的。目的是防止统计分析。</p></li></ol><h2 id="Feistel-Block-Cipher-费斯特尔区块密码"><a href="#Feistel-Block-Cipher-费斯特尔区块密码" class="headerlink" title="Feistel Block Cipher(费斯特尔区块密码)"></a>Feistel Block Cipher(费斯特尔区块密码)</h2><p><img src="/2023/04/24/Cyber-security/12.jpeg"></p><ul><li>XOR : 比较两个二进制位数之间的不同，相同返回0，不同返回1.</li><li>Round function(f): n位块进行输出n位块，</li><li>Block Size(n):</li><li>Key Size(s):</li><li>Number of rounds(r):一般大于10, 循环次数</li></ul><p> 费斯特尔密码依靠XOR操作和圆形函数的组合来创造一个更复杂和安全的加密过程。轮次函数引入了混乱和扩散，而XOR操作有助于有效地混合输入数据和轮次函数的输出。</p><p>加密和解密过程都知道参数，如回合数、密钥和具体的回合函数。当正确的密钥与这些参数一起使用时，解密过程将逆转加密过程中应用的操作，允许恢复原始明文。</p><h2 id="DES-Data-Encryption-Standard"><a href="#DES-Data-Encryption-Standard" class="headerlink" title="DES (Data Encryption Standard)"></a>DES (Data Encryption Standard)</h2><p>DES is a Feistel block cipher</p><ol><li>密钥 K 是 56 位；实际上是 8 个字节，但每个字节中的第 8 位是奇偶校验位</li><li>子密钥k1, k2 …, k16各为48位，由密钥K生成,解密和加密相同，唯一的不同是解密subkey的顺序反过来。</li><li>DES不安全了,$2^{55}$次就可以破解，因为只是56-bit key, 但是DES的设计是很好的，所以可以用DES的设计思想，设计出更好的算法，比如3DES, AES。</li></ol><h3 id="Triple-DES-3DES"><a href="#Triple-DES-3DES" class="headerlink" title="Triple DES(3DES)"></a>Triple DES(3DES)</h3><h4 id="EDS2-3DES-用两个keys"><a href="#EDS2-3DES-用两个keys" class="headerlink" title="EDS2 (3DES 用两个keys)"></a>EDS2 (3DES 用两个keys)</h4><p>$Ciphertext (C) &#x3D; E_{K1}(D_{K2}(E_{K1}(Plaintext (M))))$</p><p>EDE2的密钥长度为112位（56位来自K1，56位来自K2）。在中间使用解密算法D对安全性没有直接影响。它的作用是在K1&#x3D;K2的情况下使Triple DES向后兼容单DES，这意味着在这种情况下它可以像单DES一样发挥作用。</p><h4 id="EDS2-3DES-用三个keys"><a href="#EDS2-3DES-用三个keys" class="headerlink" title="EDS2 (3DES 用三个keys)"></a>EDS2 (3DES 用三个keys)</h4><p>$Ciphertext (C) &#x3D; E_{K3}(D_{K2}(E_{K1}(Plaintext (M))))$</p><p>EDE3密钥长度168bits.</p><h2 id="AES-Advanced-Encryption-Standard"><a href="#AES-Advanced-Encryption-Standard" class="headerlink" title="AES (Advanced Encryption Standard)"></a>AES (Advanced Encryption Standard)</h2><p>A symmetric block cipher same as DES.</p><ul><li>使用相同的密钥来加密和解密信息。</li><li>明文和密码文本具有相同的大小。</li></ul><ol><li>不同于DES他是iterative而并非feistel cipher。</li><li>限定block size &#x3D; 128 bit。加密和解密都用128bit。</li><li>round(n):<ol><li>对于一个128位的密钥长度，r &#x3D; 10轮。</li><li>对于192位的密钥长度，r&#x3D;12轮。</li><li>对于256位的密钥长度，r&#x3D;14轮。</li></ol></li></ol><h3 id="十六进制-hexadecimal-hex-number"><a href="#十六进制-hexadecimal-hex-number" class="headerlink" title="十六进制(hexadecimal (hex) number)"></a>十六进制(hexadecimal (hex) number)</h3><p>0x5B</p><ol><li>0x 表示十六进制</li><li>5: $16^1 * 5$ (80)</li><li>B: $16^0 * 11$ (11)</li><li>5B &#x3D; 16 + 11 &#x3D; 91</li></ol><h3 id="SubBytes"><a href="#SubBytes" class="headerlink" title="SubBytes"></a>SubBytes</h3><p>这个步骤只是为了让plaintext变得更加复杂。high and low nibbles of a byte是用来寻找S-box中特定的index的。<br>比如5B，high nibble是5，low nibble是B，inde就是S-box[5][11]。找到这个index，把这个index的值拿过来放到当前的5B在的位置。<br><img src="/2023/04/24/Cyber-security/14.jpeg"></p><h3 id="Shift-Row"><a href="#Shift-Row" class="headerlink" title="Shift Row"></a>Shift Row</h3><p><img src="/2023/04/24/Cyber-security/13.jpeg"></p><h3 id="Mix-columns"><a href="#Mix-columns" class="headerlink" title="Mix columns"></a>Mix columns</h3><p>$GF(P^n)$ (in AES, p&#x3D;2, n&#x3D;8)</p><p>In AES, $m(x)&#x3D;x^8+x^4 +x^3+x^1+x^0$, i.e. 100011011 (or 11B) 这里因为使用了bitwise XOR，二进制等于1则有，0则没有。<br><img src="/2023/04/24/Cyber-security/15.jpeg"></p><h3 id="Add-round-key"><a href="#Add-round-key" class="headerlink" title="Add round key"></a>Add round key</h3><p>状态的128位与圆密钥的128位进行位数XOR： 由于状态矩阵和圆密钥矩阵都由16个字节（128位）组成，AddRoundKey转换的结果是另一个128位的矩阵，其中每个位是状态矩阵和圆密钥矩阵中相应位的XOR。</p><p><img src="/2023/04/24/Cyber-security/16.jpeg"></p><h2 id="DES-vs-AES"><a href="#DES-vs-AES" class="headerlink" title="DES vs AES"></a>DES vs AES</h2><p><img src="/2023/04/24/Cyber-security/17.jpeg"></p><p>N-bit block cipher 需要超过 2^N 来破解。</p><h2 id="Stream-Cipher"><a href="#Stream-Cipher" class="headerlink" title="Stream Cipher"></a>Stream Cipher</h2><p>流密码是一种对称密钥加密算法，一次对明文数据进行加密，每次加密一个比特或字节。它们通过生成一个密钥流进行操作，密钥流是由秘密密钥产生的一个比特或字节序列。然后，密钥流与明文使用位XOR操作相结合，产生密码文本。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>Bitwise XOR 效率高</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>Key length 密钥必须和明文一样长，这在大多数应用场景中是不现实的</li><li>如果同一个密钥被用于多个明文，流密码就会受到攻击。能够获得两个明文的XOR（M1 XOR M2）的攻击者，如果能够获得另一个plaintext及其相应的密码文本（M1和C1），就可以恢复其中一个明文。这是因为将M1与C1进行XOR（即M1 XOR K）会得到密钥K，然后攻击者可以使用K来解密C2（即M2 XOR K）并恢复M2。<h3 id="Bitwise-XOR"><a href="#Bitwise-XOR" class="headerlink" title="Bitwise XOR"></a>Bitwise XOR</h3></li></ol><p>$0 XOR 0 &#x3D; 0  \<br>0 XOR 1 &#x3D; 1  \<br>1 XOR 0 &#x3D; 1  \<br>1 XOR 1 &#x3D; 0$</p><h3 id="PRNG"><a href="#PRNG" class="headerlink" title="PRNG"></a>PRNG</h3><p>Replace the random key in One-time Pad by a pseudo-random<br>sequence, generated by a cryptographic pseudo-random generator that is ‘seeded’ with the key.</p><h2 id="Modes-of-Encryption"><a href="#Modes-of-Encryption" class="headerlink" title="Modes of Encryption"></a>Modes of Encryption</h2><p>如果消息比block size长。<br>o ECB – Electronic Code Book mode<br>o CBC – Cipher Block Chaining mode<br>o CTR – Counter mode  </p><h3 id="ECB"><a href="#ECB" class="headerlink" title="ECB"></a>ECB</h3><p>plaintext被分成很多与block size相同的text独立加密，然后再用分别的密钥独立解密。</p><ul><li>操作简便，但是对于有重复性的信息不安全。</li><li>最后一个block不足block size，需要padding，最后一个字节表示padding的长度，方便接收后删除。</li><li>加密: $C_n &#x3D; E_k(M_n) (or E(K, M_n))$ 解密:  $M_n &#x3D; D_k(C_n); n &#x3D; {1, 2, …}.$</li></ul><h3 id="CBC"><a href="#CBC" class="headerlink" title="CBC"></a>CBC</h3><p>与ECB一样，不过每一个cipher block 都是用前一个cipher block的ciphertext和当前的plaintext进行加密，所以前面的block坏掉，后面的全会影响。<br>$C_i &#x3D; E_K(M_i XOR C_{i-1}), where C_0 &#x3D; IV (Initialization Vector)$<br>Initialization Vector :是一个随机值，给第一个plaintext增加随机性用的。<br><img src="/2023/04/24/Cyber-security/18.jpeg"></p><h3 id="CTR"><a href="#CTR" class="headerlink" title="CTR"></a>CTR</h3><p>目的是把block cipher变成stream cipher。<br>有一个计数器，计数器最大值等于block size的数量。每一个计数器的数量等于block size的数量，然后用计数器的值和密钥进行加密，然后和plaintext进行XOR。</p><ol><li>可以并行化。</li><li>可以随机访问。</li><li>与plaintext的XOR可以预先计算。</li><li>一个block的丢失，同步就会丢失，无法复原plaintext。</li><li>一个在传输过程中被修改的密码文本块只影响该块的解密。</li></ol><p><img src="/2023/04/24/Cyber-security/19.jpeg"></p><h2 id="Block-vs-Stream-Cipher"><a href="#Block-vs-Stream-Cipher" class="headerlink" title="Block vs Stream Cipher"></a>Block vs Stream Cipher</h2><ul><li>Block Cipher</li></ul><ol><li>While block ciphers encrypt blocks of characters, stream ciphers encrypt individual characters or bit streams.</li></ol><ul><li>Stream ciphers</li></ul><ol><li>are usually faster than block ciphers in hardware; mostly used for continuous communications and&#x2F;or real-time applications.2. requires less memory space, so cheaper for resource<br>restrained devices such as embedded sensors.</li><li>have limited or no error propagation, so advantageous when transmission errors are probable.</li><li>can be built out of block ciphers, e.g. by using CTR modes.</li></ol><h2 id="漏洞"><a href="#漏洞" class="headerlink" title="漏洞"></a>漏洞</h2><ol><li>不可以使用内置random 函数比如rand()。</li><li>IVs should be random.</li></ol><h2 id="E3-1"><a href="#E3-1" class="headerlink" title="E3.1"></a>E3.1</h2><p>By applying DES twice using two different 56-bit keys, K1 and<br>K2, to encrypt a message, M, i.e. $C&#x3D;EK2[EK1[M]]$, where C is the ciphertext, we have a double DES encryption. Would this double DES encryption double the security level of a single DES<br>encryption? Justify your answer.<br><img src="/2023/04/24/Cyber-security/20.jpeg"></p><h1 id="Public-key-Cryptography-PKC"><a href="#Public-key-Cryptography-PKC" class="headerlink" title="Public-key Cryptography (PKC)"></a>Public-key Cryptography (PKC)</h1><h2 id="One-Way-Function"><a href="#One-Way-Function" class="headerlink" title="One-Way Function"></a>One-Way Function</h2><p>计算上不可逆转的函数。常用的单项函数:</p><ol><li>Integer factorization(整数因子化): 用于RSA加密方案，将两个大的质数相乘很容易，但再给他分解质因数是很难的。RSA中信息通过提高到两个大素数的乘积来加密，只有知道素数的人才能将它解密。</li><li>discrete logarithm(离散对数): 用于DSS&#x2F;DSA和Diffie-Hellman密钥交换。目的是寻找一个 ax&#x3D;b mod p 的整数x的问题。其中a，b，p是已知的，x是未知的。这个问题是很难解决的，因为它需要尝试所有可能的x值，直到找到一个满足方程的值。这个问题的难度在于，当p很大时，x的可能值的数量是非常大的。</li></ol><h2 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h2><ul><li>适用于encryption(for symmetric key distribution): RSA, ElGamal, ECC</li><li>只能数字签名: DSA</li><li>只能key agreement : DH</li><li>加密和数字签名: RSA ElGamal Rabin</li><li>Examples:<br>  9 mod 5 &#x3D; 4<br>  20 mod 9 &#x3D; 2<br>  17 &#x3D; 2 mod 5 since 17-2 &#x3D; 3 ·5<h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2>两个大素数(100-400)的乘积。<br><img src="/2023/04/24/Cyber-security/21.jpeg"></li></ul><p><img src="/2023/04/24/Cyber-security/22.jpeg"></p><h2 id="Hybrid-Cryptosystems"><a href="#Hybrid-Cryptosystems" class="headerlink" title="Hybrid Cryptosystems"></a>Hybrid Cryptosystems</h2><p><img src="/2023/04/24/Cyber-security/23.jpeg"></p><h2 id="Digital-Signature"><a href="#Digital-Signature" class="headerlink" title="Digital Signature"></a>Digital Signature</h2><ol><li>Message-dependent: 数字签名需要依赖消息的内容，包括时间日期等细节。</li><li>Unreusable: 数字签名不可重复使用，每条信息的数字签名都是唯一的。</li><li>Ensures content integrity: 数字签名保证信息在签名过后的完整性。</li><li>Signer-dependent: 数字签名独属于签名着，不可以轻易被其他人创建。</li><li>Unforgeable: 很难被伪造。</li><li>Ensures origin authentication: 确认信息来源。</li><li>Verifiable: 可以被验证。</li><li>Anti-forgery: 数字签名不可伪造，因为它是基于签名者的私钥进行加密。</li></ol><p><img src="/2023/04/24/Cyber-security/24.jpeg"></p><h2 id="DSS-x2F-DSA-纯数字签名的方法"><a href="#DSS-x2F-DSA-纯数字签名的方法" class="headerlink" title="DSS&#x2F;DSA(纯数字签名的方法)"></a>DSS&#x2F;DSA(纯数字签名的方法)</h2><h1 id="Cryptographic-Checksum-加密校验"><a href="#Cryptographic-Checksum-加密校验" class="headerlink" title="Cryptographic Checksum(加密校验)"></a>Cryptographic Checksum(加密校验)</h1><h2 id="需要加密校验的地方"><a href="#需要加密校验的地方" class="headerlink" title="需要加密校验的地方"></a>需要加密校验的地方</h2><ol><li>Public-key encryption, A –&gt; B: $E_{KUb}$ [M] 用B的public key加密。B不知道是谁发的，也不能确定消息完整性。所以需要校验。</li><li>Digital signing, A –&gt; B: M||$E{KRa}$ [h(M)] 用A的private key加密。不可抵赖性，因为明确是A发出的，并且消息完整。但是无法保证保密性。</li></ol><p>加密校验分为两种，hash function 和 Macs。</p><h2 id="对比于数字签名"><a href="#对比于数字签名" class="headerlink" title="对比于数字签名"></a>对比于数字签名</h2><p> 加密校验和和数字签名都是相关的，因为它们都是用来确保数据的完整性和真实性。然而，加密校验使用哈希函数或MAC，而数字签名则依靠公钥密码学。此外，数字签名提供不可抵赖性，这意味着发送者不能否认发送过数据，而加密校验则不提供这一功能。</p><h2 id="Hash-Function"><a href="#Hash-Function" class="headerlink" title="Hash Function"></a>Hash Function</h2><h3 id="Compression-Property-压缩特性"><a href="#Compression-Property-压缩特性" class="headerlink" title="Compression Property(压缩特性)"></a>Compression Property(压缩特性)</h3><p>h &#x3D; H(M) , h是 message digest(信息摘要)。由于是多对一映射，有可能collisions，尽可能避免。</p><p>生成hash 摘要用很多个block，不断用不同的hash function对上一次的hash message进行hash。最后的hash 是整个message的hash摘要。</p><h3 id="Security-Requirements-x2F-Properties-安全特性"><a href="#Security-Requirements-x2F-Properties-安全特性" class="headerlink" title="Security Requirements&#x2F;Properties(安全特性)"></a>Security Requirements&#x2F;Properties(安全特性)</h3><ol><li>Preimage resistant(one-way单向性): 无法反向。</li><li>2nd preimage resistant(week coliision resistance弱碰撞性): 无法找到另一个message，使得hash值相同。</li><li>Collision resistance (strong collision resistance强抗碰撞): 很难找到相同哈希值的和两个输入。</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>A 发送信息M给B, $M||s$ , $s &#x3D; E_{KRa}[H[M]]$. 攻击者发现了另外一个meesage,这个message和M有着相同的hash，我们就可以把这个替换成原本的message。这就是collision attack。</p><h2 id="MAC-Message-Authentication-Code"><a href="#MAC-Message-Authentication-Code" class="headerlink" title="MAC(Message Authentication Code)"></a>MAC(Message Authentication Code)</h2><p><img src="/2023/04/24/Cyber-security/25.jpeg"></p><p><img src="/2023/04/24/Cyber-security/26.jpeg"></p><h2 id="HMAC"><a href="#HMAC" class="headerlink" title="HMAC"></a>HMAC</h2><p><img src="/2023/04/24/Cyber-security/27.jpeg"></p><h2 id="AEAD-Authenticated-Encryption-with-Associated-Data"><a href="#AEAD-Authenticated-Encryption-with-Associated-Data" class="headerlink" title="AEAD(Authenticated Encryption with Associated Data)"></a>AEAD(Authenticated Encryption with Associated Data)</h2><p>在AEAD（带关联数据的认证加密）中，其目的是为明文信息（有效载荷）提供保密性，并确保明文信息和关联数据（头）的完整性和真实性。AEAD的加密过程需要以下输入：</p><p>头（关联数据）： 信息的一部分，通常不需要保密性，但需要完整性和真实性保护。<br>明文（Plaintext）： 正在传输的实际内容或数据，需要保密。<br>密钥： 用于加密和认证过程的秘密密钥。<br>Nonce： 一个独特的值，将随机性引入加密过程。<br>当你使用这些输入进行AEAD加密时，你将得到以下输出：</p><p>密码文本： 明文信息的加密版本，确保其保密性。<br>认证标签： 一个验证加密的有效载荷（密码文本）和相关数据（头）的完整性和真实性的值。<br>然后，发送方将头、Nonce、密码文本和认证标签传送给接收方。收件人使用相同的密钥、nonce和头来解密密码文本并验证认证标签。如果验证成功，收件人可以确定该信息没有被篡改，并且它来自拥有相同密匙的合法发件人。</p><p>因此，收件人收到以下组件：头、nonce、密码文本和验证标签。然后，收件人使用这些组件以及共享的秘密密钥来解密密码文本，并验证整个信息的完整性和真实性。</p><h2 id="CCM-和-GCM"><a href="#CCM-和-GCM" class="headerlink" title="CCM 和 GCM"></a>CCM 和 GCM</h2><p>CGM 和 GCM 都是AEAD，并且都基于AES。GCM更加灵活，性能更好。</p><h2 id="length-attack"><a href="#length-attack" class="headerlink" title="length attack"></a>length attack</h2><p>攻击者知道正在使用的哈希函数和哈希输出的长度。他们也知道原始信息M的长度，但不知道秘钥K或其长度。</p><h2 id="E5-1"><a href="#E5-1" class="headerlink" title="E5.1"></a>E5.1</h2><ol><li>M||Tag, where Tag&#x3D;H(M||K)</li><li>M||Tag, where Tag&#x3D;E(K, H(M))</li><li>M||Tag, where Tag&#x3D;E(PRs, H(M))</li><li>E(K, M||H(M))</li></ol><h1 id="Security-Key"><a href="#Security-Key" class="headerlink" title="Security Key"></a>Security Key</h1><h2 id="Key-Management-Issues"><a href="#Key-Management-Issues" class="headerlink" title="Key Management Issues"></a>Key Management Issues</h2><ol><li>Key generation : 多个输入生成key，比如硬件信息，到达时间等等。</li><li>Key storage : 保存key，比如不联网的硬盘。或者把钥匙分成两部分k1，k2）：k2&#x3D; k1 xor K。</li></ol><h2 id="Diffie-Hellman-Algorithm-x2F-Protocol"><a href="#Diffie-Hellman-Algorithm-x2F-Protocol" class="headerlink" title="Diffie-Hellman Algorithm&#x2F;Protocol"></a>Diffie-Hellman Algorithm&#x2F;Protocol</h2><p>第一个public key 生成算法, 容易收到MITM(man in the middle)的攻击。就两方都一位攻击人的public key和private key是对方的。可以用digital signatures 或者 PKI 来验证公钥。</p><h2 id="Needham-Schroeder-分发会话密钥的方法"><a href="#Needham-Schroeder-分发会话密钥的方法" class="headerlink" title="Needham-Schroeder(分发会话密钥的方法)"></a>Needham-Schroeder(分发会话密钥的方法)</h2><h4 id="without-using-PKC"><a href="#without-using-PKC" class="headerlink" title="without using PKC"></a>without using PKC</h4><ul><li>KDC(Key Distribution Center): 可信任第三方，密钥分发中心。协议目的是建立一个共享的one-time session key($K_{ab}$)</li><li>Nonces($N_a ,N_b$),Alice 和 Bob 给的随机，用来保证信息的freshness。不会被replay attack。</li></ul><p><img src="/2023/04/24/Cyber-security/28.jpeg"></p><p>Ka被KDC用来为Alice加密信息，Alice用Ka来解密从KDC收到的信息。<br>Kb被KDC用来为Bob加密信息，而Bob用Kb来解密从KDC收到的信息。<br>Kab是Alice和Bob用来加密和解密他们之间信息的会话密钥。<br>因此，虽然Ka和Kb用于每一方与KDC之间的加密和解密，但Kab用于Alice和Bob之间的加密和解密。  </p><h4 id="PKC-2-pass"><a href="#PKC-2-pass" class="headerlink" title="PKC 2 pass"></a>PKC 2 pass</h4><p><img src="/2023/04/24/Cyber-security/29.jpeg"></p><h4 id="PKC-3-pass"><a href="#PKC-3-pass" class="headerlink" title="PKC 3 pass"></a>PKC 3 pass</h4><p><img src="/2023/04/24/Cyber-security/30.jpeg"></p><h2 id="E6-1"><a href="#E6-1" class="headerlink" title="E6.1"></a>E6.1</h2><p>Assuming that Alice is to send a message, M, to Bob. M is encrypted with a shared key established using the DH protocol.<br>Explain whether Eve could access this message M. If so, explain how, and propose a solution to address this vulnerability.Assuming that Alice is to send a message, M, to Bob. M is encrypted with a shared key established using the DH protocol. Explain whether Eve could access this message M. If so, explain how, and propose a solution to address this vulnerability.</p><p>how :<br>This is an active attack. The attacker in tercepts and substitutes Ya and Yb with Ye.<br>So at the end of the message exchanges, Eve will have Kae, Kbe, Alice will have Kae and Bob will have Kbe. Any messages encrypted with Kae will be decrypted and read by Eve and then re-encrypted with Kbe and vice versa without the knowledge of Alice and Bob.</p><p>solution 1 Fix DH: </p><p>Server’s and client’s public key certificates contain their respective DH public key parameters. In other words, the DH public keys are certified by a CA. But there has to be a way that Alice and Bob could prove to each other that they are the rightful owners of the corresponding certificates (unless the identity of one entity is already known to the other). With this method, the established symmetric key is not really a session-valid key. So the security level is not as high as the second method.</p><p>solution 2 Ephemeral DH:</p><p>DH public keys are exchanged, signed using the sender’s private DSA key; the receiver uses the corresponding public keys (certified in the certificates) to verify the signatures. The certificates are used to certify the DSA keys, and DH shares are signed using DSA by the respective signers. This is the so called DH-DSA method, used to create a temporary, one-time session key.</p><h2 id="E6-2"><a href="#E6-2" class="headerlink" title="E6.2"></a>E6.2</h2><p>• This simply protocol does not provide mutual authentication: it does not show that the public key has been certified and that the demonstration of private key associated to the public key in the certificate is missing. Eve can intercept the message, creates its own public&#x2F;private key pair {PUe, PRe} and transmits PUe||IDA to Bob. Bob generates a secret key, Ks, and transmits E(PUe, Ks). Eve intercepts the message and learns Ks by computing D(PRe, E(PUe, Ks)). Eve transmits E(PUa, Ks) to Alice. The result is that both Alice and Bob know Ks and are unaware that Ks has also been revealed to Eve. Alice and Bob can now exchange messages using Ks. Eve no longer actively interferes with the communications channel but simply eavesdrops. Knowing Ks, Eve can decrypt all messages, and both A and B are unaware of the problem.</p><h2 id="E6-3"><a href="#E6-3" class="headerlink" title="E6.3"></a>E6.3</h2><p>This is the Needham-Schroeder protocol. Answer the following questions:</p><ol><li>What are the benefits for A to forward the session key to B (i.e. step 3), rather<br>than letting KDC to directly send the session key to B?  </li><li>TRY to identify two application areas of the Needham-Schroeder protocol and to<br>elaborate the benefits of using the Needham-Schroeder protocol in these<br>application areas</li></ol><p>Q1<br>Benefits:</p><ol><li>reduced involvement of KDC, thus less overhead not just for KDC also for B;</li><li>This protocol (designed in this way) can also be used for authentication<br>purpose, in addition to confidential communication between A and B.</li></ol><p>Q2 Two applications: one is establishing a secure communication channel; and the<br>other is for authentication service.</p><p>• Benefits:<br>• Party A (i.e. user) does not need to remember many keys while being able to<br>use a different key for a different correspondent;<br>• When used for authentication, the protocol supports single sign-on, i.e. a<br>user only need to remember a single password, but is able to use different<br>short-term secrets for different servers and the users’ master secrets (i.e.<br>long-term passwords) are only managed by one entity, i.e. KDC.</p><h1 id="PKI-Public-Key-Infrastructure"><a href="#PKI-Public-Key-Infrastructure" class="headerlink" title="PKI(Public Key Infrastructure)"></a>PKI(Public Key Infrastructure)</h1><h2 id="Overview"><a href="#Overview" class="headerlink" title="Overview"></a>Overview</h2><p>VPN , 网页浏览器 , PGP 等都会用到 , 银行卡 , 数字版权。</p><ol><li>How to ensure the security (secrecy and strength)<br>of the private key ？</li></ol><ul><li>The key size should be large enough.</li><li>The lifetime of the key should guard against brute-force<br>attacks.</li><li>The key should be kept secret; they should be<br>generated, transported, stored and destroyed (at the end<br>of its lifetime) securely.</li></ul><ol start="2"><li>How to ensure that a public key is trustworthy ？ how<br>could we trust that a given public key indeed belongs to a claimed entity.</li></ol><ul><li>The solution is to have some trusted entity or authority to sign one’s public key -&gt; digital certificate.</li><li>Otherwise, communications are vulnerable to man-in-themiddle attack.</li></ul><h2 id="Signature-of-CA"><a href="#Signature-of-CA" class="headerlink" title="Signature of CA"></a>Signature of CA</h2><p>它将公共密钥与一个人、硬件设备或软件过程的身份结合起来。 证书由一个CA进行数字签名。这个签名可以用CA的公开密钥进行验证。这样，任何收到证书的人都可以验证它确实是由CA签发的，并且没有被篡改过。证书中包含的信息可以根据其目的而有所不同。例如，用于安全电子邮件通信的证书可能包含持有人的电子邮件地址。用于金融交易的证书可能包含信用卡号码和信用额度</p><h2 id="CRL-Certificate-Revocation-List"><a href="#CRL-Certificate-Revocation-List" class="headerlink" title="CRL(Certificate Revocation List)"></a>CRL(Certificate Revocation List)</h2><p>吊销证书</p><ol><li>date and time of the CRL publications.</li><li>name of the issuing CA.</li><li>serial numbers of all the revoked certificates.</li></ol><p>所以使用证书的时候需要确认 </p><ol><li>It has a valid CA signature</li><li>It has not expired, and</li><li>It is not listed in the CA’s most recent CRL.</li></ol><h2 id="top-down-certificate-hierarchy"><a href="#top-down-certificate-hierarchy" class="headerlink" title="top-down certificate hierarchy,"></a>top-down certificate hierarchy,</h2><p><img src="/2023/04/24/Cyber-security/32.jpeg"></p><p>如果Bob想认证Alice，他需要找到他信任的证书给Alice签发的。</p><p>CERT 表示的是自己的证书。<br>S_{DeptQ} 表示的是由DeptQ信任</p><p> self-signed (a standalone or root CA) 自签头证书</p><p> <img src="/2023/04/24/Cyber-security/33.jpeg"></p><h2 id="bottom-up"><a href="#bottom-up" class="headerlink" title="bottom-up"></a>bottom-up</h2><p>没有受信任的锚： 没有一个中央受信机构或锚，如根证书颁发机构（CA），来颁发和管理所有证书。</p><p>终端实体充当CA： 通常，终端实体（用户、设备、应用程序）为他们认识和信任的其他实体签署证书，本质上是充当他们自己的证书机构。</p><p>信任评估机制： 因为没有中央机构可以隐含信任，所以需要一个机制来评估每个证书或CA的信任程度。这种模式下的信任是主观的，是基于个人决定的。</p><p>PGP解决方案： 这种模式在PGP(Pretty Good Privacy)中使用，它是一种加密程序，为数据通信提供加密隐私和认证。在PGP中，用户独立决定他们信任谁。</p><p>与自上而下的层次结构相比, 自下而上的模式提供了更多的用户自主权, 但由于缺乏一个单一的可信任的权威机构, 在管理和扩展上可能会更加复杂。</p><h2 id="MasterCard"><a href="#MasterCard" class="headerlink" title="MasterCard"></a>MasterCard</h2><p> SecureCode解决方案是基于3-D域安全（3DS）模型，它代表了参与此类交易的三个主要参与者</p><h3 id="Acquirer-Domain-Merchant-商家"><a href="#Acquirer-Domain-Merchant-商家" class="headerlink" title="Acquirer Domain (Merchant)商家"></a>Acquirer Domain (Merchant)商家</h3><h3 id="Issuer-Domain-Cardholder"><a href="#Issuer-Domain-Cardholder" class="headerlink" title="Issuer Domain (Cardholder)"></a>Issuer Domain (Cardholder)</h3><p>注册是这个过程中的一个关键步骤。在注册过程中，持卡人（CH）提供相关的身份和个人信息。这可能包括密码、个人保证信息（PAM）或其他形式的识别。这些信息被收集、验证，然后传递给发卡人的访问控制服务器（ACS）</p><p> Access Control Server (ACS):</p><ol><li>Verification 验证一个账号是否注册</li><li>AuthenticationACS负责对持卡人进行认证</li><li>Signing Authentication Outcomes 购买的人是否合法人</li></ol><h2 id="E7-1"><a href="#E7-1" class="headerlink" title="E7.1"></a>E7.1</h2><p>(ii) X.509 is a top-down approach to public key management. Investigate and<br>describe a bottom-up approach to public key management.</p><p>Assumption: You knows A, B, C, D, E, F.<br>Let us say H wants to communicate with<br>You, You do not know H, but You know A<br>and B, and A and B know H. So A and B can<br>sign H’s public key.<br>If A and B are fully trusted by You, then one<br>signature (on H’s public key), either from A<br>or B, would be sufficient.<br>However, if A and B are partially trusted by<br>You, then signatures from both A and B may<br>be necessary.<br>You can use other heuristics, e.g. if You gives<br>¼ trust to each of the entities he knows,<br>then 4 signatures on the public key of an<br>entity You does not know would be<br>required.</p><h1 id="E7-2"><a href="#E7-2" class="headerlink" title="E7.2"></a>E7.2</h1><p>Assuming that Alice has sent a signed message to Bob.<br>(i) Highlight the steps for verifying a digital certificate.<br>(ii) Highlight the steps Bob takes to verify the authenticity of the message from<br>Alice.</p><p>(i)</p><ul><li>Check validity period to see if it is expired.  </li><li>Check CRL list to see if the certificate has been revoked.<ul><li>Verify the signature on the cert:</li><li>Calculate a message digest for the certificate</li><li>Use the CA’s public key to decrypt the digital signature and recover what is<br>claimed to be the original message digest embedded within the certificate</li></ul></li><li>Compare the two resulting message digest values to ensure the integrity of<br>the certificate</li></ul><p>(ii)</p><ul><li>Verify the certificate or chain of certificates</li><li>Verify Alice’s signature</li></ul><h1 id="User-Identification-and-Authentication"><a href="#User-Identification-and-Authentication" class="headerlink" title="User Identification and Authentication"></a>User Identification and Authentication</h1><h2 id="Overview-1"><a href="#Overview-1" class="headerlink" title="Overview"></a>Overview</h2><h2 id="Password-based-Authentication"><a href="#Password-based-Authentication" class="headerlink" title="Password-based Authentication"></a>Password-based Authentication</h2><h3 id="Plaintext-PW-method"><a href="#Plaintext-PW-method" class="headerlink" title="Plaintext PW method"></a>Plaintext PW method</h3><p>服务器和客户端之间的所有通信都应通过安全通道，如HTTPS或SSL&#x2F;TLS，以防止在传输过程中窃听或截获明文密码<br>受到这些威胁, Interception during Transmission(传输过程中的拦截),Server Breach(服务器被攻破), Insider Threat(内部威胁), Replay Attacks(重放攻击)。</p><h3 id="Hashed-PW-method"><a href="#Hashed-PW-method" class="headerlink" title="Hashed PW method"></a>Hashed PW method</h3><p>安全的哈希函数： 使用一个加密安全的哈希函数，它能抵抗碰撞攻击。这意味着几乎不可能找到两个不同的输入，产生相同的哈希输出。</p><h3 id="Hashed-PW-with-Salt-method"><a href="#Hashed-PW-with-Salt-method" class="headerlink" title="Hashed PW with Salt method"></a>Hashed PW with Salt method</h3><p>带盐可以防止彩虹表攻击(rainbow attack)</p><p>密码创建： 当用户创建他们的密码时，会产生一个独特的盐。盐和密码被串联起来，然后一起散列。盐和散列值（h1）都存储在服务器上的一个安全位置（例如，在基于Unix的系统上的&#x2F;etc&#x2F;shadow文件中）。</p><p>认证： 当用户输入他们的密码来登录时，这个过程会重复进行。存储的盐被附加到输入的密码上，然后对组合进行散列。这将产生一个新的哈希值（h2）。</p><h2 id="Unix-authN-Solution-Crypt"><a href="#Unix-authN-Solution-Crypt" class="headerlink" title="Unix authN Solution: Crypt()"></a>Unix authN Solution: Crypt()</h2><p>DES + salt , 提高了彩虹表4096倍, 但现在不行了，bcrypt或者scrypt。</p><h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a>Conclusions</h2><p>密码是最基本的认证机制<br>Ø安全级别只和你选择的密码一样好。<br>Ø它们很容易被猜中，除非采取预防措施确保<br>有足够大的可能的密码集，并且其中的每一个<br>潜在的密码被选中的可能性是相同的。<br>Ø挑战-回应技术允许系统改变密码，因此不容易受到猜测攻击。<br>因此，密码不容易被猜测攻击；OTP是这种技术的一个例子、<br>OTP是这种技术的一个例子，它对猜测和重放攻击特别有效。<br>q 认证也可以通过公钥加密技术实现。<br>也可以用公钥加密法实现，这需要公钥证书–X.509<br>标准。</p><p>还有其他形式的认证：生物识别技术测量用户的身体特征<br>用户的身体特征；位置要求验证者<br>来确定用户的位置。</p><p>PKC 应用: Confidentiality, Signatures and integrity , Identification and authentication , timestamping.</p><h1 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h1><p>Topic 3 :  Applications , when you should use which function?  Which function you use in which application , in which times, do not focus on details. But why they are efficient , why they are not efficient.  How to use them? </p><p>Topic 4 : DSA 不用记数学公式。</p><p>Topic 5 : 那几个公式要背。GCM不需要背。</p><p>Topic 6,7,8,9,10,11 : 全需要背。</p><h1 id="Con"><a href="#Con" class="headerlink" title="Con"></a>Con</h1><h3 id="IPsecs"><a href="#IPsecs" class="headerlink" title="IPsecs"></a>IPsecs</h3><ul><li>Transport Mode vs Tunnel Mode: transport只加密payload(数据),tunnel model 同时加密head和payload。 AH 无论用哪个model都不可以加密。上诉情况是指ESP。</li><li>AH(Authentication Header): <ul><li>data origin authentication  数据来源认证</li><li>data integrity 完整性</li><li>anti-replay 防重放 (SequenceNumber),IPsec header中有一个每个data package 的唯一序列号。从SA第一个数据报开始。</li><li>does not provide confidentiality protection  不提供保密性保护</li><li>outboard(sender)<ul><li>SA lookup : SA 由key , security protocal(AH, ESP), security parameters index(SPI)组成。</li><li>生成序列号</li><li>计算MAC</li></ul></li><li>inboard(receiver)<ul><li>Resumably(重组):较大数据需要被分割fragmented, 所以收到后要reassemble重组。</li><li>SA lookup : receiver 确定是正确的SA.</li><li>Sequence Number Verification</li><li>MAC 验证: 确保信息没有被修改。</li></ul></li></ul></li><li>ESP(Encapsulating Security Payload):<ul><li>outboard SA lookup 后面加密。 encrypt-then-mac 比mac-then-encrypt 或者mac-and-encrypt 更安全。在密码文本上计算mac，防止padding oracle attack(填充神谕攻击)</li><li>inboard MAC 之后解密。</li><li>比AH authentication认证更窄,因为AH保护所有数据，ESP不保护head。不需要confidentiality保密的时候AH是一个合适的协议。</li></ul></li></ul><h3 id="CA-和-KDC"><a href="#CA-和-KDC" class="headerlink" title="CA 和 KDC"></a>CA 和 KDC</h3><p>CA 是 asymmetric 的 , KDC 是 symmetric的。</p><h3 id="HMAC-1"><a href="#HMAC-1" class="headerlink" title="HMAC"></a>HMAC</h3><p>HMAC(K, M)&#x3D; H[(K+ XOR opad) || H[(K+ XOR ipad) || M]]; </p><h3 id><a href="#" class="headerlink" title></a></h3><h2 id="Attack"><a href="#Attack" class="headerlink" title="Attack"></a>Attack</h2><ul><li><p>Replay attack: eve拦截了data package 并且transmit很多次，让recipient以为自己收到了很多次。</p></li><li><p>padding oracle attack填充神谕攻击: eve利用解密过程中的错误信息来得到plaintext的内容。通常是mac直接通过plaintext得到而造成的。</p></li><li><p>meet-in-the-middle attack: 发生在双重加密之中。对前半段解密，后半段猜测为加密的信息进行加密。两者重合，寻找密钥。证明了双重加密无法提供两倍的安全性，所以三重。</p></li><li><p>cookie hijacking: 会话劫持，如果信息都暴露通常也伴随着被会话劫持。</p></li><li><p>brute force attack:</p></li><li><p>dictionary Attack: eve尝试生日，常见组合来破解密码。</p></li><li><p>rainbow table attack : 预先计算好的表，反转加密的hash function, 就是破解hash值的dictonary attack.</p><h2 id="security-properties"><a href="#security-properties" class="headerlink" title="security properties"></a>security properties</h2></li><li><p>integrity : 完整性 Hash.</p></li><li><p>confidentiality :  保密性</p></li><li><p>authenticity : 验证来源，CA.</p></li><li><p>non-repudiation: 不可抵赖性, 通常通过digit signature.</p></li><li><p>authorization: 授权。不同的用户有不同的权限。</p></li></ul><h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><p>PKI,CA,RSI,ECB,CBC,CTR,</p><h2 id="AES-block-cipher"><a href="#AES-block-cipher" class="headerlink" title="AES(block cipher)"></a>AES(block cipher)</h2><p>DES 8 bytes block , AES 16 bytes block.</p><h3 id="formula"><a href="#formula" class="headerlink" title="formula"></a>formula</h3><ol><li>EDE2(triple DES using 2 keys) : C &#x3D; EK1(DK2(EK1(M)))   </li><li>EDE3(triple DES using three keys):  C &#x3D; EK3(DK2(EK1(M)))   </li><li>AES</li><li>ECB : Cn &#x3D; E(K, Mn) ;  Mn &#x3D; D(K, Cn); n &#x3D; {1, 2, …}. (别忘了padding)</li><li>CBC : Ci &#x3D; E(K , Mi XORCi-1), where C0 &#x3D; IV (Initialization Vector) ; Mi &#x3D; D(K, Ci) XOR Ci-1 , M0 &#x3D; IV (别忘了padding)</li><li>CTR : Ci &#x3D; E(K, Counter + i) XOR Mi; i &#x3D; {1, 2, …}. Mi &#x3D; E(K, Counter + i) XOR Ci ; i &#x3D; {1, 2, …}.</li></ol><h3 id="如果消息比block-size长。"><a href="#如果消息比block-size长。" class="headerlink" title="如果消息比block size长。"></a>如果消息比block size长。</h3><h4 id="ECB-1"><a href="#ECB-1" class="headerlink" title="ECB"></a>ECB</h4><p> Cn &#x3D; Ek(Mn) (or E(K, Mn));<br> Mn &#x3D; Dk(Cn); n &#x3D; {1, 2, …}.<br>plaintext被分成很多与block size相同的text独立加密，然后再用分别的密钥独立解密。</p><ul><li>操作简便，但是对于有重复性的信息不安全。</li><li>最后一个block不足block size，需要padding，最后一个字节表示padding的长度，方便接收后删除。<h4 id="CBC-1"><a href="#CBC-1" class="headerlink" title="CBC"></a>CBC</h4>与ECB一样，不过每一个cipher block 都是用前一个cipher block的ciphertext和当前的plaintext进行加密，所以前面的block坏掉，后面的全会影响。<br>Initialization Vector :是一个随机值，给第一个plaintext增加随机性用的。<h4 id="CTR-1"><a href="#CTR-1" class="headerlink" title="CTR"></a>CTR</h4>目的是把block cipher变成stream cipher。<br>有一个counter 和 nonce 计数器最大值等于block size的数量。每一个计数器的数量等于block size的数量，然后用计数器的值和密钥进行加密，然后和plaintext进行XOR。</li></ul><ol><li>可以并行化。</li><li>可以随机访问。</li><li>与plaintext的XOR可以预先计算。</li><li>一个block的丢失，同步就会丢失，无法复原plaintext。</li><li>一个在传输过程中被修改的密码文本块只影响该块的解密。</li></ol><h2 id="Stream-Cipher-1"><a href="#Stream-Cipher-1" class="headerlink" title="Stream Cipher"></a>Stream Cipher</h2><p>流密码是一种对称密钥加密算法，一次对明文数据进行加密，每次加密一个比特或字节。它们通过生成一个密钥流进行操作，密钥流是由秘密密钥产生的一个比特或字节序列。然后，密钥流与明文使用位XOR操作相结合，产生密码文本。å</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>Bitwise XOR 效率高</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ol><li>Key length 密钥必须和明文一样长，这在大多数应用场景中是不现实的</li><li>如果同一个密钥被用于多个明文，流密码就会受到攻击。能够获得两个明文的XOR（M1 XOR M2）的攻击者，如果能够获得另一个plaintext及其相应的密码文本（M1和C1），就可以恢复其中一个明文。这是因为将M1与C1进行XOR（即M1 XOR K）会得到密钥K，然后攻击者可以使用K来解密C2（即M2 XOR K）并恢复M2。</li></ol><h3 id="stream和block-的区别"><a href="#stream和block-的区别" class="headerlink" title="stream和block 的区别"></a>stream和block 的区别</h3><ol><li>block 对字符块进行加密，stream对单个bit\character进行加密。</li></ol><h3 id="UNIX"><a href="#UNIX" class="headerlink" title="UNIX"></a>UNIX</h3><p>croe: 14mo31bmRY0Yg: 12:31:Cathy Roe: &#x2F;home&#x2F;croe:&#x2F;bin&#x2F;csh</p><ul><li>unix password file: &#x2F;etc&#x2F;passwd</li><li>User Name : croe</li><li>Password (14mo31bmRY0Yg) : salt value(14) + hash password </li><li>User ID(UID) : 12</li><li>Group ID(GID) : 31</li><li>Home Directory (&#x2F;home&#x2F;croe)</li><li>Shell (&#x2F;bin&#x2F;csh)</li></ul><h3 id="RSA-step"><a href="#RSA-step" class="headerlink" title="RSA step"></a>RSA step</h3><p>two prime number p,q<br>f(n) &#x3D; (p-1)(q-1)<br>1 &lt; e &lt; f(n)<br>d x e &#x3D; 1 mod f(n)<br>KPU &#x3D;  {e,n}<br>KPR &#x3D;  {d,n}<br>encrypt: message M &lt; n , C &#x3D; M^e mod n<br>decrypt: M &#x3D; C^d mod n   </p><h3 id="SA"><a href="#SA" class="headerlink" title="SA"></a>SA</h3><ol><li>negotiate policy such as authentication method , enctyption and has halgorithms , AH&#x2F;ESP,etc.</li><li></li></ol><h2 id="Exercise-Question-–-E9-1"><a href="#Exercise-Question-–-E9-1" class="headerlink" title="Exercise Question – E9.1"></a>Exercise Question – E9.1</h2><p>What is the major difference between transport mode and tunnel<br>mode in IPSec ESP, and any implications?</p><p>Unlike the tunnel mode, the transport mode only encrypts the<br>payload, not header. This means that in the transport mode, address info<br>and other header info are exposed.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>cv_笔记</title>
    <link href="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/01/30/cv-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><h2 id="lecture-2"><a href="#lecture-2" class="headerlink" title="lecture 2"></a>lecture 2</h2><h3 id="Image-representation"><a href="#Image-representation" class="headerlink" title="Image representation"></a>Image representation</h3><ul><li>Image function </li><li>Landscape </li><li>Array of pixels </li><li>Image histogram</li></ul><h3 id="Image-transformations"><a href="#Image-transformations" class="headerlink" title="Image transformations"></a>Image transformations</h3><p>g (x,y) &#x3D; f (x,y) + 20</p><p>g (x,y) &#x3D; f (-x,y)</p><h3 id="Image-Arithmetic"><a href="#Image-Arithmetic" class="headerlink" title="Image Arithmetic"></a>Image Arithmetic</h3><p>Addition : I3(x,y) &#x3D; I1(x,y) + I2(x,y) 会变得更亮，降噪</p><p>Subtraction : Static background, detects change, Object, shadows &amp;<br>reflections in realworld scenes</p><h3 id="Signal-to-Noise-Ratio-SNR"><a href="#Signal-to-Noise-Ratio-SNR" class="headerlink" title="Signal to Noise Ratio (SNR)"></a>Signal to Noise Ratio (SNR)</h3><p>较高的 SNR 表示图像包含更多有用的信息和较少的噪声，而较低的 SNR 表示图像的噪声较多且有用性较低。</p><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/1_1.jpeg"></p><h3 id="reduce-noise"><a href="#reduce-noise" class="headerlink" title="reduce noise"></a>reduce noise</h3><ol><li>temporal averaging : 平均9个图片</li><li>spatial averaging : 九宫格中间的像素平均九个的像素</li></ol><h3 id="noise-amp-scale"><a href="#noise-amp-scale" class="headerlink" title="noise &amp; scale"></a>noise &amp; scale</h3><ul><li>降噪会失去small-scale</li><li>noise是我们不想要的small-scale</li><li>如果最小的scale被移除，我们可以subsample分辨率或者用更少的pixel来表示图像</li></ul><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/1_2.jpeg"><br><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/1_3.jpeg"></p><h2 id="lecture-3"><a href="#lecture-3" class="headerlink" title="lecture 3"></a>lecture 3</h2><h2 id="week-2"><a href="#week-2" class="headerlink" title="week 2"></a>week 2</h2><h3 id="edge"><a href="#edge" class="headerlink" title="edge"></a>edge</h3><ol><li>it’s a curve</li><li>depth discontinuity</li><li>surface color discontinuity</li><li>illumination discontinuity</li></ol><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/2_1.jpeg"></p><p>用一条横切线，来寻找几个边界。和右图一样。</p><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/2_2.jpeg"></p><p>$I(x) * F(x)$</p><h3 id="Smoothing"><a href="#Smoothing" class="headerlink" title="Smoothing"></a>Smoothing</h3><ol><li>降噪</li><li>find details，subsampling</li></ol><p>*result: big structure of the image , return edges</p><ul><li>form : 00001210000</li></ul><h4 id="scale"><a href="#scale" class="headerlink" title="scale"></a>scale</h4><ul><li>细小的边缘可能只是 “噪音”（无关紧要的小尺度结构）。我们只需要outline。</li><li>较大尺度的边缘的检测更可靠，因为混乱的细节较少。</li><li>粗尺边缘(coarse scale)的位置可以指导对细尺度边缘的搜索。更精细的边缘。更快、更稳健。</li></ul><h4 id="scale-effect"><a href="#scale-effect" class="headerlink" title="scale effect"></a>scale effect</h4><ul><li>$\sigma$ small , middle of kernel is small   </li><li>$\sigma$ bigger , take from a larger area(更boarder), smoothing lot more. bigger structure, bigger edges.</li></ul><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/2_3.jpeg"><br><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/2_4.jpeg"></p><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/2_5.jpeg"><br>≈</p><h3 id="Canny-Edge-Detector"><a href="#Canny-Edge-Detector" class="headerlink" title="Canny Edge Detector"></a>Canny Edge Detector</h3><h1 id="Week-3"><a href="#Week-3" class="headerlink" title="Week 3"></a>Week 3</h1><h2 id="Hough-Lines"><a href="#Hough-Lines" class="headerlink" title="Hough Lines"></a>Hough Lines</h2><h3 id="Cartesian-coordinates"><a href="#Cartesian-coordinates" class="headerlink" title="Cartesian coordinates"></a>Cartesian coordinates</h3><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/3.jpeg"></p><ol><li>y &#x3D; mx + c -&gt; c &#x3D; -xm + y</li><li>(0,0) , (10,10) -&gt; c &#x3D; 10m + 10</li><li>把所有线用c和m表示出来，threshold&gt;&#x3D;3 的话，经过3个点的那个点m &#x3D; -1，c &#x3D; 0. 所以y&#x3D;-x</li></ol><p>What if a line in our image is vertical? m &#x3D; 正无穷</p><p>如果有线是vertical，m无限大，所以用Polar coordiates。</p><h3 id="Polar-cooridates"><a href="#Polar-cooridates" class="headerlink" title="Polar cooridates"></a>Polar cooridates</h3><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/4.jpeg"><br>Point (0, 0), r &#x3D; 0 cos(θ) + 0 sin(θ) &#x3D; 0</p><h3 id="Hough-Circles"><a href="#Hough-Circles" class="headerlink" title="Hough Circles"></a>Hough Circles</h3><p>求到点之后， (a − x)^2 + (b − y)^2 &#x3D; r^2<br><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/5.jpeg"></p><p>A(Xc,Yc,s,$\theta$)</p><h3 id="Generalised-Hough-Transform"><a href="#Generalised-Hough-Transform" class="headerlink" title="Generalised Hough Transform"></a>Generalised Hough Transform</h3><p>它还可以检测除了圆和线以外的形状</p><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/6.jpeg"></p><p>xc &#x3D; x + r cos(α)<br>yc &#x3D; y + r sin(α)</p><h1 id="Week-2"><a href="#Week-2" class="headerlink" title="Week 2"></a>Week 2</h1><h2 id="edges"><a href="#edges" class="headerlink" title="edges"></a>edges</h2><p>edges caused by </p><ol><li>depth discontinuity 深度不连续</li><li>surface colour discontinuity 表面颜色不连续</li><li>illumination discontinuity 光照不连续</li></ol><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/1.jpeg"><br>积分用来找edge<br><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/2.jpeg"></p><h2 id="kernels"><a href="#kernels" class="headerlink" title="kernels"></a>kernels</h2><h3 id="Prewitt-Kernel"><a href="#Prewitt-Kernel" class="headerlink" title="Prewitt Kernel"></a>Prewitt Kernel</h3><pre><code class="hljs">vertical edges  -1 0 1  -1 0 1  -1 0 1horizontal edges  -1 -1 -1  0  0  0  1  1  1  </code></pre><h3 id="Sobel-Kernel"><a href="#Sobel-Kernel" class="headerlink" title="Sobel Kernel"></a>Sobel Kernel</h3><p> 加了一个权重</p><pre><code class="hljs">vertical edges-1 0 1-2 0 2-1 0 1horizontal edges-1  2 -1 0  0  0 1  2  1</code></pre><h2 id="Selecting-Edge-Scale"><a href="#Selecting-Edge-Scale" class="headerlink" title="Selecting Edge Scale"></a>Selecting Edge Scale</h2><p>■ Edge detection at selected scale<br>高斯模糊</p><p>■ Derivative of Gaussian filter<br>■ Laplacian of Gaussian</p><h1 id="week4"><a href="#week4" class="headerlink" title="week4"></a>week4</h1><p>Univariate Normal (Gaussian) Distribution(单变量正太分布)</p><p>A normal distribution is not good enough! Need a way to make more complex distributions</p><p>Multivariate Normal Distribution (多变量正态分布)</p><h2 id="Mixture-of-Gaussians-MoG-vs-EM"><a href="#Mixture-of-Gaussians-MoG-vs-EM" class="headerlink" title="Mixture of Gaussians(MoG) vs EM"></a>Mixture of Gaussians(MoG) vs EM</h2><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>Probabilistic Interpretation:  MoG 有a data point belonging to each cluster每个数据点分配一个聚类。</li><li>Soft Assignments: MoG 点是以概率分配给每个cluster的，如果有的点在cluster是不确定的，这是很有用的。</li><li>Generative Model: 不仅建模一存在数据，也创建新的数据点。</li><li>Relatively Compact Storage: GMM 存放紧凑。</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>Local Minima: 他保证了收敛性,</li></ol><h2 id="Week-6"><a href="#Week-6" class="headerlink" title="Week 6"></a>Week 6</h2><p>Window Function:<br>1 in window , 0 outside window</p><p>Shifted Intensity:  </p><p>Intensity:  </p><p>$E(u, v) ≈ [u,v] M [u]^T\ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ [v]$</p><p>其中M是一个2x2矩阵，被称为结构张量或第二矩矩阵，由图像梯度组成：</p><p>$M &#x3D; ∑_{x, y} w(x, y) * [Ix^2, IxIy \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ \ IxIy, Iy^2]$</p><p>这里，Ix和Iy分别是图像强度在x和y方向的偏导数。</p><p>这种提法简化了原来的变化度量，并使哈里斯角落检测器的计算效率提高，使其能够快速识别图像中的角落。</p><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/7.jpeg"></p><p>Harris 特点: defines interest points. Precise localization ,High repeatability.</p><p>Scale Invariant Region Selection : 两个相同大小不同的物体，他们的特征是一样的。</p><p>Automatic Scale Selection :  选择对某一特定特征提供最有用或最独特信息的比例。</p><p>Difference-of-Gaussian (DoG) Detector :  feature detection algorithm。</p><h3 id="Naive-Approach-Exhaustive-Search-朴素方法：穷举搜索"><a href="#Naive-Approach-Exhaustive-Search-朴素方法：穷举搜索" class="headerlink" title="Naïve Approach: Exhaustive Search (朴素方法：穷举搜索)"></a>Naïve Approach: Exhaustive Search (朴素方法：穷举搜索)</h3><p>Multi-scale procedure: 从大到小逐渐搜索，先搜索全地图，在搜索房子，然后人。  </p><p>Compare descriptors while varying the patch size: 局部的前一点。<br>Computationally inefficient: 消耗了大量的算力。</p><p>Inefficient but possible for matching: 效率不高但也可以用。</p><p>Prohibitive for retrieval in large databases: 大型数据中检索不利。</p><p>Prohibitive for recognition: 识别不利。</p><h3 id="Automatic-Scale-Selection-自动比例选择"><a href="#Automatic-Scale-Selection-自动比例选择" class="headerlink" title="Automatic Scale Selection (自动比例选择)"></a>Automatic Scale Selection (自动比例选择)</h3><p>意思就是mulit-scale procedure 的具体确定。</p><p>Scale Invariant Function: 这个函数对两个不同比例但相同的图像会给定相同的输出。</p><p>Function of Region Size: 一个函数，它的输出是一个区域的大小。 </p><p>Take a Local Maximum: auto scale selection 的最后一步，找到最大值。  </p><p>Normalize&#x2F; Rescale: 找到了最佳比例后，图像中周围的点都是一个固定的比例，使得目标点可以更好的比较。<br><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/8.jpeg"></p><p>Scale Signature: 一个函数，描述的是图像中特定特征的意义，应该是稳健的，不被噪声或者微小变化干扰的，并且高效的。</p><h3 id="Laplacian-of-an-Image"><a href="#Laplacian-of-an-Image" class="headerlink" title="Laplacian of an Image"></a>Laplacian of an Image</h3><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/9.jpeg"></p><p>sobel专注于梯度变化，对噪声的抵抗力相对较强，使它适合于高对比度的边缘。laplacian关注二阶导数变化，可以捕捉到sobel检测器可能错过的edge，但对噪声更敏感, laplacian 能够检测到强度在两个方向上都有变化的地方的边缘（比如从暗到亮再到暗的地方）。</p><h3 id="Laplacian-of-Gaussian，-LOG"><a href="#Laplacian-of-Gaussian，-LOG" class="headerlink" title="Laplacian of Gaussian， LOG"></a>Laplacian of Gaussian， LOG</h3><p>很好的signature, 善于识别图像中的blob。</p><ol><li>Gaussian filter smooth the image. </li><li>Compute the Laplacian of the smoothed image.</li><li>LoG高的地方是blob的中心。</li></ol><h3 id="Harris-Lapace-method"><a href="#Harris-Lapace-method" class="headerlink" title="Harris-Lapace method"></a>Harris-Lapace method</h3><p>一种feature detector</p><ol><li>init, 用harris来寻找corner。</li><li>Laplacian 来选择scale。</li><li>用DoG替代LoG, 加速实现。LoG很昂贵，用Dos替代。</li></ol><h3 id="Difference-of-Gaussian-DOG"><a href="#Difference-of-Gaussian-DOG" class="headerlink" title="Difference-of-Gaussian DOG"></a>Difference-of-Gaussian DOG</h3><p>SIFT 等feature detecotor的基础。</p><ol><li>不需要二阶导。</li><li>Gassian 都要计算的无论如何，所以如果有Gaussian pyramid, 计算DoG的基本数据已经有了，会更加快。 在高斯比例金字塔中，原始图像被递归地缩小，每次都被高斯滤波器平滑化。然后在金字塔中每一对相邻的平滑图像之间计算DoG。</li></ol><p>该算法在比例空间中搜索DoG的局部最大值以检测潜在的关键点或兴趣点。在检测到潜在的关键点后，它应用两个过滤器：</p><p>低对比度阈值： 该算法放弃了对比度低于某个阈值的关键点。这有助于减少噪声的影响。</p><p>边缘响应消除： 该算法还抛弃了位于边缘的关键点。这是因为DoG对边缘很敏感，会产生假阳性反应。</p><p>更简单地说，哈里斯-拉普拉斯方法首先在不同的缩放级别上寻找角落，然后利用拉普拉斯选择每个角落的最佳缩放级别。然后，它使用高斯之差，如果你使用的是高斯金字塔，它的计算速度更快，而且已经是这个过程的一部分，来寻找图像中的关键点。该方法可以过滤掉对比度太低的点或位于边缘的点，以确保有一套强大的关键点。</p><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/10.jpeg"></p><h3 id="summary-Scale-Invariant-Detection"><a href="#summary-Scale-Invariant-Detection" class="headerlink" title="summary: Scale Invariant Detection"></a>summary: Scale Invariant Detection</h3><p>● 给定： 同一场景的两幅图像，它们之间有很大的比例差异<br>差异。</p><p>目标：在每张图像中独立地找到相同的兴趣点。</p><p>● 解决方案： 搜索合适的函数在比例上的最大值<br>和空间上的适当函数的最大值（在图像上）。</p><p>两种策略</p><p>拉普拉斯高斯函数(LoG)</p><p>高斯之差(DoG)作为一种快速近似方法</p><p>这些方法既可以单独使用，也可以与以下方法组合使用单一尺度的关键点检测器（即Harris角落检测器）。</p><h1 id="week-7-Local-Feature"><a href="#week-7-Local-Feature" class="headerlink" title="week 7 Local Feature"></a>week 7 Local Feature</h1><p>Feature detection。</p><ol><li>Invariant Detector : 不变的检测器。</li><li>Find interest points : 寻找兴趣点。</li><li>Remove effect of scale : 消除比例影响。</li><li>Invariant descriptor : 不变的描述符,旋转，比例变化不产生影响。</li></ol><p>Local Feature </p><p>feature detection</p><p>Find Local Orientation: 对于一个patch，寻找到他的dominant direction(local orientation).</p><p>Rotate Patch According to this angle: 找到angle之后，对他进行旋转，使得他的dominant direction和x轴对齐。</p><h2 id="Scale-Invariant-Feature-Transform-SIFT"><a href="#Scale-Invariant-Feature-Transform-SIFT" class="headerlink" title="Scale Invariant Feature Transform (SIFT)"></a>Scale Invariant Feature Transform (SIFT)</h2><p>SIFT是一种识别关键点的方法，并以一种对比例和旋转不变的方式来描述它们，而且对视角和光照的变化也很稳健。可以处理大角度。</p><h3 id="Feature-matching"><a href="#Feature-matching" class="headerlink" title="Feature matching"></a>Feature matching</h3><p>Given a feature in I1, how to find the best match in I2?</p><ol><li>Define distance function that compares two descriptors</li><li>Test all the features in I2, find the one with min distancer</li></ol><p>简单方法SSD(f1,f2)<br>两个描述点之间的平方差和。</p><p>更好的匹配: ratio distance &#x3D; SSD(f1,f2) &#x2F; SSD(f1’,f2’)</p><p>TP 是真正是别的匹配。</p><p>FP 是错误匹配的。</p><p>最大化TP增加召回率，最小化FP增加精准度之间找到平衡。</p><p>Features are used for:<br>■ Image alignment (e.g., mosaics) 图像对准（例如，马赛克）。<br>■ 3D reconstruction  三维重建<br>■ Motion tracking  运动跟踪<br>■ Object recognition 物体识别<br>■ Indexing and database retrieval 索引和数据库检索<br>■ Robot navigation 机器人导航  </p><h2 id="week-7-part2"><a href="#week-7-part2" class="headerlink" title="week 7 part2"></a>week 7 part2</h2><p>Depth with Stereo : 用两个相机来计算深度。用的是triangulation 三角测量法</p><p>image I(x,y) Disparity map D(x,y) image I´(x´,y´)</p><p>(x´,y´)&#x3D;(x+D(x,y), y)</p><p>Finding Correspoinces: 容易识别的有趣的点。</p><p>The Epipolar Constraint: 相机的位置是一致的，用这个来减少搜索空间。</p><p>Matching Edges: edges是方便匹配的地方。</p><p>Edge Detection: Canny detector. Multiple scale. Accurate.</p><p>用edges的优缺点:</p><ol><li><p>代表了重要的结构，数量不多，可以用image feature来验证匹配。</p></li><li><p>可以准确定位他们。</p></li><li><p>Multi-scale location。</p></li><li><p>不是所有的重要结构都在边缘上。</p></li><li><p>边缘的大小特征可能匹配的不可靠。</p></li><li><p>近水平的edges不能提供良好的定位。</p></li></ol><p>Moravec Poeratro Detector: 用于寻找corners。</p><ol><li>Non-linear filter</li><li>5x5 </li><li>不是旋转不变的，倾向于对edges做出强烈反应。</li></ol><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/12.jpeg"></p><h1 id="week-8-stereo-visiion"><a href="#week-8-stereo-visiion" class="headerlink" title="week 8 stereo visiion"></a>week 8 stereo visiion</h1><h2 id="part-1"><a href="#part-1" class="headerlink" title="part 1"></a>part 1</h2><p>Triangulation: 三角测量法</p><p>Epipolar Geometry: 通过这个平面来寻找depth information.</p><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/13.jpeg"></p><p>Extrinsic Parameters: 描述相机的姿态。 R T</p><p>Epipolar Constraint: 立体图像中的点总是对应epipolar lines。</p><p>Epipole: 两个相机的中心点。是所有epipolar lines 的汇聚点。</p><p>Disparity: 两个立体图像中的一个点的位置差异。与对应像素的depth成反比。</p><p>Rectification: 立体图像的转换过程。</p><p>Intrinsic Parameters: focal length, principal point, lens distortion coefficients….</p><p>Essential Matrix: 封装了两个相机是图之间的几何形状，translation and rotation 的matrix。</p><p>Sterio calibration: 立体校准，评估参数找到Intrinstic 和 extrinstic parameters.</p><p>总体步骤:</p><ol><li>stereopsis 提供3D位置的精准测量。</li><li>需要建立对应关系，比如Epipolar lines, Matching criteria(匹配标准比如edge，corners，interest points), Disparity computation。</li><li>Constraints(Calibration立体校准从而获得内部参数和外部参数)</li><li>Reconstruction by triangulation 三角测量进行三维重组。</li></ol><h2 id="part-2"><a href="#part-2" class="headerlink" title="part 2"></a>part 2</h2><p>Image Alignment 图像对准<br>Application: Image Stiching 图像拼接</p><ul><li>Euclidean &#x3D; (translation + rotation) </li><li>Similarity &#x3D; (translation + rotation + scaling)</li><li>Affine &#x3D; (translation + rotation + scaling + shear )</li><li>Projective &#x3D; (homography)</li></ul><h3 id="RANSAC"><a href="#RANSAC" class="headerlink" title="RANSAC"></a>RANSAC</h3><ol><li>Randomly select a minimal set of points. 能适合模型最小的可能大小，比如一条线需要2个点。</li><li>为这个子集计算模型的参数，比如tranformation</li><li>inliers: 用这个模型来测试所有的数据，如果数据点与模型的距离小于某个阈值，就认为它是一个inlier。</li><li>把数据分成inliers and outliers, inliers就是好的，outliers就是坏的。</li><li>如果inliers显著的大，就用inliers重新测量，得到精炼模型。</li><li>重放1-4次。</li><li>找到最大inliers的模型作为最终模型。</li><li>优点在于即使存在大量的outliers，也能找到好的模型。尤其是outliers大于50%的时候，也能通过N来确定模型。</li></ol><p>找到这个变换的异常值： 在估计出一个模型后，RANSAC根据所选择的距离度量将其余的数据分类为离群值和异常值。异常值是指与估计模型契合度高的点（即它们与模型的距离低于某个阈值），而异常值则不是。</p><p>如果离群点的数量足够大，就在所有离群点上重新计算最小二乘法的变换估计： 如果离群值的数量足够大，RANSAC使用所有离群值重新估计模型参数，并得到一个精炼的模型。</p><p>重复N次： 步骤1-4重复N次，N是该算法的一个参数。每次迭代都有可能产生一组不同的异常值和模型参数。</p><p>保留具有最大数量离群值的变换： 在所有迭代之后，RANSAC会选择具有最大离群值的模型作为最终模型。</p><p>RANSAC的优点在于，即使数据中存在大量的异常值，它也能够找到正确的模型。然而，它并不能保证一个最佳的解决方案，特别是当异常值的比例非常高时（&gt;50%）。迭代次数（N）和确定异常值的阈值是能够影响RANSAC性能的关键参数。</p><h3 id="总体步骤"><a href="#总体步骤" class="headerlink" title="总体步骤"></a>总体步骤</h3><p>Given two (or more) images:</p><ul><li>Step 1: Detect features, 在全景图像拼接中，通常首选SIFT（尺度不变特征变换）</li><li>Step 2: Match features  ssd 或者 ssd1&#x2F;ssd2</li><li>Step 3: Compute a homography using RANSAC</li><li>Step 4: Combine the images together (image blending) : Iblend &#x3D; αIleft + (1-α)Iright alpha blending</li></ul><p>好的window是什么样的？<br>avoid seams, avoid ghosting. 避免接缝和重影。</p><h1 id="week-9-object-recognition-with-local-feature"><a href="#week-9-object-recognition-with-local-feature" class="headerlink" title="week 9 object recognition with local feature"></a>week 9 object recognition with local feature</h1><h3 id="Indexing-with-Local-Features"><a href="#Indexing-with-Local-Features" class="headerlink" title="Indexing with Local Features"></a>Indexing with Local Features</h3><p>Inverted File Index: 倒置文件，一种数据结构，存放着visual features的索引。用于快速检索特定的特征。</p><p>Visual Words: SIFT等来识别出的特征corner，edge, blob 等。</p><p>Visual Vocabulary Construction : 用k-means来构建visual vocabulary。visual words的集合。</p><p>Use for Content-Based Image&#x2F;Video Retrieval: 一旦我们有了Inverted File Index和Visual Words 我们就可以提取所有视觉词，找到包含相同词的图像或者视频。相同的共同词越多我们约我认为他们相似。</p><h3 id="Object-Categorization"><a href="#Object-Categorization" class="headerlink" title="Object Categorization"></a>Object Categorization</h3><p>Object Categorization Revisited: 重新审视物体分类。比如狗，汽车，把检测的物体装进大集合里面。</p><p>More Exact Task Definition: 更精准的任务定义。比如给定一个图像，判断它是否包含一个特定的特征，比如颜色，大小。不仅仅是识别物体的类型是什么。</p><p>basic Level Catergories: 对物体进行分类，比如狗为一个大类，相对于哺乳动物或者狮子狗来说。</p><p>Category Representations: cv中如何表现类别，最常见的是vector of features。每一个特征是类别中的某些方面，比如颜色，形状。</p><h3 id="BoG-Bag-of-Words-Representations"><a href="#BoG-Bag-of-Words-Representations" class="headerlink" title="BoG (Bag-of-Words) Representations"></a>BoG (Bag-of-Words) Representations</h3><p>BoG Representations: 用于图像分类的一种表示，其中图像被视为单词的集合，而不是像素的集合。这种表示通常用于图像分类，其中图像被视为单词的集合，而不是像素的集合。这种表示通常用于图像分类，其中图像被视为单词的集合，而不是像素的集合。这种表示通常用于图像分类，其中图像被视为单词的集合，而不是像素的集合。这种表示通常用于图像分类，其中图像被视为单词的集合，而不是像素的集合。这种表示通常用于图像分类，其中图像被视为单词的集合，而不是像素的集合。这种表示通常用于图像分类，其中图像被视为单词的集合，而不是像素的集合。这种表示通常用于图像分类，其中图像被视为单词的集合，而不是像素的集合。这种表示通常用于图像分类，其中图像被视为单词的集合，而不是像素的集合。<br><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/14.jpeg"></p><p>优点: </p><ol><li>Flexible to geometry&#x2F;deformations&#x2F;viewpoint: BoW模型对空间排列不敏感，因此可以处理物体的变形，旋转和不同的视角。</li><li>Compact summary of image content: BoW模型是图像内容的紧凑摘要，因此可以处理大量的图像。</li><li>Povides vector representation for sets: 每幅图像可以被表示为高维空间中的一个向量，其中每个维度都对应着一个 “视觉词”。这允许对图像进行有效的比较和分类。</li><li>简单且表现良好。</li></ol><p>缺点:</p><ol><li>忽略了geometry，忽略了几何学。重大限制，不过可以在BoW匹配之后执行一个集合验证步骤来解决。</li><li>BoW覆盖整个图像，background和foreground 都被考虑进去了。这可能会导致噪音和不相干的特征被包含在bag中，会导致性能降低。</li><li>Interest Points or sampling: 不能保证物体层面的部分。</li><li>Optimal vocabulary formation remains unclear: 不同方法适用于不同的任务和数据集，没有一个公用的。</li></ol><h1 id="Feature-Detection-Application-Drone-Self-localisation"><a href="#Feature-Detection-Application-Drone-Self-localisation" class="headerlink" title="Feature Detection Application - Drone Self-localisation"></a>Feature Detection Application - Drone Self-localisation</h1><h3 id="GPS"><a href="#GPS" class="headerlink" title="GPS"></a>GPS</h3><p>GPS 问题: </p><ol><li>复杂地形不行</li><li>GPS容易被spoofing欺骗</li><li>GPS signal blocking 高于卫星信号发射信号防止他们被接收</li></ol><h3 id="Face-Detection"><a href="#Face-Detection" class="headerlink" title="Face Detection"></a>Face Detection</h3><p>Decisiion Trees and Random Forest: 构建大量的decision trees，每个tree都是一个分类器，最终结果是所有分类器的投票结果。</p><p>AdaBoost : ml算法，结合表现不佳的分类器来构建一个强大的分类器。</p><p>Viola-Jones Face Detector: 用于检测人脸的ml算法，基于AdaBoost，通过AdaBoost来提高分类器准确性。</p><p>OpenCV: 题哦给你了CascadeClassifer， 可以用来创建Viola-Jones检测器。</p><h1 id="LAST-DANCE"><a href="#LAST-DANCE" class="headerlink" title="LAST DANCE"></a>LAST DANCE</h1><h2 id="Hough"><a href="#Hough" class="headerlink" title="Hough"></a>Hough</h2><ol><li>edge detection : canny</li><li>parameter space : (p,theta)  或者 (x,y)</li><li>accumulator space : voting 累积每一个经过的点</li><li>line detection : 投票过的点坐标作为在最终图像中的线。</li></ol><h3 id="Generalized-Hough-Tranform-GHT"><a href="#Generalized-Hough-Tranform-GHT" class="headerlink" title="Generalized Hough Tranform(GHT)"></a>Generalized Hough Tranform(GHT)</h3><p><img src="/2023/01/30/cv-%E7%AC%94%E8%AE%B0/6.jpeg"></p><p>where r is the distance from the reference point to the boundary point and<br>θ is the angle</p><h2 id="一些基本概念"><a href="#一些基本概念" class="headerlink" title="一些基本概念:"></a>一些基本概念:</h2><ul><li><p>PCA: 种通过压制较弱的模式来带出数据集中的强势模式的方法，使数据更容易被可视化、理解和被后续算法处理。它通常被用于探索性数据分析和制作预测模型</p></li><li><p>ASM (Active Shape Model)<br>物体形状的统计模型，手动标注了地标点，用来构建模型。</p></li><li><p>local feature 猫的耳朵。。。小特征</p></li><li><p>3D Reconstruction: 三维重建</p></li><li><p>Image Compositing: 图像合成 , 把两个图像合二为一融合起来。</p></li><li><p>Segmentation and grouping : 分割是将图像划分为多个片段或 “区域 “的过程，其目的是简 图像和&#x2F;或将其表现形式改变为更有意义的东西</p><ul><li>Gestalt principles: 花花草草为一组，树木为一组。。。</li><li>Image segmentation: 一般要使用颜色的分割，边缘检测。。。</li></ul></li><li><p>EM,GM ,K-means: random initialization, 和 K-means++ 两种初始化方法,GMM + EM &#x3D; 每一个cluster要遵循高斯分布, soft clustering, K-means 反之是hard clustering</p></li><li><p>Harris vs SIFT</p><ol><li>Scale-Invariance, Harris 在不同尺度下才能显示出的corner Harris发现不了。SIFT通过difference of Gaussian approach 做到了这一点。</li><li>Rotation-Invariance, 物体旋转Harris检测不出，SIFT可以</li><li>descriptor, harris自己是没有descriptor的需要结合别的方法，他只有keypoints。</li><li>SIFT耗时久，如果只关注corner或者需要高效，Harris是个好选择。</li><li>Harris: 使用图像强度的二阶导数矩阵来观察每个像素周围的图像局部结构。这个矩阵的特征值给出了图像中该点的边缘或角落的强度的测量，这个矩阵被用来创建一个触发角落的响应函数。</li><li>SIFT:<ul><li>Contrast threshold: 一个过滤器，删除那些由于对比度低而不太可能被正确匹配的点。</li><li>Curvature Threshold: 消除具有高边缘响应的关键点。这是因为边缘往往可以有很高的对比度。该算法可以将重点放在角落、大块和其他更有可能被稳健匹配的区域。</li><li>Dimensionality of Feature vector:  SIFT中特征向量的维度是指为每个关键点创建的方向直方图中的宾格数量。这些方向直方图代表了关键点周围不同子区域的梯度（即方向）分布。</li><li>steps: <ol><li>scale-space extrema detection: 通过scale-space pyramid 寻找intrest points</li><li>keypoint localization: 通过两个threshold减少第一步选择的keypoints。</li><li>give an orientation to the keypoints.</li><li>keypoint descriptor:  表示为一个vector。</li></ol></li></ul></li></ol></li><li><p>BoW(Bag of Words): </p><ol><li>Feature extraction(特征提取): SIFT, ORB….</li><li>Clustering: k-means, GMM … ,每一个cluster都是一个visual words</li><li>Histogram creation: 每一个 visual words的出现频率</li><li>Naive Bayes classifier:</li></ol></li><li><p>Image Alignment 图像对准   Application: Image Stiching</p><ol><li>Camera calibration : Extrinsic parameters(Rotate matrix ,Translate Vector). ntrinsic parameters(focal length, original offset(原点偏移),  Pixel size(像素大小))</li><li>Feature extraction and matching: SIFT…. </li><li>Rectification: 对其两张图像，相同的点位于同一水平线上</li><li>Disparity computation :两张图片找到差异的点，作为x移动的坐标</li><li>Depth estimation：用disparities三角测量，来算每个点的深度Z &#x3D; fB&#x2F;d。</li></ol></li><li><p>Stereo: </p><ol><li>Window Size, 小只能包含像素差异，大会包含区域差异。</li><li>sparse, 只考虑部分特征，比如SIFT。需要方法确定哪些特征是重要或者相关的。</li><li>dense, 用每个像素点来计算，但是计算量大，三维重建游泳，缺乏纹理或者细节区域效果不好。图像视角非常不同的时候，dense也不能用。</li></ol></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ux_review</title>
    <link href="/2023/01/25/ux-review/"/>
    <url>/2023/01/25/ux-review/</url>
    
    <content type="html"><![CDATA[<h1 id="Introducing-the-User-Experience"><a href="#Introducing-the-User-Experience" class="headerlink" title="Introducing the User Experience"></a>Introducing the User Experience</h1><h2 id="HCI"><a href="#HCI" class="headerlink" title="HCI"></a>HCI</h2><p>Human-Computer Interaction  包含了这些学科: computer science, ergonomics, interface design, sociology and psychology. </p><p>从计算机科学的早期开始，从打卡机到QWERTY键盘的转变。从 “Doug Englebart “的鼠标和初级超文本系统，到施乐PARC的图形用户界面工作。到任何计算机之间共享信息的愿望（万维网），人一直是系统的核心。因此，人机交互在计算机科学方面有很长的历史，但作为一个独立的学科领域却相对年轻。在某些方面，它的研究与它所帮助实现的组件的研究是不可分割的。然而，正如我们将看到的，与计算机科学的大多数其他方面不同的关键科学原理，支持和支撑着这个领域，并暗示着它作为用户体验的实际应用。</p><p>我们将讨论用户体验的各个方面，如快速应用开发和敏捷性，人和交互性的障碍，需求收集，案例研究和焦点小组，故事和角色。我们将研究无障碍准则和可用性原则，以及情感设计和以人为本的设计。最后，我们将触及科学方法、实验和推理统计。这似乎是一个相当多的内容，但是相对于更广泛的人因&#x2F;人机交互领域来说，它是非常小的。例如，我们将不包括。</p><h4 id="HCI-三阶段-（IEEE-standard-610）"><a href="#HCI-三阶段-（IEEE-standard-610）" class="headerlink" title="HCI 三阶段 （IEEE standard 610）"></a>HCI 三阶段 （IEEE standard 610）</h4><ul><li>creation of the principles theories and methodologies, </li><li>the application of those aspects into a development</li><li>the testing of the outcomes of that development.</li></ul><p>(1）用户为解决问题或实现目标所需要的条件或能力；（2）系统或系统组件必须满足或拥有的条件或能力，以满足合同标准规范或其他以前规定的文件；以及（3）（1）或（2）中条件或能力的文件化表示”。</p><h2 id="UX"><a href="#UX" class="headerlink" title="UX"></a>UX</h2><p>作为一个用户体验专家，你将关注围绕原则和指导方针在开发中的应用的实践方面，以及对开发结果的测试。这意味着你将需要考虑到开发和个人体验的渐进性。</p><p>usability, but some would say takes-its-lead from the emerging discipline of experience design (XD).</p><h4 id="用户体验专家的重点是确保用户从一开始就被考虑在内"><a href="#用户体验专家的重点是确保用户从一开始就被考虑在内" class="headerlink" title="用户体验专家的重点是确保用户从一开始就被考虑在内"></a>用户体验专家的重点是确保用户从一开始就被考虑在内</h4><h4 id="社区认为用户体验必须以用户为中心的设计为基础，我们不能设计用户体验，但我们可以为用户体验而设计"><a href="#社区认为用户体验必须以用户为中心的设计为基础，我们不能设计用户体验，但我们可以为用户体验而设计" class="headerlink" title="社区认为用户体验必须以用户为中心的设计为基础，我们不能设计用户体验，但我们可以为用户体验而设计"></a>社区认为用户体验必须以用户为中心的设计为基础，我们不能设计用户体验，但我们可以为用户体验而设计</h4><h2 id="UX-and-HCI"><a href="#UX-and-HCI" class="headerlink" title="UX and HCI"></a>UX and HCI</h2><h4 id="主要"><a href="#主要" class="headerlink" title="主要"></a>主要</h4><p>人机交互领域–用户体验是其中的一部分–是不一样的，每个从业者都来自不同的专业领域。在某些情况下，心理学或人机工程学，在其他情况下，社会学，对我们来说，软件工程可能是主要的专业，而在用户体验的背景下，产品设计师也是特色。</p><h4 id="其次"><a href="#其次" class="headerlink" title="其次"></a>其次</h4><p>用户体验（UX）是关于一个人使用一个系统的感觉。用户体验突出了人机交互（HCI）和产品所有权的体验性、情感性、有意义和有价值的方面，但它也涵盖了一个人对系统的实用性、易用性和效率等方面的看法。UX在本质上是主观的，因为它是关于个人对系统的表现、感受和想法。</p><h1 id="Perceiving-Sensory-Information"><a href="#Perceiving-Sensory-Information" class="headerlink" title="Perceiving Sensory Information"></a>Perceiving Sensory Information</h1><p>参与收集数据以形成对系统或界面应该如何工作的理解。不管个人项目的重点是什么，用户体验专家主要关注的是人以及他们与计算系统的互动方式。</p><p>理解人类如何接受信息、理解并从这些信息中学习，并利用这些信息来指导他们对外界的控制，是理解人类经验的关键[Weinschenk, 2011]（见图中的PET扫描：葡萄糖代谢的PET研究）。在这里，我们并不直接关注这些过程的解剖学、生理学或心理学方面（有许多深入的论述涉及这些领域），而是从用户与软件或设备的结合点来看待它们。在这种情况下，我们可以简单地认为，人类感觉和感知外部环境（系统或界面），处理和存储这些知识，直接或在未来使用这些知识。此外，基于过去和当前的知识，对外部环境（同样，在这种情况下，系统或界面）施加控制[Bear等人，2007]。</p><h2 id="Inattention-blindness-amp-amp-attention-blindness"><a href="#Inattention-blindness-amp-amp-attention-blindness" class="headerlink" title="Inattention blindness &amp;&amp; attention blindness"></a>Inattention blindness &amp;&amp; attention blindness</h2><p>那么，这个现象只是理解用户、他们的感知和他们的注意力所涉及的复杂性的一个例子。这种现象被称为 “注意力盲”、”注意盲 “或 “感知盲”，与我们的期望、感知和注意力的位置有关。简单地说，”不注意盲 “描述的是我们注意到在明处且已被看到的东西的能力。这通常发生在我们不期望刺激物发生的时候–为什么大猩猩会在篮球比赛中进行月球漫步？如果我们认为它不应该在那里，我们的大脑就会通过不在认知上登记该刺激物来补偿知觉输入。然而，有很多其他的测试也显示了这种现象。此外，对于为什么会出现这种现象，也有一些不同的解释。正如你刚刚读到的，我更喜欢 “期望 “的解释，但其他人建议：显眼性，刺激物可能是不显眼的，因此不被视为重要。心理负荷，我们可能忙于关注另一项任务而没有注意到一个刺激，或者说这确实是注意力位置的解释；正如我们将在后面看到的。在现实中，我希望每一种解释都有一些组合在起作用，但问题是，这种现象本身并不是我们所期望的，而且我们并不确切知道它为什么或如何发生。当你阅读更多的内容，当你开始在用户体验领域工作时，请记住这种不确定性的程度。</p><h2 id="visual-channel"><a href="#visual-channel" class="headerlink" title="visual channel"></a>visual channel</h2><p>视觉交互设计是由界面上的元素或细节的安排决定的，这些元素或细节可以通过现有的资源促进或阻碍用户。这是因为界面内到达我们眼睛的信息量远远大于我们的大脑所能处理的信息量，正是由于这个原因，视觉通道，也就是视觉注意力是好设计的关键。</p><p>通过对视觉通道的理解，我们可以看到与视觉设计相关的颗粒度的水平。这种颗粒度使我们能够通过分割成更小的、更容易管理的片段或组件来理解一个大的视觉效果图。我们的注意力根据我们的视觉注意力与这些组件的关系在这些组件之间移动，正是这种关于视觉通道如何运作的知识，作为设计的最佳实践，使设计师能够建立起用户觉得有趣和容易使用的界面。设计师为观察者建立的视觉叙事是由每个视觉组件的视觉外观（以及，因此，吸引力）暗中创造的。观察者的注意力，或者说我们将看到的注意力的位置，使得这种视觉叙事能够被讲述。</p><h4 id="Selective-visual-attention"><a href="#Selective-visual-attention" class="headerlink" title="Selective visual attention"></a>Selective visual attention</h4><p>由大脑中的意识和潜意识过程组成，用来快速有效地寻找和关注相关信息。有两个一般的视觉注意过程，即自下而上和自上而下，它们决定了人类下一步将注意力放在哪里。自下而上的视觉注意模型表明，低层次的突出特征，如对比度、大小、形状、颜色和亮度与视觉兴趣有很大的关联。例如，一个红苹果（营养的来源）在视觉上比它周围的绿叶更突出，因此也更有吸引力。另一方面，自上而下的模型解释了由语义或关于环境的知识驱动的视觉搜索：例如，当被要求描述图片中一个人的情绪时，人们会自动看向这个人的脸。</p><h4 id="Bottom-up-processing"><a href="#Bottom-up-processing" class="headerlink" title="Bottom-up processing"></a>Bottom-up processing</h4><p>自下而上的处理方式使人们能够迅速地发现一些项目，如粗体字和图片，这有助于解释界面的组织方式。它还能帮助人们将信息分为 “部分”，如文本块、标题和菜单。</p><h4 id="Top-down-processing"><a href="#Top-down-processing" class="headerlink" title="Top-down processing"></a>Top-down processing</h4><p>自上而下的处理方法使人们能够利用已有的知识和启发式方法来解释信息。例如，人们可能会在界面的顶部和两侧寻找菜单，而在中间寻找主要的界面组件。</p><h4 id="gaze-hotspots"><a href="#gaze-hotspots" class="headerlink" title="gaze hotspots"></a>gaze hotspots</h4><p>从眼动研究中可以看出，用户的注意力会依次集中在界面的不同部分，计算机图形学中已经成功地采用了计算模型，将图像分割成用户最可能关注的区域。这些模型是基于对人类视觉行为的了解和对有关图像的理解。事实上，有一些研究记录了用户在特定的交互任务中的眼球运动，以找出界面设计中那些被访问的特征，其顺序和 “凝视热点 “被发现的地方。在这些数据中，我们可以看到界面组件和眼睛注视之间的关联，但不是 “用户看了视觉上最明显的界面特征 “这样简单。事实上，有时候，在一个吸引人注意的特征（如图片）旁边的大字体也会被固定下来。然而，我们可以推断出，比如说，一些文字中的信息本身可能并不能吸引用户的注意力，但最好是附近有一些特征可以吸引用户的注意力。这一观点得到了其他研究的支持，这些研究试图建立界面设计指标来预测一个界面在视觉上是否复杂。这些研究与界面设计的复杂性有关，解释了交互被感知的方式取决于界面本身的设计方式和所使用的组件。</p><h2 id="Auditory-channel"><a href="#Auditory-channel" class="headerlink" title="Auditory channel"></a>Auditory channel</h2><p>听觉渠道是信息输入的第二大渠道，与视觉渠道高度相关，然而，听觉输入有一些经常被忽视的优势。例如，在某些情况下，对听觉刺激的反应要比对视觉刺激的反应快。其次，使用听觉信息可以在一定程度上减少屏幕上的视觉信息量。在某种程度上，这减少了来自界面组件和目前正在进行的交互方面的可能的信息过载。视觉需求的减少意味着注意力可以被释放到最好的视觉处理的刺激上，也意味着听觉刺激可以被定制到最适合的互动部分。</p><h4 id="drawback-of-auditory-channel-and-solution"><a href="#drawback-of-auditory-channel-and-solution" class="headerlink" title="drawback of auditory channel and solution"></a>drawback of auditory channel and solution</h4><p>事实上，与标准的界面组件相比，听觉通道往往使用不足。在某些情况下，这是由于需要在环境中不存在噪音污染的缘故。我们可以看到，在同一个大环境中，一致的声音或断断续续的声音往往会让计算机用户感到沮丧和分心；而对于可以专门针对主要用户的视觉刺激来说，情况并非如此。最后，在某些情况下最重要的是，声音可以移动用户的注意力，并将其集中到一个特定的空间位置。由于人类听觉处理系统的性质，研究发现，使用类似于白噪声的不同频率在吸引注意力方面是最有效的。这是因为人类的语言和交流是使用多种频率进行的，而单一频率的转换，如警报器或可听音调，不会使人感到不安，但更难在空间上定位。</p><h4 id="Earcons"><a href="#Earcons" class="headerlink" title="Earcons"></a>Earcons</h4><p>非语音听觉输入的一个更有趣的方面是听觉图标和 “Earcons”。目前，许多系统都有某种听觉图标，例如，从特定目录中删除文件时，往往伴随着用来表达删除的声音，如纸张被揉碎。耳朵图标稍微复杂一些，因为它们涉及到非语言音频信息的传输，向用户提供有关某种计算机对象、操作或互动的信息。与听觉图标相比，Earcons使用的是更传统的音乐方法，通常是由单独的短节奏序列构成，并以不同的方式组合。在这种情况下，听觉部分必须学习，因为Earcon和它所代表的内容之间没有直观的联系。</p><h2 id="Somatic"><a href="#Somatic" class="headerlink" title="Somatic"></a>Somatic</h2><p>体感一词涵盖了在环境中体验到的所有类型的物理接触，无论是感受表面的纹理还是力的冲击。触觉描述了用户在接触物体或其他用户时如何体验力或皮肤反馈。触觉交互可以作为提供输入和接收输出的手段，并被定义为 “个人通过使用其身体对其身体附近的世界的感受性”。触觉是由由覆盖在皮肤上的受体和大脑中的处理中心组成的各种感觉系统所产生的触觉刺激所驱动的，以产生触觉和温度等感觉模式。当感觉神经元被特定的刺激所触发时，神经元会传递到大脑中的一个区域，使经过处理的刺激在正确的位置被感觉到。因此，可以看出，使用触觉通道进行控制和反馈，特别是作为其他感官输入或输出的辅助手段，是很重要的。事实上，触觉和触觉的优势在于使互动看起来更真实，这也是触觉设备在虚拟和沉浸式环境中大量使用的原因。</p><h2 id="The-Olfactory-System"><a href="#The-Olfactory-System" class="headerlink" title="The Olfactory System"></a>The Olfactory System</h2><p>嗅觉系统使我们能够感觉到气味。因此，对于许多研究用户体验的人来说，可能会感到惊讶，因为已经有一些工作在研究使用气味作为一种与交互直接相关的感官输入形式（特别是来自[Brewster等人，2006]）。虽然这是一个研究不足的领域，但某些类型的界面可以使用气味来传达一个额外的支持成分，而不是一般的、更好理解的声音和视觉的刺激。嗅觉的主要好处之一是它与记忆有着密切的联系，在这种情况下，嗅觉可以被用来帮助用户找到他们已经去过的地点，或者在互动环境中认出他们已经去过的地点。事实上，似乎嗅觉和味觉[Narumi等人，2011]在与图像识别相关联时特别有效，并且可以以抽象的气味，或者代表特定线索的气味的形式存在。然而，作为一个UX’er，气味不太可能在你设计的系统中被大量使用，尽管如果你在用户忘记以前学过的交互方面有特别的问题时，记住气味可能是有用的。</p><h2 id="Explicit-and-Implicit-Communication"><a href="#Explicit-and-Implicit-Communication" class="headerlink" title="Explicit and Implicit Communication"></a>Explicit and Implicit Communication</h2><p>信息可以通过多种不同的方式传输，这些方式可以是隐式的（隐蔽的）或显式的（公开的）。在这种情况下，让我们将信息传输称为通信；将信息传达给用户，然后通过输入和控制机制将用户要求传回计算机。明确的交流通常被很好地理解，并且集中在文本和图像（或声音）的视觉或听觉传输以供用户消费。然而，隐式通信有点难以定义。在这种情况下，我指的是在某些方面是无形的视觉或听觉用户体验的那些方面。我的意思是诸如审美或情感反应 [Pelachaud, 2012] 等方面对交流的各个方面。</p><h4 id="explicit-commuication"><a href="#explicit-commuication" class="headerlink" title="explicit commuication"></a>explicit commuication</h4><p>沟通和复杂度密切相关，复杂度直接影响到用户和界面或系统之间沟通的便利性。沟通主要是通过界面的视觉布局和用户必须阅读的文字标签来进行的，以了解与他们的互动沟通。人们通过使用生硬的眼球运动（称为’Saccades’）来阅读文本，然后停止并固定在一个关键词上大约250毫秒。这些固定的动作各不相同，在更复杂的文本中持续的时间更长，而且集中在向前的固定上，当阅读变得更加困难时，倒退（向后）的固定只发生在10-15%的时间。人们在快速阅读时，通过扫描寻找适当的信息，往往固定的频率较低，时间较短。然而，他们只能记住所读信息的要点；而不能对所遇到的信息进行全面的论述（见图：视觉化文字）。这意味着，对于用户来说，在快速扫描一个互动功能时，对界面的全面描述并没有被用于用户的决策过程中。事实上，在浏览大型互动资源时，认知过载是一个关键问题。如果互动是非线性的，并且可能会意外地切换上下文，那么这种过载就会增加。通过摘要进行预览是提高用户在复杂界面中的认知的关键，但是复杂的提示也会使读者的不相干的信息过载。</p><h4 id="implicit-communication"><a href="#implicit-communication" class="headerlink" title="implicit communication"></a>implicit communication</h4><p>美学通常被定义为对美丽或愉悦的欣赏，但这个术语仍有争议。视觉美学是 “关于如何通过感官认识事物的科学”，指的是用户的感知和认知。具体来说，’美观的’界面通常被用来描述那些被用户认为是干净、清晰、有组织、漂亮和有趣的界面。这些术语只是描述美学的众多不同术语中的一个例子，这些术语在交互设计中普遍使用。人机交互工作大多强调性能标准，如学习时间、错误率和完成任务的时间，而较少关注美学。然而，用户体验工作试图扩大这种狭隘的（”还原论”）体验观，试图理解美学和情感如何影响观看者的感知–但是界面的美学表现和用户的交互之间的关系仍然没有被很好的理解。</p><p>最新的科学发现表明，情绪在决策、感知、学习等方面起着至关重要的作用–也就是说，它们影响着理性思维的机制。不仅是太多，而且太少的情绪都会损害决策[Picard, 1997]。这现在被称为 “情感计算”，其中生物识别仪器，如皮肤电泳反应（GSR），凝视分析和心率监测被用来通过用户的生理变化来确定其情感状态。此外，情感计算还寻求改变这些状态的方法，或者根据这些状态表现出对技术的控制。</p><h2 id="input-and-output"><a href="#input-and-output" class="headerlink" title="input and output"></a>input and output</h2><p>在讨论 UX 时，最后一个难题是输入信息以供计算机使用的能力。通常，这通常是通过使用与键盘和鼠标结合使用的 GUI 来完成的。然而，这还不是全部，确实有很多种入口设备可用于信息输入、选择和目标获取[Brand，1988]。在某些情况下，在其他凝视和眨眼检测中使用了专业设备，例如头部操作的鼠标，但是，在大多数情况下，鼠标和键盘将是事实上的组合。但是，作为 UX 工程师，您还应该了解可用的不同类型的设备以及它们之间的关系。通过这种方式，您将能够在指定非标准系统时做出准确和合适的选择。</p><h4 id="The-Written-word"><a href="#The-Written-word" class="headerlink" title="The Written word"></a>The Written word</h4><p>书面文字，草书，长期以来被视为将文本输入计算机系统的最自然方式。 因为它依赖于使用已经学过的技能。</p><h4 id="Pointing-Devices"><a href="#Pointing-Devices" class="headerlink" title="Pointing Devices"></a>Pointing Devices</h4><p>在大多数情况下，用于绘图和目标获取的指针设备由无处不在的鼠标处理。</p><h4 id="Text-entry"><a href="#Text-entry" class="headerlink" title="Text entry"></a>Text entry</h4><p>通过键盘输入文本是标准计算机系统的主要数据输入方式。</p><h4 id="Haptic-Interaction"><a href="#Haptic-Interaction" class="headerlink" title="Haptic Interaction"></a>Haptic Interaction</h4><p>触觉交互并没有在沉浸式或协作环境领域之外广泛使用。为了与虚拟世界进行触觉交互，</p><h4 id="Gesture-Recognition"><a href="#Gesture-Recognition" class="headerlink" title="Gesture Recognition"></a>Gesture Recognition</h4><p>手势识别最初被视为主要用于研究和学术调查的领域。然而，最近有两种产品改变了这种看法。其中第一个是流行的游戏机 Nintendo Wii，它使用游戏控制器作为手持指点设备，并检测三个维度的运动</p><h2 id="SUM-of-Week-3"><a href="#SUM-of-Week-3" class="headerlink" title="SUM of Week 3"></a>SUM of Week 3</h2><p>了解我们如何使用我们的感官：视觉（视觉通道）、听觉（听觉通道）、嗅觉（嗅觉通道）和触摸（触觉通道）使我们能够了解如何通过界面传达有关系统状态的信息。 对心灵自然过程的了解：注意力、记忆和学习、探索和导航、情感交流和复杂性以及美学，有助于理解我们传输的信息如何更好地适应用户的心理过程。 最后，了解输入和控制是如何制定的，可以让我们从多种输入设备中进行选择，这些输入设备可用于信息输入、选择和目标获取。 但是，我们必须记住，有许多不同类型的人，这些人有许多不同类型的感官或身体要求，在施工过程的各个阶段都必须考虑到这些要求。</p><h2 id="Digital-Phenotyping"><a href="#Digital-Phenotyping" class="headerlink" title="Digital Phenotyping"></a>Digital Phenotyping</h2><p>数字表型(Digital Phenotyping)是指 “利用个人数字设备（尤其是智能手机）的数据对个人层面的人类表型进行现场量化。</p><p>这些数据可以分为两个子组，即主动数据和被动数据，前者是指需要用户主动输入才能生成的数据，而被动数据，如传感器数据和手机使用模式，是在不需要用户主动参与的情况下收集的。</p><h2 id="User-Centred-Design"><a href="#User-Centred-Design" class="headerlink" title="User Centred Design"></a>User Centred Design</h2><p>在现实中，这意味着在开发任何软件之前都有一个很长的用户咨询期，这样设计者就可以更准确的表达这些用户的要求–”什么”。可以说，有许多不同的子风格，我现在称之为以用户为中心的设计（UCD），本节中列出的文本和标准是很好的第一步[9241-210:2010, 2010]。然而，有许多首要的问题和原则适合于它们，并且在某些方面可以不严格参照特定的UCD方法。作为一个训练有素的UX’er，你不应该死记硬背任何特定的方法，而是应该了解每一种方法的长处和短处，并在你目前的设计过程中选择最适合你具体要求的工具4。</p><h4 id="UCD-user-centred-design"><a href="#UCD-user-centred-design" class="headerlink" title="UCD (user centred design)"></a>UCD (user centred design)</h4><p>UCD代表了一套技术，使参与者能够在评估和设计过程中获得某种形式的所有权。人们通常认为，这些参与者在某种程度上对所调查的系统和过程有一定的了解，因此对整个组织所需要的系统和界面有一定的洞察力。UCD方法与 “大声思考 “协议密切相关，但不是完全专注于评估，而是鼓励用户根据他们对系统或界面的了解，扩大他们的观点，提出改进建议。事实上，我们鼓励参与者对提议的系统进行批评，以达到真正的要求。这意味着–在某些情况下–在用户体验设计开始之前就已经创建了一个系统设计，以便参与者有一个起点。</p><h1 id="Gathering"><a href="#Gathering" class="headerlink" title="Gathering"></a>Gathering</h1><h2 id="Digital-Phenotyping-1"><a href="#Digital-Phenotyping-1" class="headerlink" title="Digital Phenotyping"></a>Digital Phenotyping</h2><p>数字表型是指 “利用个人数字设备（尤其是智能手机）的数据，对个人层面的人类表型进行现场量化。<br>这些数据可以分为两个子组，即主动数据和被动数据，前者是指需要用户主动输入才能生成的数据，而被动数据，如传感器数据和手机使用模式，是在不需要用户主动参与的情况下收集的。</p><h2 id="User-Centred-Design-（UCD）"><a href="#User-Centred-Design-（UCD）" class="headerlink" title="User Centred Design （UCD）"></a>User Centred Design （UCD）</h2><h4 id="不是正确，而是用户想要。"><a href="#不是正确，而是用户想要。" class="headerlink" title="不是正确，而是用户想要。"></a>不是正确，而是用户想要。</h4><p>在现实中，这意味着在开发任何软件之前都有一个很长的用户咨询期，这样设计者就可以更准确的表达这些用户的要求–”什么”。可以说，有许多不同的子风格，</p><p>用户中心设计过程不是一个快速的解决方案，传统工程方法和UCD的主要区别在于，用户在UCD中的参与度要高得多，而且周期也不那么僵硬。</p><h2 id="What-information-do-we-need"><a href="#What-information-do-we-need" class="headerlink" title="What information do we need"></a>What information do we need</h2><p>elicitation, specification, and validation<br>即征询、规范和验证。</p><p> post-it note 是最有效的，在用户反馈过程中。</p><h2 id="如何收集数据？"><a href="#如何收集数据？" class="headerlink" title="如何收集数据？"></a>如何收集数据？</h2><p> The most used methods for requirements capture are participant observation, interviewing, archival and unobtrusive methods. 最常用的需求捕捉方法是参与观察、访谈、档案和非侵入式方法。我建议，这些方法主要用于建立一个在程度和范围上既深入又狭窄的理解体系。然后，这些知识可以被用来帮助指导我们的发展。如果综合使用各种方法，你可以期待更好的结果–然而，在现实中，你大多会受到时间的限制。</p><h2 id="six-months"><a href="#six-months" class="headerlink" title="six months"></a>six months</h2><h3 id="Participant-observation"><a href="#Participant-observation" class="headerlink" title="Participant observation"></a>Participant observation</h3><p>是通过参与被研究的团体或组织的日常生活来收集数据的过程。不要太规范，别太正式，让目标有偏差。你的取样必须是有代表性的。样本和取样程序要公开。抽样策略包括概率抽样和非概率抽样。</p><h3 id="implicit-information-captured"><a href="#implicit-information-captured" class="headerlink" title="implicit information captured"></a>implicit information captured</h3><p>如果一个用户想从图书馆借一本书，那么任务分析的一部分可能是需要一张新的借阅证，而子任务可能是需要在借阅证上输入当前的日期，以及借阅者的姓名和书的目录号。在这种情况下，我们可以看到，任何自动化系统都必须为创建一个伪结账代码做准备，而且在这个伪结账卡中必须有可用的字段来捕捉日期、姓名和目录号。</p><h2 id="总结-elicitation-and-analysis-phase"><a href="#总结-elicitation-and-analysis-phase" class="headerlink" title="总结 (elicitation and analysis phase )"></a>总结 (elicitation and analysis phase )</h2><p>一旦征询和分析阶段完成（ elicitation and analysis phase ），也许是时候把这些知识转移到对用户更正式的描述中去了，这些描述可以被软件工程师理解，因此可以用来开发系统的面向用户的方面。在这种情况下，我们可以看到需求征询与知识获取并无不同。在知识获取和需求激发领域内的主要问题是，分析员很难从用户那里获取知识。这往往会导致这两个领域陷入所谓的分析瘫痪。这种现象通常表现为项目规划、需求收集、程序设计和数据建模的漫长阶段，这些步骤几乎没有创造任何额外价值。当延伸到一个很长的时间框架时，这种过程往往会强调软件开发的组织性和官僚性，而减弱其功能性、价值创造和面向人的部分</p><h1 id="UX-development"><a href="#UX-development" class="headerlink" title="UX development"></a>UX development</h1><p>用户体验工程师主要负责在开发开始前与用户进行互动。在需求收集阶段和开发完成后的测试和评估阶段也是如此。</p><ul><li><p>Methodology Agile Development (if we know the end point) &#x2F; Cowboy Coding (if we don’t know the ned point) 需要谨慎的导航和沟通</p></li><li><p>Separate Concerns: Microservices or REST (Service lead)</p></li><li><p>Interfaces: Use a toolkit and skin-it. Don’t create your own!</p></li></ul><h2 id="Development-Methodologies-and-Lifecycles"><a href="#Development-Methodologies-and-Lifecycles" class="headerlink" title="Development Methodologies and Lifecycles"></a>Development Methodologies and Lifecycles</h2><h4 id="Waterfall"><a href="#Waterfall" class="headerlink" title="Waterfall"></a>Waterfall</h4><p>瀑布模型的世界观是，开发生命周期的每一个环节都是按照严格的、僵硬的顺序进行的。<br>SSADM（Structured Systems Analysis and Design Method）</p><h4 id="Spiral"><a href="#Spiral" class="headerlink" title="Spiral"></a>Spiral</h4><p>螺旋模型与瀑布模型不同，它将每项任务分割成一些任务，这些任务是反复进行的。</p><h4 id="Iterative"><a href="#Iterative" class="headerlink" title="Iterative"></a>Iterative</h4><p>这是因为它认为软件开发是一个循环过程，包括需求、分析和设计、实现、测试、评估，然后为下一次迭代做计划。这意味着，它将软件工程的生命周期看作是迭代和循环的。</p><h1 id="Accessibility"><a href="#Accessibility" class="headerlink" title="Accessibility"></a>Accessibility</h1><p>方便残障人士。</p><h2 id="Barriers-to-Effectual-Use"><a href="#Barriers-to-Effectual-Use" class="headerlink" title="Barriers to Effectual Use"></a>Barriers to Effectual Use</h2><ul><li>Visual: Many Many challenges in providing efficient &#x2F;<br>effective use.</li><li>Cognitive: Many types &#x2F; a large spectrum - under<br>researched.</li><li>Hearing: First language is Sign.</li><li>Physical: Many types - with input solutions. &#96;Locked<br>in’ - brain interfaces?</li><li>Combinatorial: Different but low level impairments<br>experienced in combination.</li><li>Developing Regions: 发展中地区的计算机使用目前的特点是操作方式受到限制。速度慢，计算能力低，带宽减少，</li></ul><h2 id="Barries-to-Dffectural-Use"><a href="#Barries-to-Dffectural-Use" class="headerlink" title="Barries to Dffectural Use"></a>Barries to Dffectural Use</h2><p>● i18n: Language and understanding. (国际化)国际化是指对产品、应用程序或界面的设计和开发，使其易于为不同文化、地区或语言的目标受众进行本地化。</p><p>文化也可以成为无障碍的障碍，但往往根本没有得到解决。例如，在90年代中期，万维网的一些用户不愿意选择超链接。这是因为这些链接是蓝色的，而蓝色被视为不吉利的颜色</p><p>● Literacy: Education and misconception.</p><p>● Situational: Mobile et al.</p><p>● Developing Regions: Unconventional use.</p><p>● Low Income: Device Independence.</p><h2 id="What-is-Accessibility"><a href="#What-is-Accessibility" class="headerlink" title="What is Accessibility"></a>What is Accessibility</h2><p>可访问性旨在帮助残疾人感知、理解、浏览和与计算机系统或界面互动</p><h2 id="What-is-Potted-Principles-POUR"><a href="#What-is-Potted-Principles-POUR" class="headerlink" title="What is Potted Principles (POUR)"></a>What is Potted Principles (POUR)</h2><p>在我看来，对于有效和可访问的交互来说，最重要的考虑因素是开放性、可感知性、可操作性、可理解性和灵活性。</p><h4 id="Perceivable"><a href="#Perceivable" class="headerlink" title="Perceivable"></a>Perceivable</h4><h4 id="Operable"><a href="#Operable" class="headerlink" title="Operable"></a>Operable</h4><h4 id="Understandable"><a href="#Understandable" class="headerlink" title="Understandable"></a>Understandable</h4><h4 id="Rubust"><a href="#Rubust" class="headerlink" title="Rubust"></a>Rubust</h4><p>问任何一个消息灵通的开发者对无障碍性有多重要进行评价，我希望大多数人都能把它列为高等级。问他们为什么，我希望大多数人会谈论残疾用户、利他主义和法律。少数开明的人可能会谈及商业案例，或者扩展到使他们的软件具有无障碍性的许多技术优势。</p><h1 id="userability"><a href="#userability" class="headerlink" title="userability"></a>userability</h1><h1 id="Affective-Experience"><a href="#Affective-Experience" class="headerlink" title="Affective Experience"></a>Affective Experience</h1><p>为集体情感体验而设计的问题就在这里，它当然不容易适用于所有用户。事实上，当我们处理诸如可用性或可及性等容易量化的方面时，我们会得到非常一致的结果，而在情感计算方面，情况却不一定如此。我们看到更多的个人化的结果，更多的离群值，以及我们收集的数据中更多的差异。在这种情况下，你可能会想，如果情感的使用无法量化，为什么它如此重要。有三个原因，首先，有吸引力的东西工作得更好，它们的吸引力产生积极的情绪，使心理过程更有创造性，对小的困难或缺点更宽容。其次，情感上的依恋对我们人类来说是很自然的，而且我敢说，最初比有效的体验要强大得多（经常被引用的 “功能服从于形式 “仍然适用，因为赞同这种观点的人把功能看作是一种美学品质）；最后，仅仅因为某些东西不容易被量化，并不意味着我们不能尝试去理解它，或者它对我们在用户体验领域没有任何用途或意义。</p><p>在这一章中，我不建议采用以用户为中心的方法来设计情感化的用户体验。这应该是一个个人的愿景，作为UX’er，你的工作是根据客户的要求选择最好的人去实现这个愿景；这最好是单独完成，而不需要一个委员会。</p><ol><li>Beauty</li><li>Visual Complexity 视觉复杂性主要由物体的数量、杂乱性、开放性、对称性、组织性和颜色的多样性等知觉维度来表示。</li><li>Visual Aesthetics and Design</li></ol><h3 id="Visual-clarity-and-richness-影响最大"><a href="#Visual-clarity-and-richness-影响最大" class="headerlink" title="Visual clarity and richness 影响最大"></a>Visual clarity and richness 影响最大</h3><h3 id="Visual-Attention"><a href="#Visual-Attention" class="headerlink" title="Visual Attention"></a>Visual Attention</h3><p>有两个一般的视觉注意过程，即自下而上和自上而下，它们决定了人类下一步将注意力放在哪里。</p><h2 id="Potted-Principles-of-Affective-User-Experience-用户体验的情感准则"><a href="#Potted-Principles-of-Affective-User-Experience-用户体验的情感准则" class="headerlink" title="Potted Principles of Affective User Experience(用户体验的情感准则)"></a>Potted Principles of Affective User Experience(用户体验的情感准则)</h2><p>理解用户的情感体验，并建立捕捉它的系统是复杂的，容易出错的，而且容易被误解。情感是关于主观性的，而这种主观性是在时间上、文化上和心理上发生的。</p><h2 id="personality"><a href="#personality" class="headerlink" title="personality"></a>personality</h2><h2 id="如果你的界面有个性，那么美学、质量、流程、满意度或成就感的好坏就不重要了；我甚至可能会说，可用性也不重要。个性胜过其他一切，因为它是唯一能让用户在情感上有价值地参与软件工程作品的因素。"><a href="#如果你的界面有个性，那么美学、质量、流程、满意度或成就感的好坏就不重要了；我甚至可能会说，可用性也不重要。个性胜过其他一切，因为它是唯一能让用户在情感上有价值地参与软件工程作品的因素。" class="headerlink" title="如果你的界面有个性，那么美学、质量、流程、满意度或成就感的好坏就不重要了；我甚至可能会说，可用性也不重要。个性胜过其他一切，因为它是唯一能让用户在情感上有价值地参与软件工程作品的因素。"></a>如果你的界面有个性，那么美学、质量、流程、满意度或成就感的好坏就不重要了；我甚至可能会说，可用性也不重要。个性胜过其他一切，因为它是唯一能让用户在情感上有价值地参与软件工程作品的因素。</h2><p>最后，尽管个性是王道，但讨人喜欢的、有吸引力的网站效果更好，更容易使用，因为它们反映了大脑的生物起源。令人愉悦的互动和有吸引力的界面会产生积极的情绪，使人的心理过程更有创造力，对界面设计或互动体验中的小困难和小错误更宽容。简而言之，吸引力会影响人类的行为，因此它是设计和实现用户体验的一个重要组成部分。</p><h1 id="Engagement-Digital-Umami"><a href="#Engagement-Digital-Umami" class="headerlink" title="Engagement (Digital Umami)"></a>Engagement (Digital Umami)</h1><p>游戏, 利用人类参与游戏的心理倾向性。购物等。。</p><p>它把游戏–一种神秘的、神奇的、强大的媒介，吸引了无数人的注意力</p><h2 id="Group-Dynamics"><a href="#Group-Dynamics" class="headerlink" title="Group Dynamics"></a>Group Dynamics</h2><p>在我们与应用程序的互动中加入人类互动中经常发现的能量，将推动我们获得更好的用户体验，因为它们更接近我们对人与人之间互动的期望。</p><p>，人类是有社会动机的，并且生活在群体中，在协作的情况下与人有很强的联系。等级制度往往作为这些群体社会互动的一部分形成，因此在互动环境中，我们需要决定我们是否觉得计算机是用户的附属品。</p><h2 id="Funology"><a href="#Funology" class="headerlink" title="Funology"></a>Funology</h2><h2 id="Gamification"><a href="#Gamification" class="headerlink" title="Gamification"></a>Gamification</h2><p>插图、漫画元素、比生活更真实的3D渲染，以及已知的徽章内容</p><p>最后，我们来到了自下而上的游戏化，其中游戏元素与软件系统（其互动、界面和精神）本身是不可分割的。说实话，我还没有看到真正好的例子，这既是游戏又是非游戏（如果这有任何意义的话）</p><p>完成任务的难度不断增加。</p><h2 id="CON"><a href="#CON" class="headerlink" title="CON"></a>CON</h2><p>增加游戏化、趣味性和协作性的团体元素等吸引人的方面可能带来的好处仍然是非常暂定和传闻的。然而，这些元素对整个用户体验的好处似乎是显而易见的，即使有时很难将这些参与性原则转化为实际的界面和交互。虽然我们可以看到，在界面上添加有趣的元素可能是有用的，但在某种程度上，游戏化还没有定论。事实上，你可能会注意到，我并没有触及 “地面游戏化 “这个更广泛的话题，即所有的互动都像游戏一样，特别是因为它的应用仍然存在争议65。虽然有很多关于这种互动的讨论，也有一两个（主要是网站）发生的例子，但在大多数情况下，我认为从头开始的游戏化等于游戏，而不等于游戏化的非游戏。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>我的kpi</title>
    <link href="/2023/01/08/%E6%88%91%E7%9A%84kpi/"/>
    <url>/2023/01/08/%E6%88%91%E7%9A%84kpi/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="d46957dee587476b9438a4d926adaec16dd8d943650cd6332767ee31428dcebb">3a0bc4641647d2340c9f1dc98f043c380c8c53990d7de4f8cd160186461d0becff2c3c5780f6eb51f7722a5674c32d691f820ba2aa4aed05a0f135c14520bde9c1432a5bdbec9674e96dc34e32e692ef3692ad5f714452c83c053a1adaee5ca3868304614b098f451e6b952aa1366693fbdcdb230dc0f662530a61d63e8e5f07e0670a7d680b9e2395a499f02c0cd19f3f7cbb48d57b0d37086ce40ef7cedfdacde55bd7671764c7147dfe4205656cd2febeb285f3839e84a1d93aa59655a9917243b94857c567bfd88935d7d9d01c80e323b60ffa1a7665d655b9bc6cab09b06359cdafc0d3ad21c5d0b46da44db378815556a8eb9150152b0afa175f58ae746170f350ee03dcea2f7d81975fa8102b4f1a0322630b959491e697ad79ffd43866cc7a1ea2a94a055fa4d2140dd780f649414e379045fc98f2a1d6b18f73a194fbedcb21cb42045712caa5a3d4eb58a2bc5b9dafd1084374292c18b4504e04f37ecb3d427db30f053e9b5aaa59f707813a1273e6e54908411c2f69f029fec908f3222e0e9500b84455503b8fa7fd9e87be88c118baad5e122ce2dc5aef023c7c787bc1132e4b594299756acb093588a8fd0839fb8660a7e929daf3e9a3c90b2bbe6904215d507e8f5da6df5573cbae1e6b190302b726f24bf5382c2236b2967cb2ca7a6806ffcdcedd59e4496c4940c173ad96e9bc86583561faff6c39542a85ab5fcee5a8859052b57cb5ec9e2ba5440951fdcd11f936e701995cd376649f9c2de6409c8f51a147b91cb363c0d7ab92e88e8f5ed4596354c1893e3941c388a5007900575c1bc77a8f09ec88d3f2ef1ff7840964095da6b3d11f7744399c2b6ad36cefaa1e5ee4b79aeb0f1bd63686bd0a3ce522764ea2401321b6b071da08f55cdbec980f5be0187b78038e3cc04c1ccc449245d57dcccff6fd3a1a6585e482d31d75966f13dea74655263d93519bbd273c150240aa161590ff6e50fdc9cc5ee6c8cf99103acf1b0cff53084c16c0adedd47ffa851063357c4f31325db0e27d1ba4c88e14aeb9ae49b01d43afb2fa7316972a0f92ab515fd509f1b45562eee0e9336af27a44fd38d68560bcfca89f54732d51f4a2c9ca5ca3fa7920bbf50ee2ef3d2441b217b4756111cc42996fdc1966ab43f5f0f3cd9305f9c369906e254bb31ab02b55ed8d7994d4243c015962215eb676e855c4ccdf01da1250adb084da037b850ec49f894f3a508558db7ddaa305243494294e1c88739376c917bcb4e806f4c711481c4cb262f55e363f93f109434f94a2a357ad2704bc2212bbdb4adf70eeb068cce489c6372ec9fcf64101a064bc12b45200de5f9c421a5aafdef4262fee3574e394bb3fba5ec0559597e77f6d62aff7334f4fa06bf18a03f1f3ee5644890e2501737215aa3c46b43d9183c1f6ff1ea863b022a52e414f2758d9b271cd3333710b9a04bf606bfb60da4c5fcc48ca29e1d58e6e48eaa27816f7ad67116fbf3e59f7e504254ee256dd151b7d353f327c57054bfea38ed0126beac6b37434dcfa811beb2acf99c4d11991aabae4dcef4b3ea6195e0efa2fdf80525646257cbe7cdfc627ddc4078098b477f72494863d81628dfdf50f2fb2227ea058161ca2a8724fc8e8fede50bf779912ad8ff2229e3069495500a3cd230d94cf3a212cd905e4d4ae1017307749eec6e2fccfb553aeb8b791ad496b0a543391d2f4c71a3413691f8eae3468eec4e3a72f1ad86d9543c6afff0a81b1aa7e094d60355d9607496424c0fe88a2e25f44213f825c426937f9034f221ef5248d4eecd751ac86a9b10baad1f7be9fe5a7f4ac49cf8b93c351553000aef24b458889befa9e56a2a3b893a41ce195d7410d55c21e9a2547903122f5c50a87c8a4db57b0768a886defa9ed5e9cba1e1a7e4823cbe61a8340259693a6e5c669530d55c44922e9697b37e5f4603621ad2f9b16b1fefaa2461d834caccc4ce7653231313b60e59dba8d34c7ee6df947076df158f62a29f69555ec71aa428e8cdc0679e6a21e39230e4b1b9324572e4c7e50c261995c9d3db5631f6d167e8102738a11cb0e29d9e10eee593706b6ab0d5a54aec6af42f0188b1d38538c02d279db5c908664ff8088ac5920a73bd19f59953960625cfa50d584b7d06e4161fc073a3e4d04132fec9b6f3dfef627322f53eb0b94d1dc6c084623fa73f65b61044ca388c9d91328606c42110cb57ca9c26744561dea1ef5cdfd8fdf3709ec5f525ce5a12b702a90ecd7e6c2446474b6cba8e5982ebdaeb20aa95dd33af90bec0bbaff5d6467c9fbefbcd18facb8bc0af51db1bc72b166002793cb4ecbd5856dd3eff79514cbb33e9976931cac3699c8e2ead4ead1fe9eb14a585804e312d56b320bd224ded707a363b830bcbdf4ef45552dc0ae1f11bcf6ef43266e7d51b0b7f556ebc914924b0b1f1ef5ec6711358148e8c42f4ce84decfe7fbe9198ec2752c555d49a26b70d0c7b5b971dc810b6a077dcff87beecb3da661d229ce70707be17dbb21953873a17ffed841156e3866b33a58b8e452d8eef2a57d50bf520704cf85f21e747af2b3956383dfd7fd92f4c1ecd30795147049eb8b0255cab2f5eadeeb29d60b5391573f708b0321349f9640f08343822085cf651e292c7c5f4272d364e02c40505db774b118de0dadf23cd34004ce2b3641ef3182dadb5a98d60488ab0a176c44187457ba52d3f13d19cf9491c98bb77631f4e68ae5762fdcb98b70a69e78872bb7d6cdf6d8f7062f26a6bce1e6a616e975b22b56b67c002fd1fe66c58f1d9d0947a29e67afc3228533cc0766d80c37f5a2138d54136597b12bffa4387d53a500195444570b367c8a23824722350ada6a1a3dd7d115a11b514f4b3c89c7ff372f4defe8d87bc44dc6a61178a16e327845d9fe09133072faff84abcc37e4861f9fd99be48a8f53c4ce48046e932574fa598e6e071d2e177ada7ddbc091a24854cbcc9e2036bd1c6933e5551bd1920885e3a810d2d1550ca0a798ddc69efca25d1aad885e2816d9c3f0e5aef0543f551817bb75624bc4e86582b315c53270b3e788ceee5e72060fd45566c6800b28c69dd520de71099df87d41e83c6258cbca44a89c9f1c5f346c606e211ae371d7861753ed886622baee9ffe16af8871c665219db446534a34b2c9c71e5046cd8158ea6b0f1cd1e3391fa3dcd41cc3552b0141c5ff9e69eebaddc63db5c865603a89f4c43c1ed6a590ca39296947d4485421f08968f0202543bccd510881e95926a28f34a3a64d9fa7c065266b3cec0679254df4533758ccc63f7eded1c2e6cdf950de4286ccd0c61f3aeb11d8ae9ee974ec67def9024dae3d8ca0eaa63a5452ce8750f6bf8636d42d04a9a79a85d7fead11705108fe1331235e4aae1d72b51c67dfcb11a51b69fae897ad9b7776725ec5ff59ee347ea3e35b175aa800c55f4776996fd4984525c8781a859031b1b3b5dccf0e3f4df115fc168de64dc4e946a39b68ca2427310d6bce27d3c20afde286b08361fc0073e986d95ff39118f73b919a8caa9c6379d649a6758c6c82036d55a3e1e6f73dbbe56fbd9d5ddf58c5045cf4802ca089b815c54155a4dc805b7d5f7a9de94ee91c8fdd7eb6ff84af8b5cca180f03928360689d2dd0319808fb0d29b13001fb779952484a79645e28bc24d15bb68bb7d15234082cbd45ee3e91978b05daaba90fbe724059169c3d93b45e4728acf8126b264c42258a856bab1ebbfb388e76da7f0a96e22cf2181138f2adbbf96eaba802c3585cd7c9d7b029ce8c82b7edc788b0a63313cf078e9c091c3726f25a4395f288f9f0cfe37e59ff9783b3edb4a838a10292e3fd5180ca445283f69670fbcdd0822f97a801d465de7661763723a09a9ee1d91f415dab9a40c6e24532de9469371953c6f6ab8f9bbbc5536a3ca621231c046ab2cbd3cfed7a8be64232d4d869612ce6cfe03cbf0bcf1bcc7f7a48766075d592f98a732068841153cb1c20580eb54fdec18fdd8cf670fff1e6312d1261c5b4d3734983b0f5472b82fba0a1ade3ac722c7fea276595779e04d74dc00cef562d7a477397824d5d901b8534dd5c3f4d39fd796eb4eec24be9046057da89cf30d93b89d32680e4daba94c5032f889c8fc6a731ce2f53ed708963261656392a82fea524c013ea827ba8204e34c9b3f4f0719f64d83510ecaa3a430656d39e72febae1f61320df8a04520d0676fe51ad29b124faa0917f3626eff38d79329004810b61f14f47d1d0bdb9dab9d091a363b26341ddaa98f2b9213c6f47c8565393b240ab12024b1cf254de8a62ec85889c52ccb3b1b0cd13298b689d12de86142675d0b86286831fc1b828a071a9a3feedd7e07df433d526c27d07b0771b8927a33a226a9df6cbce60ef4f0c200ab06eb7f9b54d098c453111b3e9f7c12b85180583660dc85a9d66809d12c05cedade0544687c960f6b4554644fcfb5bb828ac8d9ea5b3d21bbafc80cacab1177b10d7d6a2b2e83564e41dc44d968f36b34557dc6c3bd243e5896263539675b94a3cb1c0b9e8417bdca002730cff70f741427263054d5205ce44bd0cea1763d31bcb3517c96d7633827bae9d3ff171fe31b4874792da1ab618525abfa627a704c56facacc22158794e06b2654d204bcec1c58ed4b69b15b8895f99ea52f2161968481e61a204d5569cc1ac75d8e1a0886f218553ed88bbee138494f11d98ad5ff977ee55bc9823f32bac1f2e7023a375d5d65b0c6e56ab5ad1c6692242e7e94d2791f87ce4baaa10a3f4981aa28789abcb2d4608c99ff3aa30774e058201d25f8dc81cb9bc1b73b600b7f0342ad3fe662ef2e8e71b7dc07045892b4494f0b8ac9d14c899d94e2975795cb8294553be4d25ec056ed76161a70d26fa38b047f2a83ea852bbd8e5404fbad24061cc4e3d7ac99d87ddea387e8edd30f503c420cb82d71267db2a2f6c88bd4a90aa1602ac2d47126f04f025569a22a419d565b98be990cfa4488a3f7ca7c87ec790d40c88cc2887b2be35eb45eb74dab6c441cb6008e1adf44424c133f817ba81e29853230106eaf9c80a0bea38d44bfb0c42b572deea7c01bba5c0d03b75331</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">password</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>algorithm_review</title>
    <link href="/2023/01/04/algorithm-review/"/>
    <url>/2023/01/04/algorithm-review/</url>
    
    <content type="html"><![CDATA[<h1 id="last-section"><a href="#last-section" class="headerlink" title="last section:"></a>last section:</h1><ul><li>Horn-SAT is PTime-complete</li><li>SAT is NPTime-complete. by Cook’s</li><li>st-Con is NLogSpace-complete.</li><li>The problem QBF is PSpace-complete.</li><li>LP-feasibility is in PTime. </li><li>ILP is NPTime-hard. BEC 3-SAT ≤ log m ILP.</li><li>HAMILTONIAN-circuit is NPTime-complete</li></ul><p>We can forget the ‘reasonably large’ non-deterministic space<br>classes.<br>LogSpace ⊆ NLogSpace ⊆ PTime ⊆ NPTime ⊆<br>PSpace ⊆ NPSpace ⊆ ExpTime ⊆ NExpTime ⊆<br>ExpSpace ⊆ NExpSpace ⊆ 2-ExpTime · · ·</p><p>• Savitch’s theorem simplifies this to:<br>LogSpace ⊆ NLogSpace ⊆ PTime ⊆ NPTime ⊆<br>PSpace ⊆ ExpTime ⊆ NExpTime ⊆<br>ExpSpace ⊆ 2-ExpTime · · ·</p><ul><li>deterministic classes (time or space) are always equal to their<br>complement classes;</li><li>non-deterministic space classes from NPSpace upwards are<br>equal to their deterministic variants (Savitch) and hence to<br>their complement classes;</li><li>NLogSpace is equal to its complement class<br>(Immerman-Szelepcse´nyi).</li></ul><h2 id="LP"><a href="#LP" class="headerlink" title="LP"></a>LP</h2><ul><li>Diophantine : A equation in which all coefficients are integers and solutions<br>are sought over the non-negative integers is called</li><li>A system of linear equations<br>Ax &#x3D; 0<br>is called homogeneous . The solution x &#x3D; 0 is the trivial<br>solution .</li></ul><h4 id="Farkas’-Lemma"><a href="#Farkas’-Lemma" class="headerlink" title="Farkas’ Lemma"></a>Farkas’ Lemma</h4><p>一定满足其中一个，不能两个都满足</p><ul><li>There exists a vector x such that Ax ≥ b and x ≥ 0</li><li>There exists a vector y such that yA ≤ 0 and yb &lt; 0</li></ul><h1 id="final-final-review"><a href="#final-final-review" class="headerlink" title="final final review"></a>final final review</h1><h2 id="3-colourability"><a href="#3-colourability" class="headerlink" title="3-colourability"></a>3-colourability</h2><p>3个gadget</p><ol><li>第一个是四边形，其中一个对角线连线，另外一组对角必须是不同颜色。</li><li>三角形一个点上面有一个点，上面这个点与三角形另外两个点必须有一个相同颜色。</li><li>两个三角形，两个点相连，然后另外两个点相连一个额外的点。这个额外的点与三角形的剩下两点需要不同颜色。</li><li>3的条件下其中一个点下面还有两个点，把这个有两个额外节点的点拿掉，这四个点中a一定有与bcd相同的颜色。</li></ol><p>背下来吧还是:{(¬p1 ∨ ¬p2 ∨ p3),(¬p2 ∨ p4 ∨ p1),(¬p1 ∨ ¬p3 ∨ p2)}</p><h2 id="Hamiltonian-circuits"><a href="#Hamiltonian-circuits" class="headerlink" title="Hamiltonian circuits"></a>Hamiltonian circuits</h2><ol><li>NPTime-Complete， 从DHAMILTONIAN-circuit reduce 来的。</li><li>穿过所有的edge每个一次叫做Eulerian，穿过所有的vertex每个一次叫做Hamiltonian。</li><li>Eulerian: every node has even degree. LogSpace , PTime.</li></ol><h2 id="TSP"><a href="#TSP" class="headerlink" title="TSP"></a>TSP</h2><ul><li>TSP feasibility：NPTime-complete</li></ul><h2 id="Matching-bipartite-graph-G-perfect-matching"><a href="#Matching-bipartite-graph-G-perfect-matching" class="headerlink" title="Matching (bipartite graph G perfect matching)"></a>Matching (bipartite graph G perfect matching)</h2><p>PTime , if 3D , NPTime-complete</p><h3 id="SAT"><a href="#SAT" class="headerlink" title="SAT"></a>SAT</h3><h2 id="reduce"><a href="#reduce" class="headerlink" title="reduce:"></a>reduce:</h2><h3 id="SAT-gt-k-SAT"><a href="#SAT-gt-k-SAT" class="headerlink" title="SAT -&gt; k-SAT:"></a>SAT -&gt; k-SAT:</h3><p>l1 ∨ l2· · · ∨ lm 可以转化成</p><p>p ∨ 3 ∨ · · · ∨ m<br>¬p ∨ l1 ∨ l2  </p><p>不断重复上诉过程直到所有clauses最多只有三个元素。用LogSpace和PTime,所以说SAT比3-SAT简单。<br>SAT ≤log m 3-SAT</p><ul><li>closed: many-one reduction 之后时间复杂度不变 Time(n),Time(n^2) 不是closed，sensible都是closed。</li><li>Commonly-encountered (i.e. sensible) complexity classes: 合理时间或资源的问题。P, NP, NP-complete, and NP-hard</li></ul><h3 id="many-one-reduction"><a href="#many-one-reduction" class="headerlink" title="many-one reduction:"></a>many-one reduction:</h3><p>P1 is (many-one polytime) reducible to P2 , 函数p1中所有的解都属于p2<br>P1 ≤p m P2</p><h3 id="complete"><a href="#complete" class="headerlink" title="complete:"></a>complete:</h3><p>SAT is NPTime-complete. Horn-SAT is PTime-complete. st-CON is NLogSpace-complete. QBF is PSpace-complete.</p><h1 id="final-review"><a href="#final-review" class="headerlink" title="final review"></a>final review</h1><h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="strongly-connected-components"><a href="#strongly-connected-components" class="headerlink" title="strongly connected components"></a>strongly connected components</h3><ul><li>incident : 一条edge与旁边的两个vertex的关系就是incident。</li><li>in-degree : 指向这个vertex的edge数量。 out-degree 相反。</li><li>strong connected : 每一个vertex 都可以从其他vertex到达。</li><li>st-CON : 从一个点reachable到另外一个。DFS来算。</li><li>acyclic : 无环。如果是acyclic directed graph，存在vertex是zero in-degree。</li><li>SSCs : Strongly connected components</li></ul><h4 id="topological-sorting"><a href="#topological-sorting" class="headerlink" title="topological sorting"></a>topological sorting</h4><ol><li><p>把所有的vertex的in-degree算出来。</p></li><li><p>从in-degree &#x3D; 0开始，推到一个Stack里。</p></li><li><p>从Stack里面一个个抽出元素，放到res里面。</p></li><li><p>res调转顺序。</p></li><li><p>当一个vertex从Stack中弹出时，它的所有父节点都必须已经弹出，并且有一个较低的index。</p></li><li><p>如果all vertex都有index。就是拓扑排序。</p></li><li><p>如果不是，则G是cyclic，并且所有vertex都是non-zero in-degree。</p></li></ol><p>RUNING Time: O(V + E) </p><h4 id="strongly-connected-components-1"><a href="#strongly-connected-components-1" class="headerlink" title="strongly connected components"></a>strongly connected components</h4><p>Kosaraju algorithm: O(V+E)</p><ol><li>DFS, 记录DFS的顺序。</li><li>反转所有边。DFS，按到时间顺序的反转来访问。访问到的节点构成了SSCs。</li></ol><p>Tarjan’s algorithm: O(V+E)</p><ol><li>时间戳dfn: 每个vertex被访问的顺序。</li><li>追溯值low: 每个vertex的追溯值就是这个vertex的子树能到达的最小时间戳。</li><li>当当前追溯值等于时间戳，意味着这个带你是个强联通量的头节点，需要弹出。剩下的就是SSCs。</li></ol><h3 id="union-find"><a href="#union-find" class="headerlink" title="union find"></a>union find</h3><ul><li>connected components: linear time 可以找到</li><li>partition: 把graph分割成几个部分，每一个部分叫做一个cell</li><li>union-find(G) : O(E+VlogV)</li></ul><h4 id="makeSet"><a href="#makeSet" class="headerlink" title="makeSet"></a>makeSet</h4><p>v.parents() &#x3D; v<br>v.length() &#x3D; 1<br>    reutrn</p><h4 id="union"><a href="#union" class="headerlink" title="union"></a>union</h4><p>把两个set连起来</p><h4 id="Lemma"><a href="#Lemma" class="headerlink" title="Lemma"></a>Lemma</h4><p>In a series of operations of makeSet, union and find on n<br>elements using the size-heuristic, no element can have its cell<br>field assigned more than blog nc + 1 times.<br>Proof.</p><p>Whenever v →cell changes, the cardinality of v → cell at least<br>doubles. But 1 ≤ |v → cell| ≤ n. This can happen no more than<br>blog nc times.<br>&#x3D;&#x3D;&#x3D; 1.30 &#x3D;&#x3D;&#x3D;</p><h4 id="Lemma-2"><a href="#Lemma-2" class="headerlink" title="Lemma 2"></a>Lemma 2</h4><p>With the above implementation, the running time of<br>union-find(G) is O(m + n log n), where n &#x3D; |V| and m &#x3D; |E|.  </p><p>The total number of calls to makeSet, union and find is linear in<br>m + n. Each call involves a constant amount of work, apart from<br>updating v →cell. But each of the n vertices can have its<br>cell-pointer updated in this way at most blog nc times, yielding<br>total work O(m + n + n log n) &#x3D; O(m + n log n).  </p><h3 id="fast-and-slow"><a href="#fast-and-slow" class="headerlink" title="fast and slow"></a>fast and slow</h3><h4 id="Grzegorczyk-hierarchy"><a href="#Grzegorczyk-hierarchy" class="headerlink" title="Grzegorczyk hierarchy"></a>Grzegorczyk hierarchy</h4><p>Grzegorczyk层级是一个可数的层级，根据其计算复杂性，图灵机可以计算的函数。层次结构的每一级都被定义为可以通过Grzegorczyk还原法还原到上一级的函数类。</p><p>Γ0是原始递归函数类。这些函数可以由图灵机在有限的时间内计算出来。</p><p>Γ1 是原始递归有界函数类。这些函数可以由图灵机在有限的时间内用有限的资源量进行计算。如果存在一个原始递归函数g(n)和一台图灵机M，使得对于任何输入x，M最多经过g(|x|)步就会停止，并返回f(x)的值，则函数f(n)属于Γ1。</p><p>Γ2是递归有界函数的类别。这些函数可以由图灵机在有限的时间内计算出来，使用的是一个不一定是原始递归的边界函数。如果一个函数可以由图灵机使用某种可由图灵机计算的边界函数来计算，那么它就属于Γ2。</p><p>Γ3是可递归列举的函数类。这些是可以被图灵机部分计算的函数。如果一个函数可以被图灵机计算，但对于给定的输入不一定会停止，则该函数属于Γ3。</p><p>Γ4 是一般递归函数类。这些是可以由图灵机计算的函数。如果一个函数是可以由图灵机计算的，那么它就属于Γ4。</p><p>值得一提的是，Γ0是Γ1的适当子类，Γ1是Γ2的适当子类，Γ2是Γ3的适当子类，Γ3是Γ4的适当子类。层次结构中的每一级都严格包含在下一级中。</p><p>exponentially bounded </p><p>doubly exponentially bounded</p><p>k-tuply exponentially bounded</p><h3 id="flow-networks-and-matching"><a href="#flow-networks-and-matching" class="headerlink" title="flow networks and matching"></a>flow networks and matching</h3><ul><li>max flow : flow的最优解</li></ul><h4 id="The-Ford-Fulkerson-algorithm"><a href="#The-Ford-Fulkerson-algorithm" class="headerlink" title="The Ford-Fulkerson algorithm"></a>The Ford-Fulkerson algorithm</h4><p>N &#x3D;  &#x3D; (V,E,s,t,c) :  (V,E)是一个graph,s和t是起始和终点,c是赋值。</p><h4 id="bipartite-graph"><a href="#bipartite-graph" class="headerlink" title="bipartite graph"></a>bipartite graph</h4><p>G &#x3D; (U,V,E) where U and V are disjoint, E 属于 U x V</p><p>perfect match : 左右两边的节点一对一全对上</p><p>maximum matching : matching 有着最多数量的edges。</p><p>naiveMatch : 寻找matching，不断递归，删除左边和右边一个点，和他们之间的边。到最后判断是否两个集合都是空，是的话Yes，否的话No。</p><h4 id="Busacker-Gowen-algorith"><a href="#Busacker-Gowen-algorith" class="headerlink" title="Busacker-Gowen algorith"></a>Busacker-Gowen algorith</h4><p>minmimum cost and max value</p><p>begin flowMaxCost(V,E,s,t,c,γ) set f (e) &#x3D; 0 for all e ∈ E<br>while<br>reachable(Nf ,s,t)<br>let e1,…,em be the edges on a shortest path from s to t for 1 ≤ i ≤ m<br>ifei ∈E,incrementf(ei)<br>else decrement f (e−1) i<br>return f  </p><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul><li>The Boyer-Moore Algorithm : 相比于暴力遍解，只需要加两个启发式。</li></ul><p>Looking-Glass Heuristic: 当第一个字节匹配，我们也同时检测最后一个substring是否匹配。</p><p>Character-Jump Heuristic: 如果string中有一个字符substring都不存在，直接跳到这个字符串后面。</p><ul><li>Knuth-Morris-Pratt Algorithm : 有一个判断子字符串的重叠信息，比如abcabcd 就是 0001230 这个叫做 $\pi$</li></ul><h2 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h2><h3 id="machine-stops"><a href="#machine-stops" class="headerlink" title="machine stops"></a>machine stops</h3><h3 id="time-space-and-determinism"><a href="#time-space-and-determinism" class="headerlink" title="time,space and determinism"></a>time,space and determinism</h3><ul><li>CO-NLogSpace: cannot solved by non-deterministic algorithms</li><li>Davis-Putnam algorithm : 目的是验证satisfiable</li></ul><h3 id="try-to-be-logical"><a href="#try-to-be-logical" class="headerlink" title="try to be logical"></a>try to be logical</h3><ul><li>Horn: 一个clause最多只能有一个positive的literal，就是Horn。并且都是vvvv这种形式的。所以能从VVVV -&gt; (and and and)-&gt; 正的那个元素</li><li>Horn set: PTime 因为它可以用一种叫做Chandon和Lewis算法的线性时间算法来解决。这个算法的工作原理是：首先将Horn公式转换为等价的共轭正常形式（CNF）公式，然后使用深度优先搜索来检查CNF公式中变量的满足性分配。由于CNF公式的大小与原始Horn公式的大小成多项式，因此该算法的总体时间复杂度也是多项式的。</li><li>Krom: 一个cluase最多只有俩元素。该算法首先将Krom公式转换为等价的共轭正常形式（CNF）公式，然后使用深度优先搜索来检查CNF公式中变量的满足性分配。由于CNF公式的大小与原始Krom公式的大小成多项式，因此该算法的总体时间复杂度也是多项式的。</li><li>QBF : 加上存在和所有。Pspace。因为画个二叉树就行了。</li><li>QBF sentence : A quantified Boolean formula with no free variables is called a<br>quantified Boolean sentence.</li></ul><h3 id="how-hard-can-this-be"><a href="#how-hard-can-this-be" class="headerlink" title="how hard can this be"></a>how hard can this be</h3><p>many-one reduction 就是一个问题a比另外一个问题b更加复杂，也就是说如果能解决困难的问题a，也就可以使用它去解决简单的问题b。many-one就是将许多的输出映射到一个函数。</p><p>为了证明一个问题可以many one reduction 到另一个问题，你需要定义一个函数，该函数接收第一个问题的输入并产生第二个问题的输出，这样，只要第一个问题的输入是第一个问题的有效输入，第二个问题的输出就是第二个问题的有效解。这个函数被称为从第一个问题到第二个问题的多一还原</p><p>多一还原经常被用来证明一个问题是NP-hard的，这意味着它至少和NP中最难的问题一样难。如果一个问题是NP-hard，那么它就被认为是非常难解决的，而且不太可能找到一个有效的算法来解决它。</p><ul><li>closed : many-one reduction 之后时间复杂度不变</li></ul><h3 id="Two-NP-Complete-problems"><a href="#Two-NP-Complete-problems" class="headerlink" title="Two NP-Complete problems"></a>Two NP-Complete problems</h3><h2 id="凸优化"><a href="#凸优化" class="headerlink" title="凸优化"></a>凸优化</h2><h3 id="Integer-Linear-Programming"><a href="#Integer-Linear-Programming" class="headerlink" title="Integer Linear Programming"></a>Integer Linear Programming</h3><h3 id="Two-Theorems-on-Space-Complexity"><a href="#Two-Theorems-on-Space-Complexity" class="headerlink" title="Two Theorems on Space Complexity"></a>Two Theorems on Space Complexity</h3><h4 id="Savitch’s-theorem"><a href="#Savitch’s-theorem" class="headerlink" title="Savitch’s theorem"></a>Savitch’s theorem</h4><h1 id="Week-4"><a href="#Week-4" class="headerlink" title="Week 4"></a>Week 4</h1><h2 id="Turing-Machines-我自己的理解"><a href="#Turing-Machines-我自己的理解" class="headerlink" title="Turing Machines (我自己的理解)"></a>Turing Machines (我自己的理解)</h2><h3 id="palindrome问题"><a href="#palindrome问题" class="headerlink" title="palindrome问题"></a>palindrome问题</h3><p>我们可以用one tape来实现判断回文。在这种情况之下，先看input的第一个，read（再这里是不用write的）head。然后在通过O(n)，n是字符串长，来跑到最后一位，判断是否相等。如果相等，继续，不想等，halt。直到判断完所有为止。</p><p>那么two tape呢。比如可以第一个tape从头往后，第二个tape从后往前，判断是否相等。</p><ol><li>但是怎么样每一个tape在一半的时候停止呢？我们可以用一个counter来计算，图灵机在判断开始前知道了字符串长度，维护counter就可以了。这个counter并不需要额外的tape去实现。</li><li>如果我们有一个set的string怎么判断回文呢？我们可以把所有的set连起来，比如”level-after-halo”。也可以图灵机嵌套去图灵机，但是这样的话图灵机只能输出单一string了。</li><li>‘-‘该用在哪里呢？可以用在判断字符串结束比如one tape中的input是”level-“.</li></ol><h3 id="binary-reverse问题"><a href="#binary-reverse问题" class="headerlink" title="binary reverse问题"></a>binary reverse问题</h3><p>每一次读取需要给1变成0，0变成1，这就涉及到了read&#x2F;write head 同时使用的地方了。</p><p>并且还有一个点就是read&#x2F;write 是隶属于head的功能，head移动，可以做read&#x2F;write这两个事，认清从属关系。</p><h2 id="Turing-Machines"><a href="#Turing-Machines" class="headerlink" title="Turing Machines"></a>Turing Machines</h2><p>控制单元K，读取一个特殊的sequence of symbols 在 K tapes 上。</p><ul><li>T : control unit （finite set of unstructions）</li><li>Tapes : 除了第一个(input) 和最后一个(output) tape, 别的都是working tape</li><li>read&#x2F;write : 小横杠，读取</li><li>Q : 可以简单的理解为</li><li>state : 一行数字，10101010110 (老师这么说但貌似不是这样，state是end ，start这些东西)</li></ul><h3 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h3><p>如果当前state是p，reading sequence s，移动到state q，write sequence t，direction d.把一个configuration变成另外一个configuration</p><h3 id="configuration"><a href="#configuration" class="headerlink" title="configuration"></a>configuration</h3><p>head 在哪，你也知道turing machine 是啥。It’s a current memory dump of the turing machine.每一个tape都是什么状态的。</p><h3 id="run"><a href="#run" class="headerlink" title="run"></a>run</h3><h3 id="Handy-notation"><a href="#Handy-notation" class="headerlink" title="Handy notation"></a>Handy notation</h3><p>x 就是从alphabate 里面选取的一个string</p><p>每一次turing machine 都开始于 blank , 然后过一段时间，没有avaiable transitions，the run stop。</p><p>我们假设有avaiable transitions， run就不会stop。</p><p>$M\downarrow x$ given input x, all of the types is blank except the input,之后会停止</p><p>$M\uparrow x$ 有可能会停止，有可能一直运行</p><p>在我的看来就是这个M会在input为x的时候停止或者停止不了。</p><h3 id="用single-number来表示图灵机"><a href="#用single-number来表示图灵机" class="headerlink" title="用single number来表示图灵机"></a>用single number来表示图灵机</h3><p>transition is a turple </p><p>transition table is a sequence of tuple.</p><p>图灵机里的啥都是turple，所以我们可以用single number来表示。问题的关键在于。</p><p>可以把一个图灵机当作input放入另外一个图灵机。</p><h3 id="acceptance-and-recognition"><a href="#acceptance-and-recognition" class="headerlink" title="acceptance and recognition"></a>acceptance and recognition</h3><p>如果一台图灵机在给定输入时停在一个接受状态，那么它就被称为 “接受 “输入。接受状态是一种特殊的状态，它被指定为机器可以停止的地方，并且仍然被认为是成功完成了它的任务。这通常用于表明输入是图灵机所要解决的问题的有效解决方案。</p><p>如果一台图灵机在给定输入时停在接受状态或拒绝状态，就可以说它 “识别 “了输入。拒绝状态是一种特殊的状态，它被指定为机器可以停止的地方，并被认为是未能找到解决方案。这通常用于表明输入不是图灵机所要解决的问题的有效解决方案。</p><p>因此，综上所述，”接受 “输入的图灵机是在给定输入时能够成功解决问题的机器，而 “识别 “输入的图灵机是能够确定输入是否是问题的有效解决方案的机器。</p><h3 id="其他的一些零碎定义"><a href="#其他的一些零碎定义" class="headerlink" title="其他的一些零碎定义"></a>其他的一些零碎定义</h3><ul><li><p>If a language is recognized by some Turing machine M , then it is recognized by some determinisitc Turing Machine M’。我的理解是图灵机可以嵌套。</p></li><li><p>language 和 （decision） problem的意思一样， recursive和decidable的意思一样</p></li></ul><h3 id="recursively-enumerable-r-e"><a href="#recursively-enumerable-r-e" class="headerlink" title="recursively enumerable (r.e.)"></a>recursively enumerable (r.e.)</h3><p>如果一个语言(language)是recursively enumable的，也就意味着存在一个图灵机，图灵机会enumerable（list）这个语言中所有的strings。重点是，他不需要有能力去算出给定的input string 在不在这个语言之中。</p><p>举个例子: {x ∈ {0, 1}∗ | x denotes a prime number}</p><p>x属于这个是二进制，比如3的话就是11. *是Kleene star，表示的是x可以是任何数字在里面。</p><h3 id="recursively-decidable-language"><a href="#recursively-decidable-language" class="headerlink" title="recursively  decidable language"></a>recursively  decidable language</h3><p>recriively enumerable languages 是recursively decidable languages的subclass。他的意思就是图灵机能不能判定input的string在不在我们指定的language之中。图灵机可以在所有的input上停止。</p><h3 id="problem"><a href="#problem" class="headerlink" title="problem"></a>problem</h3><p>举例子:<br>Consider the problem of determining whether a formula of<br>propositional logic is satisfiable<br>p0 ∧ (p1 → p10)<br>¬((p0 ∧ p1) ∨ (p0 ∧ ¬p1) ∨ (¬p0 ∧ p1) ∨ (¬p0 ∧ ¬p1))<br>This problem is the language language<br>{x ∈ {p, 0, 1, ∧,(,), ∨, ¬, →}∗<br>| x is a wff and satisfiable}.</p><p>解释：<br>The language being considered is defined as the set of all strings x in {p, 0, 1, ∧,(,), ∨, ¬, →}^* (i.e., all finite strings of symbols from the alphabet {p, 0, 1, ∧,(,), ∨, ¬, →}) that represent a well-formed formula (wff) of propositional logic and are satisfiable.</p><p>In other words, this language consists of all strings that represent formulas of propositional logic that can be satisfied (made true) by assigning values to the propositional variables in such a way that the formula evaluates to true.</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>problem name:<br>given : a string x (coding some object we are interested in);<br>return : Yes if x has some property P , and no otherwise.</p><h3 id="Halting-problem"><a href="#Halting-problem" class="headerlink" title="Halting problem"></a>Halting problem</h3><p>HALTING<br>Given: a pair of strings m, x;<br>Return: Yes if m is the code of a deterministic Turing Machine, M, and x a string in the alphabet of M, such that M ↓ x;<br>No otherwise.</p><h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>The halting problem is a famous problem in computer science that asks whether it is possible to determine, given a description of a Turing machine and an input string, whether the Turing machine will halt (stop) when run on that input.</p><p>More formally, the halting problem can be stated as follows:</p><p>Given a Turing machine M and an input string x, is it possible to determine whether M will halt when run on x?</p><p>The halting problem is undecidable, meaning that there is no algorithm or procedure that can always correctly determine whether a given Turing machine will halt on a given input. This means that it is not possible to write a program that can determine, for any arbitrary Turing machine M and input string x, whether M will halt when run on x.</p><p>The halting problem is a fundamental result in computability theory and has important implications for the limitations of computability and the design of programming languages.</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p><img src="/2023/01/04/algorithm-review/4_1.jpeg"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> In this lecture, we have:<br>• explained the origins of research into computability theory,<br>including Hilbert and Ackermann’s Entscheidungsproblem;<br>• defined Turing machines and the notion of a decidable problem<br>(&#x3D; recursive language);<br>• proved the existence of undecidable problems, and indeed<br>answered Hilbert and Ackermann’s question in the negative.  </p><h1 id="week-7"><a href="#week-7" class="headerlink" title="week 7"></a>week 7</h1><h2 id="Propositional-logic-satisifability"><a href="#Propositional-logic-satisifability" class="headerlink" title="Propositional logic satisifability"></a>Propositional logic satisifability</h2><ul><li>proposition letters : P &#x3D; {p1,p2,p3} 元素符号</li><li>formulas : $\phi$ 公式</li><li>assignment : $\theta$ P -&gt; {T,F} 赋值，例子：θ(¬ϕ1) &#x3D; T iff ϕ1 &#x3D; F</li><li>satisfiable : 存在一种assigmen 使得formula &#x3D; Ture</li><li>proposition letters(variables): p&amp;q 的p和q</li><li>connectives: &amp;, v, -&gt;, and &lt;-&gt;.</li><li>leteral: p or ¬p (p is proposition letter)</li><li>opposite leteral : l 上面一个横杠</li><li>clauses : 每个formula都是一个clause，一堆公式就是clause</li></ul><p>clause: A clause is an expression l1 v l2 v· · · ∨ k , where the li are<br>literals. ep: p1 ∨ ¬p2 ∨ p3</p><h4 id="propositional-SAT"><a href="#propositional-SAT" class="headerlink" title="propositional SAT"></a>propositional SAT</h4><p>Given: a propositional logic formula ϕ;<br>Return: Yes if ϕ is satisfiable, and No otherwise.</p><p><img src="/2023/01/04/algorithm-review/7_1.jpeg"></p><p>SAT<br>Given: a set of clauses Γ;<br>Return: Yes if Γ is satisfiable, and No otherwise.<br>k-SAT<br>Given: a set of clauses Γ, each with at most k literals;<br>Return: Yes if Γ is satisfiable, and No otherwise.</p><h4 id="Davis-Putnam-algorithm"><a href="#Davis-Putnam-algorithm" class="headerlink" title="Davis-Putnam algorithm"></a>Davis-Putnam algorithm</h4><p>目的是验证satisfiable</p><p>resolve : 移除但个元素</p><p>DPLL : </p><p><img src="/2023/01/04/algorithm-review/7_2.jpeg"></p><h2 id="special-cases"><a href="#special-cases" class="headerlink" title="special cases"></a>special cases</h2><h3 id="Horn"><a href="#Horn" class="headerlink" title="Horn"></a>Horn</h3><p>一个clause最多只能有一个positive的literal，就是Horn。并且都是vvvv这种形式的。</p><p><img src="/2023/01/04/algorithm-review/7_3.jpeg"></p><h3 id="Horn-SAT"><a href="#Horn-SAT" class="headerlink" title="Horn-SAT"></a>Horn-SAT</h3><p>in PTime</p><p>Given : a set of Horn-clauses<br>Return : satisfiable or not</p><h3 id="Krom"><a href="#Krom" class="headerlink" title="Krom"></a>Krom</h3><p>一个cluase最多只有俩元素。</p><p><img src="/2023/01/04/algorithm-review/7_4.jpeg"></p><h3 id="KROM-UNSAT"><a href="#KROM-UNSAT" class="headerlink" title="KROM_UNSAT"></a>KROM_UNSAT</h3><p>NLOGSPACE （由很多答案true或false来组成）</p><p><img src="/2023/01/04/algorithm-review/7_5.jpeg"></p><p>跳过: KROM_UNSAT 的证明</p><p><img src="/2023/01/04/algorithm-review/7_6.jpeg"></p><h2 id="QBF-quantified-boolean-formula"><a href="#QBF-quantified-boolean-formula" class="headerlink" title="QBF (quantified boolean formula)"></a>QBF (quantified boolean formula)</h2><p>就是带上$\exists$ and $\forall$</p><p>在我看来就是描述相似的function的符号。</p><p><img src="/2023/01/04/algorithm-review/7_7.jpeg"></p><p><img src="/2023/01/04/algorithm-review/7_8.jpeg"></p><p>总结</p><p><img src="/2023/01/04/algorithm-review/7_9.jpeg"></p><h1 id="Week-5"><a href="#Week-5" class="headerlink" title="Week 5"></a>Week 5</h1><h2 id="runs-in-time-amp-space"><a href="#runs-in-time-amp-space" class="headerlink" title="runs in time &amp; space"></a>runs in time &amp; space</h2><p><img src="/2023/01/04/algorithm-review/5_1.jpeg"></p><p>g is a function that maps natural numbers (i.e., non-negative integers) to natural numbers. The expression g(|x|) refers to the value of the function g applied to the input |x|, where |x| is the length of the string x.</p><p>In other words, g(|x|) is the output of the function g when the length of the string x is used as the input. For example, if |x| &#x3D; 5 and g(n) &#x3D; n^2, then g(|x|) &#x3D; g(5) &#x3D; 5^2 &#x3D; 25.</p><p>In the context of the definition you provided, g(|x|) represents the maximum number of steps that a Turing machine M is allowed to take when run on input x, where the number of steps is determined by the function g applied to the length of the input string x.</p><p>The definition states that M runs in time g if, for all but finitely many strings x in the alphabet Σ*, any run of M on input x halts within at most g(|x|) steps. In other words, M must halt within a number of steps that is determined by the function g applied to the length of the input string x, except for a finite number of strings x.</p><h2 id="Time-g-and-Space-g"><a href="#Time-g-and-Space-g" class="headerlink" title="Time(g) and Space(g)"></a>Time(g) and Space(g)</h2><p>Let L be a language over some alphabet, and let g : N → N be a<br>function. We say that L is in Time(g) if there exists a<br>deterministic Turing machine M recognizing L such that M runs in<br>time g.</p><p>Let L be a language over some alphabet, and let g : N → N be a<br>function. We say that L is in Space(g) if there exists a<br>deterministic Turing machine M recognizing L such that M runs in<br>space g.</p><h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><p>文中说Time(3n+1) ， Space$(\upharpoonright logn \upharpoonleft)$。 其实这里应该弄清楚了，时间复杂度是O(3n+1),是因为他课上讲的脑瘫方法所致，但空间复杂度可以通过这种方法达到O(logn):</p><ul><li>先给input分成两个部分，比较前者和后者的inverse是否相同，如果相同，再给每一部分分成两个再进行比较。递归到一个个元素为止。</li></ul><p>注意:The space complexity is determined by the number of memory units required to store the data needed by the algorithm as it is running.</p><h2 id="speed-up"><a href="#speed-up" class="headerlink" title="speed-up"></a>speed-up</h2><p><img src="/2023/01/04/algorithm-review/5_3.jpeg"></p><p>PTime &#x3D; Time(P)<br>ExpTime &#x3D; Time(E)<br>k-ExpTime &#x3D; Time(Ek)<br>LogSpace &#x3D; Space(log n)<br>PSpace &#x3D; Space(P)<br>ExpSpace &#x3D; Space(E)<br>k-ExpSpace &#x3D; Space(Ek)  </p><h2 id="st-CON"><a href="#st-CON" class="headerlink" title="st-CON"></a>st-CON</h2><p>一个有向图 G，有顶点u和v</p><p>return : v是否reachable from u, N otherwise</p><h2 id><a href="#" class="headerlink" title></a></h2><p><img src="/2023/01/04/algorithm-review/5_4.jpeg"></p><h2 id="TSP-feasibility"><a href="#TSP-feasibility" class="headerlink" title="TSP feasibility"></a>TSP feasibility</h2><p>旅行商问题，绕所有的点不重复并且回到原点</p><p><img src="/2023/01/04/algorithm-review/5_5.jpeg"></p><h2 id="k-COLOURABILITY"><a href="#k-COLOURABILITY" class="headerlink" title="k-COLOURABILITY"></a>k-COLOURABILITY</h2><p>Given: A graph G.<br>Return: Yes if G is k-colourable, and No otherwise.  </p><h2 id="回到图灵机"><a href="#回到图灵机" class="headerlink" title="回到图灵机"></a>回到图灵机</h2><p><img src="/2023/01/04/algorithm-review/5_6.jpeg"></p><h1 id="Week-8"><a href="#Week-8" class="headerlink" title="Week 8"></a>Week 8</h1><h2 id="k-SAT"><a href="#k-SAT" class="headerlink" title="k-SAT"></a>k-SAT</h2><p>Given: A set of clauses $\Gamma$ each of which has at most k literals.<br>Return: Y if $\Gamma$ is satisfiable, and N otherwise. </p><p>我们现在有一个set of (proposition al logic) clauses。我们拿来一个新的proposition letter : p, 然后给他全都装进去。</p><p>之前是 l3v…vlm 和 l1vl2<br>现在是  pvl3…vlm 和 -pvl1vl2</p><h2 id="reduction"><a href="#reduction" class="headerlink" title="reduction"></a>reduction</h2><h3 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h3><p>many-one reduction 就是一个问题a比另外一个问题b更加复杂，也就是说如果能解决困难的问题a，也就可以使用它去解决简单的问题b。many-one就是将许多的输出映射到一个函数。</p><p>为了证明一个问题可以many one reduction 到另一个问题，你需要定义一个函数，该函数接收第一个问题的输入并产生第二个问题的输出，这样，只要第一个问题的输入是第一个问题的有效输入，第二个问题的输出就是第二个问题的有效解。这个函数被称为从第一个问题到第二个问题的多一还原</p><p>多一还原经常被用来证明一个问题是NP-hard的，这意味着它至少和NP中最难的问题一样难。如果一个问题是NP-hard，那么它就被认为是非常难解决的，而且不太可能找到一个有效的算法来解决它。</p><h3 id="many-one-reduction-定义"><a href="#many-one-reduction-定义" class="headerlink" title="many one reduction 定义"></a>many one reduction 定义</h3><p>P1 和 P2 分别对应字母表 $\Sigma1$ 和 $\Sigma2$</p><p>我们说P1(many-one logspace) reducible to P2，如果存在function可以做到字母表1映射到字母表2通过一个function(f),并满足以下两点:</p><ol><li>function f 可以在deterministic 图灵机 使用在一个最多为log n space的任何工作tape上。</li><li>对于$\Sigma1$里所有的x，x属于P1，iff，f(x)属于P2</li></ol><p><img src="/2023/01/04/algorithm-review/8_2.jpeg"></p><h3 id="closed"><a href="#closed" class="headerlink" title="closed"></a>closed</h3><p> property of a complexity class remain under a many-one reductions.</p><h3 id="Commonly-encountered-i-e-sensible-complexity-classes"><a href="#Commonly-encountered-i-e-sensible-complexity-classes" class="headerlink" title="Commonly-encountered (i.e. sensible) complexity classes"></a>Commonly-encountered (i.e. sensible) complexity classes</h3><p>有些是close的有些不是。</p><p><img src="/2023/01/04/algorithm-review/8_3.jpeg"></p><p><img src="/2023/01/04/algorithm-review/8_4.jpeg"></p><p>图示上公式。</p><p><img src="/2023/01/04/algorithm-review/8_5.jpeg"></p><ol><li>Calculate the first bit of f1(x).  </li><li>Initialize a counter to 1 (to keep track of which output bit we are calculating).  </li><li>Start a simulation of f2(f1(x)), using the calculated bit as input.  </li><li>If the simulation of f2 asks to move the read head to the right:  <ol><li>Calculate the next bit of f1(x).  </li><li>Write it on top of the current bit.  </li><li>Update the output bit counter.</li></ol></li><li>If the simulation of f2 asks to move the read head to the left:  <ol><li>Restart the calculation of f1(x).</li></ol></li><li>Continue until the required output bit is calculated.  </li><li>Write it on top of the current bit.  </li><li>Update the output bit counter.</li></ol><p>向左移动是因为他遇到了left end，”-“，啥的，让他结束进行下一个计算。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="/2023/01/04/algorithm-review/8_6.jpeg"></p><p><img src="/2023/01/04/algorithm-review/8_7.jpeg"></p><h2 id="Cook’s-theorem"><a href="#Cook’s-theorem" class="headerlink" title="Cook’s theorem"></a>Cook’s theorem</h2><h3 id="主旨"><a href="#主旨" class="headerlink" title="主旨"></a>主旨</h3><p>SAT is NPTime-complete</p><h1 id="week-9"><a href="#week-9" class="headerlink" title="week 9"></a>week 9</h1><h2 id="k-colourability"><a href="#k-colourability" class="headerlink" title="k-colourability"></a>k-colourability</h2><p>NPTime for all k</p><p>3-colorability is NPHard</p><p>Encoding of {(¬p1 ∨ ¬p2 ∨ p3),(¬p2 ∨ p4 ∨ p1),(¬p1 ∨ ¬p3 ∨ p2)}</p><h2 id="Hamiltonian-circuits-1"><a href="#Hamiltonian-circuits-1" class="headerlink" title="Hamiltonian circuits"></a>Hamiltonian circuits</h2><p>每一个vertex只走一次</p><p>HAMILTONIAN-circuit is NPTime-complete.</p><p>A cycle that travels exactly once over each edge in a graph is called “Eulerian.” A cycle that travels exactly once over each vertex in a graph is called “Hamiltonian.”</p><p><img src="/2023/01/04/algorithm-review/9_1.jpeg"></p><h2 id="Eulerian-circuit"><a href="#Eulerian-circuit" class="headerlink" title="Eulerian circuit"></a>Eulerian circuit</h2><p>if a graph has an Eulerian circuit, then every vertex must have an even degree, since the circuit visits every edge exactly once and each edge is incident to two vertices.</p><p>The problem EULERIAN-circuit is in LogSpace, hence certainly<br>in PTime.</p><h1 id="week-10"><a href="#week-10" class="headerlink" title="week 10"></a>week 10</h1><h2 id="Caratheodory’s-theorem"><a href="#Caratheodory’s-theorem" class="headerlink" title="Carathéodory’s theorem"></a>Carathéodory’s theorem</h2><p>如果你有一个n维空间中的点集，你可以找到最多n+1个点的凸组合（系数为非负且和为1的组合），其中包括该集凸壳中的任何其他点。</p><ol><li>设E是一个由m个线性方程组成的系统。如果E有一个解在R+，那么它就最多只有m个entries是正的。</li><li>如果linear equations 在正实数集合上(R+)有一个解，那么它在正有理数集合上(Q+)也会有一个解（形式为a&#x2F;b的数字，其中a和b是正整数）。解决方案中的有理数的分子和分母将被(2mM)^m所限制。</li></ol><p>R+ : 非零正数</p><p>E : Ax &#x3D; b , e is a solution over R+</p><h2 id="LP-linear-programming"><a href="#LP-linear-programming" class="headerlink" title="LP(linear programming)"></a>LP(linear programming)</h2><p>LP-feasibility is NPTime<br>LP-infeasibility is NPTime by Farkas’ Lemma<br>E : Ax &#x3D; b</p><p><img src="/2023/01/04/algorithm-review/9_2.jpeg"></p>]]></content>
    
    
    
    <tags>
      
      <tag>36111</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>grapic_review</title>
    <link href="/2022/12/19/grapic-review/"/>
    <url>/2022/12/19/grapic-review/</url>
    
    <content type="html"><![CDATA[<h1 id="final-final-review"><a href="#final-final-review" class="headerlink" title="final final review"></a>final final review</h1><ol><li>C0 G1 C1 C2 </li><li>viewpoint dependent:<br>ray tracing, path tracing, direct volume rendering, proxy geometry<br>viewpoint independent:<br>radiosity, the rendering equation, texture baking, marching cubes    </li><li>Implicit surface :  x^2+y^2+z^2 &#x3D; n^2<br>Parametric Surface : x &#x3D; cos(t) y &#x3D; sin(t)<br>explicit surface : y &#x3D; mx + b</li><li></li></ol><h1 id="final-review"><a href="#final-review" class="headerlink" title="final review"></a>final review</h1><h2 id="week-7"><a href="#week-7" class="headerlink" title="week 7"></a>week 7</h2><h3 id="Direct-Volume-Rendering"><a href="#Direct-Volume-Rendering" class="headerlink" title="Direct Volume Rendering"></a>Direct Volume Rendering</h3><p>Trilinear Interpolation : all you’re doing here is ‘averaging out’ the values around the data point, biased in the three different directions.</p><p>Proxy geometry : 就是给屏幕切片，但是如果你的摄像头恰好与被切平面垂直，啥都看不到。可以朝着摄像头方向切。</p><p>Marching Cubes algorithm : 一堆方块的方法。</p><p>voxel: 体素结构，也被称为体素阵列，是一种用于直接体积渲染的数据结构。它是一个由小的立方体元素组成的3维数组，称为体素，代表一个三维物体或一个三维空间数据。阵列中的每个体素都包含颜色、密度和透明度等信息，可用于生成物体的2D图像。体素结构允许对大型三维数据集进行有效操作，通常用于医学成像、计算机图形和科学可视化。</p><p> opacity : 不透明度</p><h2 id="week-8"><a href="#week-8" class="headerlink" title="week 8"></a>week 8</h2><p>Gridcell : populating Space : O(n3) Finding Time : O(1)</p><p>Octree : 适合真实世界</p><h2 id="week-7-1"><a href="#week-7-1" class="headerlink" title="week 7"></a>week 7</h2><p>sub-voxel sampling</p><h2 id="week-6"><a href="#week-6" class="headerlink" title="week 6"></a>week 6</h2><p>Radiosity :</p><ul><li>able : Colour Bleed , Diffuse interreflection , Soft shadows</li><li>unable : Specular reflection , Refraction , Crisp shadows , Participating media</li></ul><p>Path tracing : </p><ul><li>able : Specular highlights, Specular reflection, Refraction, Colour bleed, Soft shadows, Hard shadows, Diffuse interreflection</li></ul><p>Rendering equation only using a BRDF : </p><ul><li>able : Specular highlights, Reflection, Colour Bleed, Penumbral Shadows, Umbral shadows, Diffuse interrefection</li><li>unable: Refraction, Depth of field, relativistic effects</li></ul><p>viewpoint moves of texture baking(烘焙) 储存数据的过程 : </p><ul><li>able : colour bleed, soft shadows, hard shadows</li><li>unable : specular highlights, specular reflection, refraction, depth of field</li></ul><h2 id="一些名词"><a href="#一些名词" class="headerlink" title="一些名词"></a>一些名词</h2><ul><li>colour bleed : 渗色</li><li>caustics : 焦散: 玻璃杯子下面阴影的点里有一个高亮处</li><li>soft shadows : 软阴影</li><li>transparency : 透明度</li><li>opaque : 不透明物体</li><li>partially transparent : 部分透明</li><li>emerge : 表面</li><li>flux : 对到达某一表面上的某一点的热力学辐射的称呼。这个术语的意思是 粒子的流动</li><li>form factor : 表面发出的光能有多少可以到达另一个表面。计算方式是一个面投影到另外一个面的面积比。计算过程不考虑表面材质哦。</li><li>参与媒体(participating media) : 就是cornell box中物体的意思，上面的光源不参与散射和吸收光线就是非参与媒体。</li><li>DOF(depth of field) : 视角范围多大</li><li>crisp shadow : 清晰的影子</li><li>DOF 不适用一个bsdf</li></ul><h1 id="week-10"><a href="#week-10" class="headerlink" title="week 10"></a>week 10</h1><p>detail culling : 无论远近，剔除太小并且消耗过多的物体。<br>Backface culling : 不渲染物体的背面看不见的东西。<br>Frustum Culling : 渲染前就移除FOV之外的东西。<br>Occlusion Culling : 它可以在渲染之前从场景中移除隐藏或闭塞的物体。z-buffer知道那些物体被遮挡，直接剔除。<br>portal culling : 确定当前视角中所有的门户，对着门户射线到其他房间。剔除看不见的区域</p><h2 id="regular-special"><a href="#regular-special" class="headerlink" title="regular special"></a>regular special</h2><h3 id="grid-cell"><a href="#grid-cell" class="headerlink" title="grid cell"></a>grid cell</h3><p>就正常网格划分</p><h3 id="OctTree"><a href="#OctTree" class="headerlink" title="OctTree"></a>OctTree</h3><p>保持每一个空间里面有最多2个物体。</p><center><img src="/2022/12/19/grapic-review/10_1.jpeg" width="400" height="200"> <br></center><h2 id="irregular-special"><a href="#irregular-special" class="headerlink" title="irregular special"></a>irregular special</h2><h3 id="HBV-Hierarchical-Bounding-Volumes"><a href="#HBV-Hierarchical-Bounding-Volumes" class="headerlink" title="HBV (Hierarchical Bounding Volumes)"></a>HBV (Hierarchical Bounding Volumes)</h3><p>use a simple shape to encapsulate a more complicated shape </p><center><img src="/2022/12/19/grapic-review/10_2.jpeg" width="400" height="200"> <br></center><h3 id="BSP-Binary-Space-Partitioning"><a href="#BSP-Binary-Space-Partitioning" class="headerlink" title="BSP (Binary Space Partitioning)"></a>BSP (Binary Space Partitioning)</h3><center><img src="/2022/12/19/grapic-review/10_3.jpeg" width="500" height="200"> <br></center><h2 id="Spatial-coherence"><a href="#Spatial-coherence" class="headerlink" title="Spatial coherence"></a>Spatial coherence</h2><p>空间连贯性指的是场景中物体的结构化排列。它是指物体被分组在一起的趋势，而不是随机分布的趋势。这种结构可能是由于各种因素造成的，如物体的物理属性、物理定律和环境的限制。例如，在一个房间里，像椅子、桌子和灯这样的物体很可能以一种连贯的排列方式出现在一起，而不是随机地散布在整个空间。在计算机图形和图像处理中，空间连贯性经常被用来简化算法和降低计算的复杂性。</p><h2 id="Temporal-coherence"><a href="#Temporal-coherence" class="headerlink" title="Temporal coherence"></a>Temporal coherence</h2><p>时间一致性是指一个事件或现象在一段时间内的一致性。它是一个过程或系统在一段时间内表现出相同行为或特征的属性。在计算机图形和图像处理中，时间一致性指的是图像或视频在一段时间内的一致性，即图像或视频的内容从一帧到下一帧没有明显变化。时间一致性经常被用来简化算法和降低计算复杂度，例如，通过从一帧到下一帧重复使用信息，或者假设图像或视频的内容不会随时间发生重大变化。</p><h2 id="Back-face-culling"><a href="#Back-face-culling" class="headerlink" title="Back-face culling"></a>Back-face culling</h2><p>Back-face culling is a method in computer graphics programming which determines whether a polygon of a graphical object is visible. If not visible, the polygon is “culled” from rendering process, which increases efficiency by reducing the number of polygons that the hardware has to draw.</p><p>The vertices of front-facing polygons wind in a clockwise fashion. This way, polygons that face away from the camera are in a counter-clockwise order relative to the current view. When back-faces are culled, these polygons are not drawn.</p><h2 id="winding-of-a-polygon"><a href="#winding-of-a-polygon" class="headerlink" title="winding of a polygon"></a>winding of a polygon</h2><p>在计算机图形学中，多边形的缠绕是指多边形的顶点的排列方向。一个多边形可以有顺时针缠绕或逆时针缠绕。缠绕很重要，因为它决定了多边形的哪一面被认为是 “前面”，哪一面被认为是 “后面”。这与渲染算法有关，例如背面剔除，它可以用来优化渲染过程，只绘制正面的多边形，而忽略背面的多边形。多边形的缠绕可以通过画一条穿过多边形顶点的线并观察线的弯曲方向来确定。如果该线以顺时针方向弯曲，则该多边形具有顺时针方向的绕线，如果该线以逆时针方向弯曲，则该多边形具有逆时针方向的绕线。</p><h1 id="week-9"><a href="#week-9" class="headerlink" title="week 9"></a>week 9</h1><h2 id="Volume-rendering"><a href="#Volume-rendering" class="headerlink" title="Volume rendering"></a>Volume rendering</h2><ol><li>渲染没有explict surface的物体 。 weather system ，一些东西没有明确的surface。 或者是there is surafce ，我们更关注物体内部，比如人体。</li><li>axial tomographiy</li></ol><p>amorphous (无固体形状的)</p><h2 id="Direct-Volume-rendering"><a href="#Direct-Volume-rendering" class="headerlink" title="Direct Volume rendering"></a>Direct Volume rendering</h2><ol><li>apply a transfer function to classify the data points, give it a color and an Alpha value.</li><li>ray casting through the view plane to figure out the color of each pixel.</li></ol><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>把values和现实世界物体联系起来叫做transfer function。</p><p>下图是cat data。我们已经知道hands field scale。<br> <center><br><img src="/2022/12/19/grapic-review/9_1.jpeg" width="600" height="200"> <br></center></p><p>但如果我们没有这个表格呢？ 我们可以给含量多少的pixel命名数字，500，250，200.在之后给每一数字命名颜色</p> <center><img src="/2022/12/19/grapic-review/9_2.jpeg" width="600" height="200"> <br></center><p>通过画表格我们大概可以知道，我们有两个区间，也就是说有可能有两种物体。于是给他们分别给上不同种类的颜色。</p><h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>ray casting， 注意在这里如果view point变换位置需要重新计算。</p><p>还有问题就是没有highlight，depth不是那么特别好区分。 </p> <center><img src="/2022/12/19/grapic-review/9_3.jpeg" width="600" height="200"> <br></center><p>我们给他变成3纬，加一个向量n，这个向量没有任何实际意义，因为我们现在在处理比如一个石头中间的部位，没有光。通过这个我们来给他加plausable surface shading  </p><h2 id="Indirect-Volume-rendering"><a href="#Indirect-Volume-rendering" class="headerlink" title="Indirect Volume rendering"></a>Indirect Volume rendering</h2><h3 id="contour-line-轮廓线-等高线"><a href="#contour-line-轮廓线-等高线" class="headerlink" title="contour line (轮廓线,等高线)"></a>contour line (轮廓线,等高线)</h3><p>也叫ISO line</p><p>天气预报，地形一类的。 相同的水平面象征着相同的高度</p><ol><li>下图描述的是用点来描述每一个位置的高度。我们就可以像图片中一样划线来描述等高线。</li><li>如图85上下颜色就可以来表示高于85是天空，低于85是石头。</li><li>通常情况下等高线是更加smooth的，我们给这个折线变成弯弯曲曲的曲线。</li></ol> <center><img src="/2022/12/19/grapic-review/9_4.jpeg" width="600" height="200"> <br></center><p>根据点不一样一共有14种情况，别的情况都是这些的反转变化。</p><p>然后向下图这样，遍历扫描所有的点，来确定整个形状是啥样。</p> <center><img src="/2022/12/19/grapic-review/9_5.jpeg" width="600" height="200"> <br></center> <center><img src="/2022/12/19/grapic-review/9_6.jpeg" width="400" height="400"> <br></center><p>提出了一个terrain editor。类似于astronomer中的填补地形工具。</p> <center><img src="/2022/12/19/grapic-review/9_7.jpeg" width="600" height="200"> <br></center><p>整体来说这种方法如上图所示，但是问题是slices之间的gap看起来很差。</p><p>我们尝试使所有切片正对着我们的viewpoint，但这样太消耗算力了。多一些slices也会提高效果显而易见。</p><h1 id="week-7-2"><a href="#week-7-2" class="headerlink" title="week 7"></a>week 7</h1><h2 id="ray-tracing"><a href="#ray-tracing" class="headerlink" title="ray tracing"></a>ray tracing</h2><h3 id="各种ray"><a href="#各种ray" class="headerlink" title="各种ray"></a>各种ray</h3><ol><li><p>primary ray : 也被称为相机光线，是为图像中的每个像素生成的光线。主射线从摄像机或观察者的视角出发，通过图像的每个像素，追踪到三维场景中。主射线被用来确定最终图像中相应像素的颜色。</p></li><li><p>shadow feeler ray : surface上一个点是不是被光线直接照射。</p></li><li><p>transmission ray : 也被称为折射光线，是计算机图形学中的一种光线，用于模拟光线通过透明物体（如玻璃或液体）时的弯曲方式。</p></li></ol><h4 id="depth-of-field"><a href="#depth-of-field" class="headerlink" title="depth of field"></a>depth of field</h4><p>一些东西是focus的一些东西是bluerred的。</p><h4 id="ray-casting"><a href="#ray-casting" class="headerlink" title="ray casting"></a>ray casting</h4><h2 id="radiosity"><a href="#radiosity" class="headerlink" title="radiosity"></a>radiosity</h2><p>radiance ： the flux leaving a surface at point x</p><p>color bleed : 旁边的墙的颜色应到了盒子上</p><center><img src="/2022/12/19/grapic-review/7_1.jpeg" width="400" height="250"> <br></center><p>$B(x)\delta A$ : 所有从$\delta A$中离开的能量在point x之中。</p><p>$E(x)\delta A$ : emmited area 比如他是发光源</p><p>$\rho(x)\delta A$ refelctivity of the point 通过reflected energy per unit area by mutiplying the incident energy per unit area which is the total energy which arrives from all the other patches.</p><p>S : all the surface from scene</p><p>$F(x,x’)$</p><p>ray tracing中如果移动viewpoint需要重新calculate ， 但是radiosity不需要。</p><ol><li>我们首先关注light source直接照射到的patches，再关注他们接下来影响到的patches。</li><li>关注他们反射到的地方。无限重复。</li><li>到有一个很高的percentage不变的时候停止。</li></ol><h1 id="week-8-1"><a href="#week-8-1" class="headerlink" title="week 8"></a>week 8</h1><h2 id="path-tracing"><a href="#path-tracing" class="headerlink" title="path tracing"></a>path tracing</h2><h4 id="umbra-and-penumbra"><a href="#umbra-and-penumbra" class="headerlink" title="umbra and penumbra"></a>umbra and penumbra</h4><center><img src="/2022/12/19/grapic-review/8_1.jpeg" width="200" height="250"> <br></center><h4 id="path-tracing-1"><a href="#path-tracing-1" class="headerlink" title="path tracing"></a>path tracing</h4><p>whitted style 就没有这种: 不是有就是无，不存在模糊</p><p>radiosity : 场景分成小块，计算每个小块洗手和反射的能量， 无法实现有光泽或透明的表面的场景。</p><center><img src="/2022/12/19/grapic-review/8_2.jpeg" width="200" height="250"> <br></center><p>只关注一条我们感兴趣的path。<br>下图完美的解释了path tracing 和ray tracing的区别。。采用了蒙特卡洛随机选择其中一条path。</p><center><img src="/2022/12/19/grapic-review/8_3.jpeg" width="200" height="250"> <br></center><h4 id="SPP（sample-per-pixel）"><a href="#SPP（sample-per-pixel）" class="headerlink" title="SPP（sample per pixel）"></a>SPP（sample per pixel）</h4><p>screen每一个pixel发射多少条ray</p><h1 id="Week-6"><a href="#Week-6" class="headerlink" title="Week 6"></a>Week 6</h1><h2 id="Rendering-Equation"><a href="#Rendering-Equation" class="headerlink" title="Rendering Equation"></a>Rendering Equation</h2> <center><img src="/2022/12/19/grapic-review/4_8.jpeg" width="300" height="200"> <br></center><ul><li>LO : a spectral radiance arriving along direction Wo from Point X. Wavelengths 入 and time t.  </li><li>Le : emited from object itself (light source)  </li><li>f欧米茄 : 积分所有角度</li><li>Li : 光线从别的地方打到x上，wi是incient incoming.</li><li>fr : BRDF. 描述物体表面的，是diffuse还是啥。</li><li>-w’n : 入射角和normal之间的夹角的cosine，描述的光线的强弱。与normal平行也就是所有打出去的光都会等量返还，cos0&#x3D;1.</li></ul><h3 id="渲染公式以后的解决方法"><a href="#渲染公式以后的解决方法" class="headerlink" title="渲染公式以后的解决方法"></a>渲染公式以后的解决方法</h3><p>analytical solution : rendering equation 是Fredholm equation of the second kind 中的一种。有一些的这个问题被解决了，但渲染公式因为是infinitely recursive所以没有被解决。</p><p>现代cg的解决方法是把一些项变换成近似值。</p><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><p>combination of diffuse and specular reflection. </p><p>提到的BRDF种类有specular，纯粹的一条线。diffuse。结合两者。更结合两者。</p><p>polished mirror 抛光镜面</p><h3 id="color"><a href="#color" class="headerlink" title="color"></a>color</h3><ul><li>人们更好地区分红色和绿色，而不是蓝色和绿色</li><li>monochromatic (单频的)。单频purple不存在，看到是因为结合了蓝色和红色。</li></ul><h3 id="BSSSDF"><a href="#BSSSDF" class="headerlink" title="BSSSDF"></a>BSSSDF</h3><p>nonmetallic(非金属) 多一些，比如手电筒打皮肤透光感。</p><p>BSDF &#x3D; BRDF + BTDF + BSSSDF</p><h1 id="week-5"><a href="#week-5" class="headerlink" title="week 5"></a>week 5</h1><h2 id="仍存在的问题"><a href="#仍存在的问题" class="headerlink" title="仍存在的问题"></a>仍存在的问题</h2><ul><li>4 种simulation的具体区别</li><li>4 种包围盒的具体区别</li></ul><h2 id="DOF-Degree-of-Freedom"><a href="#DOF-Degree-of-Freedom" class="headerlink" title="DOF (Degree of Freedom)"></a>DOF (Degree of Freedom)</h2><ul><li>3 DOF : particle system (火，烟雾)</li><li>6 DOF : 无论有多复杂，刚体的任何可能性运动（Rigid Body Simulation）都可以通过6自由度的组合进行表达。<br>Translational motion : x,y,z。 Rotary motion: 纵摇(Pitch)、横摇(Roll)和垂摇(Yaw)</li></ul><p>Force and torque: 力与扭力</p><p>Impulse-based collisions : 描述碰撞发生时候做的运动</p><p>Rest in contact : 一些物体静止了，我们没必要计算他们的collisions，设定他们的状态为rest in contact， 直到有物体接触这个物体位置，解除状态。</p><p>Stacking : 砖头之间怎么样互相卡住的。</p><h2 id="articulated-rigid-body-simulation-（刚体关节的仿真）"><a href="#articulated-rigid-body-simulation-（刚体关节的仿真）" class="headerlink" title="articulated rigid body simulation （刚体关节的仿真）"></a>articulated rigid body simulation （刚体关节的仿真）</h2><p>两块骨头&#x2F;中间链接的部分叫做： joint constraint</p><p>原本两块骨头分别6个DOF。但可以通过以下两种方式减少DOF。</p><ol><li>由于链接，在一个面，所以关节处-2个rotate。</li><li>因为链接，一个物体必定在另一个末端，所以关节-3个坐标点。</li></ol><p>总体来说12-5 &#x3D; 7 个。</p><p>其实换一种说法，我们只需要判定一个物体的6DOF，再加上rotate中的任何一个，也就是一个旋转角度1DOF，就可以描述两个关节的状态。</p><p>例子： 人的骨头，车的轮子。。。etc</p><h2 id="Deformable-object-simulation-可变形物体的仿真"><a href="#Deformable-object-simulation-可变形物体的仿真" class="headerlink" title="Deformable object simulation (可变形物体的仿真)"></a>Deformable object simulation (可变形物体的仿真)</h2><p>物体是elastic（有弹性）的。刚体的方法不可以适用。提出了FEM。</p><h3 id="1-Finite-Element-Method-FEM-有限元思想"><a href="#1-Finite-Element-Method-FEM-有限元思想" class="headerlink" title="1. Finite Element Method (FEM) 有限元思想"></a>1. Finite Element Method (FEM) 有限元思想</h3><p> 把物体变成很多四面体(Tetrahedralization),因为四面体是3D中最简单的有volume的形状。类似于tringle在surface中。</p><p>deformed shape 可以通过 FEM 变成rest shape。具体的通过方式当前阶段不需要学习。也就是从形变之后的物体（三角形或者四面体对应2D或3D）如何转化成静止的物体（三角形或者四面体）的这个交互是通过FEM完成的。</p><h3 id="2-mass-spring-fracture-simulation"><a href="#2-mass-spring-fracture-simulation" class="headerlink" title="2. mass-spring fracture simulation"></a>2. mass-spring fracture simulation</h3><p>用来描述压力下的物体。</p><h3 id="3-particle-based-fluid-simulation-Lagrangian"><a href="#3-particle-based-fluid-simulation-Lagrangian" class="headerlink" title="3. particle-based fluid simulation (Lagrangian)"></a>3. particle-based fluid simulation (Lagrangian)</h3><p>给液体堪称很多个粒子</p><h3 id="4-grid-based-fluid-simulation-Eulerian"><a href="#4-grid-based-fluid-simulation-Eulerian" class="headerlink" title="4. grid-based fluid simulation(Eulerian)"></a>4. grid-based fluid simulation(Eulerian)</h3><p>给空间划分成很多的网格，进入每一个小网格的物体和出去的应该是一样的数量</p><h3 id="5-Hybrid-fuild-simulation-Lagrangian-Eulerian"><a href="#5-Hybrid-fuild-simulation-Lagrangian-Eulerian" class="headerlink" title="5. Hybrid fuild simulation(Lagrangian + Eulerian)"></a>5. Hybrid fuild simulation(Lagrangian + Eulerian)</h3><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>有限元法（FEM）是一种用于解决微分方程的数值技术。它是一种通用的方法，广泛用于模拟各种物理系统，包括流体力学、传热学和结构力学。FEM以其处理复杂几何形状的能力和为具有平滑解的问题提供精确解而闻名。然而，它可能是计算密集型的，而且可能不是模拟某些类型流体的最有效方法，例如那些具有高粘度的流体。  </p><p>Eulerian是一种数值技术，通过监测空间中固定点的某些量（如速度、密度和压力）的值来跟踪流体的运动。这种方法通常用于模拟涉及不可压缩流体的问题，善于捕捉处于稳定状态的流体的行为。欧拉法适用于模拟像牛奶这样没有宏观变形的粘性流体。  </p><p>Lagrangian是一种数值技术，它追踪单个流体粒子在空间移动时的运动。这种方法通常用于模拟涉及可压缩流体的问题，它善于捕捉正在发生大变形的流体的行为。  </p><p>mass-spring是一种简单且计算效率高的方法，用于模拟涉及大量粒子或节点的系统。它可以用来模拟流体，但一般来说，由于其假设的线性和弹性行为，它对复杂的系统和流体，如牛奶，并不那么准确。</p><h2 id="Collusion-detection"><a href="#Collusion-detection" class="headerlink" title="Collusion detection"></a>Collusion detection</h2><h3 id="1-implict-equation-for-surface"><a href="#1-implict-equation-for-surface" class="headerlink" title="1. implict equation for surface"></a>1. implict equation for surface</h3><p>是常用的检测intersation与否的方法。<br>if H(x,y,z) &#x3D; 0 意味着物体在surface上, &lt;0意味着在surface里面。</p><p>应对于其他种类mesh（网格）等比较复杂</p><h3 id="2-backtracking"><a href="#2-backtracking" class="headerlink" title="2. backtracking"></a>2. backtracking</h3><p>处理碰撞问题的时候，发现物体已经进入surface之中了，利用backtracking，使进入surface的物体回到intersaction这个点来计算反射光线。常用语ray object之中。</p><h3 id="3-fixing"><a href="#3-fixing" class="headerlink" title="3. fixing"></a>3. fixing</h3><p>同上，但是处理方式变成了找到离目前点更近的surface点。是inaccurate的但是更加容易compute。</p><h3 id="4-多个物体同时碰撞"><a href="#4-多个物体同时碰撞" class="headerlink" title="4. 多个物体同时碰撞"></a>4. 多个物体同时碰撞</h3><p>时间复杂度n2，每一个物体都需要与其他物体进行碰撞检测。</p><h3 id="5-bounding-volumes"><a href="#5-bounding-volumes" class="headerlink" title="5. bounding volumes"></a>5. bounding volumes</h3><p>经典包围盒  </p><h1 id="week-4"><a href="#week-4" class="headerlink" title="week 4"></a>week 4</h1><h2 id="rigging-索具"><a href="#rigging-索具" class="headerlink" title="rigging(索具)"></a>rigging(索具)</h2><p>建造animation controls叫做rigging</p><p> Rigging is the process of setting up a character or object for animation, which involves creating a virtual skeleton for the character or object and assigning control handles or bones to the skeleton. The bones can then be used to control the movement and posing of the character or object in a 3D software package or game engine.</p><h3 id="articulated-skeleton-铰链骨架"><a href="#articulated-skeleton-铰链骨架" class="headerlink" title="articulated skeleton(铰链骨架)"></a>articulated skeleton(铰链骨架)</h3> <center><img src="/2022/12/19/grapic-review/4_1.jpeg" width="300" height="200"> <br></center><p>上图是2 dimension中有2个segment的手臂。 </p><p>P 是end effector</p><h3 id="forward-kinematics"><a href="#forward-kinematics" class="headerlink" title="forward kinematics"></a>forward kinematics</h3><p>通过joint angle 寻找end effector 也就是点P</p> <center><img src="/2022/12/19/grapic-review/4_2.jpeg" width="300" height="200"> <br></center><h3 id="inverse-kinematics"><a href="#inverse-kinematics" class="headerlink" title="inverse kinematics"></a>inverse kinematics</h3><p>反之通过end effector P 寻找 joint angle</p> <center><img src="/2022/12/19/grapic-review/4_3.jpeg" width="300" height="200"> <br></center><p>重要 : Inverse kinematics is to find the motion to reach a desired position 是正确的，因为joint angle从某种意义上来说算是描述motion。</p><h2 id="data-driven-approach"><a href="#data-driven-approach" class="headerlink" title="data-driven approach"></a>data-driven approach</h2><p>用高速摄像机来进行动态捕捉（Motion Capture）。</p><h3 id="retargeting"><a href="#retargeting" class="headerlink" title="retargeting"></a>retargeting</h3><p>marker position 转换成 character control的过程。</p><h3 id="skinning"><a href="#skinning" class="headerlink" title="skinning"></a>skinning</h3><p>Q : You modeled an imaginary character with three hands and two legs, then you augmented the character with bones (or handles). Now you need to move the character along with assigned bones. What is this step known as? </p><p>A : skinning</p><p>skeleton subspace deformation(SSD) 比较出名的算法。</p> <center><img src="/2022/12/19/grapic-review/4_4.jpeg" width="300" height="200"> <br></center><p>每一个颜色代表一个bone，黑色的话代表它属于多个骨头。</p> <center><img src="/2022/12/19/grapic-review/4_5.jpeg" width="300" height="200"> <br></center>每一个vertex改属于哪一个骨头。我们用wij表示，weight=1的话意味着vertex I 严格属于骨头j。并且每一个vertex的所有骨头之和的weight应该是1。weight 应该是非负数。<p>转移坐标系的公式：</p> <center><img src="/2022/12/19/grapic-review/4_6.jpeg" width="300" height="200"> <br></center><p>公式的意思：rest position的pi，转换到骨头坐标系通过Bj-1，在转换到world坐标系Tj。</p><p>bind pose : 指的是两个bone同时处于rest position</p><h4 id="SSD-例子："><a href="#SSD-例子：" class="headerlink" title="SSD 例子："></a>SSD 例子：</h4><ol><li>两个bone处于bind pose，他们经过transformation T1 和 T2 变换成了T‘1 和 T’2。</li><li>原本的P0也就是两块骨头中间的位置分别变成了P1和P2。我们想要算原本P0处的皮肤需要移动与否。</li><li>P0 &#x3D; 0.5<em>p1 + 0.5</em>p2</li><li>结果不是好的。</li></ol><h2 id="physics-based-animation"><a href="#physics-based-animation" class="headerlink" title="physics based animation"></a>physics based animation</h2><h3 id="animation-of-partical-system"><a href="#animation-of-partical-system" class="headerlink" title="animation of partical system"></a>animation of partical system</h3><p>particle 和 fluid 不一样的是，他们每一个都是分开的。</p><h3 id="ODE-ordinary-differential-equation"><a href="#ODE-ordinary-differential-equation" class="headerlink" title="ODE (ordinary differential equation)"></a>ODE (ordinary differential equation)</h3><ul><li>一般都用一些pure heuristic （启发式）来模拟还不错的效果。</li><li>基于物理的模拟其实就是integrate bunch of（一群）ODE</li></ul><p>如何解ODE呢？我们举个例子如下， Newtonian method</p><h4 id="Newtonian-method"><a href="#Newtonian-method" class="headerlink" title="Newtonian method"></a>Newtonian method</h4><p>是 second order ODE。 用来模拟point mass。</p><p>F &#x3D; ma </p> <center><img src="/2022/12/19/grapic-review/4_7.jpeg" width="300" height="200"> <br></center><p>积分ODE是在做什么？用图像来表示是在做这个事情：</p><ol><li>寻找切线（tangent）</li><li>切线的点就是next guess，也就是next state在哪里</li></ol> <center><img src="/2022/12/19/grapic-review/4_9.jpeg" width="300" height="200"> <br></center><h3 id="Euler-method"><a href="#Euler-method" class="headerlink" title="Euler method"></a>Euler method</h3><p>简单容易实现不精确的方法。</p><p>h 是a step size age。</p><p>x0 time为0的时候位置。</p> <center><img src="/2022/12/19/grapic-review/4_11.jpeg" width="300" height="200"> <br></center> <center><img src="/2022/12/19/grapic-review/4_12.jpeg" width="300" height="200"> <br></center><h4 id="Eluer-method-drawback"><a href="#Eluer-method-drawback" class="headerlink" title="Eluer method drawback"></a>Eluer method drawback</h4><p>f(X,t) &#x3D; (-y<br>…………..x)</p><p>Euler method 是inaccurate的在某些情况，因为一直沿着切线走会走出范围。去对比于newtonian method方法，我们永远无法得到一个perfect circule</p><h3 id="Forces"><a href="#Forces" class="headerlink" title="Forces"></a>Forces</h3><h4 id="buoyancy（浮力）"><a href="#buoyancy（浮力）" class="headerlink" title="buoyancy（浮力）"></a>buoyancy（浮力）</h4><p>Point mess ： 是一个vector，多个。<br>处理smoke的时候我们有一个小tip ： 让smoke的gravity 向上来进行模拟。 也可以叫buoyancy（浮力）。</p><h4 id="viscous-damping（粘性阻尼）"><a href="#viscous-damping（粘性阻尼）" class="headerlink" title="viscous damping（粘性阻尼）"></a>viscous damping（粘性阻尼）</h4><p>比如 honey 或者 wind resistance(风阻)</p><p>设定damping越多物体越stabilized</p><h4 id="spatial-field-（空间场）"><a href="#spatial-field-（空间场）" class="headerlink" title="spatial field （空间场）"></a>spatial field （空间场）</h4><p>或者叫velocity field。空间中每一个向量描述将物体推向哪一个方向。</p><h4 id="hair"><a href="#hair" class="headerlink" title="hair"></a>hair</h4><p>一堆particle组成的，每一个之间距离我们保持一致。</p><p>hooks law </p><p>里面的系数K : 描述物体的stiffness</p><p>不要忘了相互作用力，两个点受到的力是相同的。</p> <center><img src="/2022/12/19/grapic-review/4_10.jpeg" width="300" height="200"> <br></center><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h4><ol><li>structrual forces： enforce invariant properties of the system like force in the distance between 2 particles and to be constant same as in cloth or hair.</li><li>internal deformation forces: string board tried to remain flat. </li><li>external forces : wind coming, friction , wind coming.</li></ol><h1 id="week-3"><a href="#week-3" class="headerlink" title="week 3"></a>week 3</h1><h2 id="Color"><a href="#Color" class="headerlink" title="Color"></a>Color</h2><h3 id="cone"><a href="#cone" class="headerlink" title="cone"></a>cone</h3><p>cone cell（色锥细胞）一共有三种。</p><ul><li>short-wave cone </li><li>middle-wave cone </li><li>lone-wave cone</li></ul><p>在不同波长三种cone的工作状态不一样</p><center><img src="/2022/12/19/grapic-review/3_2.jpeg" width="300" height="200"> <br></center><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>色彩饱和度(Saturation): 饱和度高颜色鲜艳，饱和度低的颜色柔和或沉闷。 </p><p>gamma encoding:图像的伽马编码是利用人类对光线和颜色的非线性感知方式，来优化编码图像时的比特使用，或用于传输图像的带宽。在普通照明条件下（既不是漆黑一片，也不是亮得刺眼），人类对亮度（亮度）的感知遵循一个近似的幂函数（与伽马函数没有关系），对深色调之间的相对差异比浅色调之间更敏感，这与亮度感知的史蒂芬幂律一致。 如果图像没有进行伽马编码，就会把太多的比特或太多的带宽分配给人类无法区分的高光部分，而把太少的比特或太少的带宽分配给人类敏感的阴影值，需要更多的比特&#x2F;带宽来维持同样的视觉质量。对浮点图像进行伽马编码是不需要的（而且可能会起到反作用），因为浮点格式已经提供了对数曲线的片状线性近似。<br>metamer:在测色学中，metamerism是指具有不同（不匹配）光谱功率分布的颜色的感知匹配。以这种方式匹配的颜色被称为元体。光谱功率分布描述了一个颜色样本在每个可见波长下发出（发射、透射或反射）的总光的比例；它定义了关于来自样本的光的完整信息。然而，人的眼睛只包含三个颜色受体（三种类型的锥体细胞），这意味着所有的颜色都被简化为三个感觉量，称为tristimulus值。之所以会出现同构现象，是因为每一种锥体细胞都对来自广泛的波长的累积能量作出反应，因此，所有波长的光的不同组合可以产生相等的受体反应和相同的三刺激值或颜色感觉。 在色彩科学中，感觉光谱敏感度曲线的集合是由色彩匹配函数来表示的。</p><h3 id="HSI"><a href="#HSI" class="headerlink" title="HSI"></a>HSI</h3><p>HSI颜色空间是从人的视觉系统出发，用色调（Hue）、色饱和度（Saturation）和亮度（Intensity）来描述色彩。HSI颜色空间可以用一个圆锥空间模型来描述。用这种描述HSI色彩空间的圆锥模型相当复杂，但确能把色调、亮度和色饱和度的变化情形表现得很清楚。</p><center><img src="/2022/12/19/grapic-review/3_4.jpeg" width="300" height="300"> <br></center><h3 id="混合颜色"><a href="#混合颜色" class="headerlink" title="混合颜色"></a>混合颜色</h3><ul><li>左边是additive color。像是光。</li><li>右边是subtractive color。 像是paint。<center><img src="/2022/12/19/grapic-review/3_1.jpeg" width="700" height="200"> <br></center></li></ul><h3 id="RGB"><a href="#RGB" class="headerlink" title="RGB"></a>RGB</h3><p>左边的是人眼看到的</p><p>右边是rgb正常工作的。有负数就给B和G增加，给R变成0。</p><center><img src="/2022/12/19/grapic-review/3_5.jpeg" width="400" height="300"> <br></center><h3 id="chromaticity-diagram"><a href="#chromaticity-diagram" class="headerlink" title="chromaticity diagram"></a>chromaticity diagram</h3><p><a href="https://www.zhihu.com/question/441617032/answer/1707671686">https://www.zhihu.com/question/441617032/answer/1707671686</a></p><p>XYZ中抛开亮度（luminance），剩下的二维切片（profile）xy可以表示颜色的色度（chromaticity），二维的也比较容易画出来。但一个色度会对应亮度不同的多个颜色。具体画图时会选取一个合适的亮度xyz颜色空间中的颜色可以对应到RGB颜色空间中，但不是一一对应，有效的颜色在xy切片上是个舌头的形状，这与人眼本身的特性和xyz空间的定义有关。</p><center><img src="/2022/12/19/grapic-review/3_3.jpeg" width="300" height="300"> <br></center><p>3D -&gt; 2D<br>x &#x3D; X&#x2F; (X+Y+Z)<br>y &#x3D; Y&#x2F;(X+Y+Z)</p><h2 id="Concept-of-animation"><a href="#Concept-of-animation" class="headerlink" title="Concept of animation"></a>Concept of animation</h2><h3 id="Principles-of-animation"><a href="#Principles-of-animation" class="headerlink" title="Principles of animation"></a>Principles of animation</h3><ul><li>Squash and stretch  </li><li>Anticipation  </li><li>Staging  </li><li>Straight-ahead action and pose-to-pose  </li><li>Follow through and overlapping action  </li><li>Slow in and slow out  </li><li>Arc  </li><li>Secondary action  </li><li>Timing  </li><li>Exaggeration  </li><li>Solid drawing  </li><li>Appeal</li></ul><h4 id="squash-and-stretch"><a href="#squash-and-stretch" class="headerlink" title="squash and stretch:"></a>squash and stretch:</h4><p>Squash and Stretch挤压与伸展<br>动画对象会通过变长或变平，来突出其速度、动量、重量及质量<br>小球落地</p><center><img src="/2022/12/19/grapic-review/3_6.webp" width="600" height="300"> <br></center><h4 id="timing"><a href="#timing" class="headerlink" title="timing:"></a>timing:</h4><p>Timing节奏<br>动画的生动、有趣和自然感，受介于主动作之间的插入帧数量的影响，相同时间内，帧越多，物体运动速度越慢<br>两帧一画（两帧共用一张图片）<br>使用量大</p><ol><li>可以减轻一半的工作量</li><li>两帧一画在快动作上效果更加出色，赋予画面生气与灵动</li></ol><center><img src="/2022/12/19/grapic-review/3_7.webp" width="600" height="300"> <br></center><h3 id="animate-motion-of-object-in-the-scene"><a href="#animate-motion-of-object-in-the-scene" class="headerlink" title="animate motion of object in the scene"></a>animate motion of object in the scene</h3><ol><li>production:</li></ol><p>制作场景中物体的动画运动是指通过快速连续显示一系列静态图像或帧来创造运动的错觉的过程。</p><ol start="2"><li>interactive:</li></ol><p>是指通过用户输入来操纵或控制场景中物体运动的能力。这可以通过各种方式实现，如使用鼠标或键盘来控制物体的运动</p><ol start="3"><li>keyframe</li></ol><p>只记录关键帧。 用twinning来填充各个步骤之前的流动性</p><ol start="4"><li>procedural</li></ol><p>motion algorithmically。 比如钟表，我们可以使时间变成参数。</p><ol start="5"><li>Tweening and Twining</li></ol><p>Tweening是一种用于在关键帧之间创建平滑过渡的技术，而Tinning是一种用于创建一个物体的多个副本并使其独立运动的技术。</p><p>前者一个物体的流畅运动，后者物体变成多个。</p><h1 id="week-2"><a href="#week-2" class="headerlink" title="week 2"></a>week 2</h1><h2 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h2><center><img src="/2022/12/19/grapic-review/2_1.jpeg" width="400" height="200"> <br></center><p>给一个线拉成平面</p><h4 id="displacement"><a href="#displacement" class="headerlink" title="displacement"></a>displacement</h4><p>paint displacement on a smooth surface.</p><p>we tessellate somooth patch into fine grid, then add displacement at a particular point like UV. 经常在游戏和电影中用，让东西变bumping。</p><center><img src="/2022/12/19/grapic-review/2_2.jpeg" width="400" height="200"> <br></center><h4 id="Chaikin’s-algorithm-subdivision-surface"><a href="#Chaikin’s-algorithm-subdivision-surface" class="headerlink" title="Chaikin’s algorithm (subdivision surface)"></a>Chaikin’s algorithm (subdivision surface)</h4><p>corner cutting.</p><p>让一个平面无限细分，把每一条变分成更多份。让一个多边形变成不规则的图形。</p><h4 id="sculpturing"><a href="#sculpturing" class="headerlink" title="sculpturing"></a>sculpturing</h4><p>声称球的过程，从一个正方形开始无限分割。</p><p>但注意不能有hole在里面。需要torus。之后做的事情和subdivision一样。</p><h4 id="另一种"><a href="#另一种" class="headerlink" title="另一种"></a>另一种</h4><p>另外一种生成平面的方式，把2D curve 旋转一周变成3D</p><center><img src="/2022/12/19/grapic-review/2_3.jpeg" width="700" height="200"> <br></center><p>R : rotate matrix</p><p>q : vertor of points</p><p>总而言之就是有一个2D profile 和一个3D的曲线。sweep the profile along the 3D curve</p><center><img src="/2022/12/19/grapic-review/2_4.jpeg" width="400" height="200"> <br></center><p>那我们的curve该如何定义呢？ frame of curve (frenet frame):</p><p>In a Frenet frame, the tangent vector (T) is a unit vector that points in the direction of the curve at a given point. The normal vector (N) is a unit vector that is orthogonal to the tangent vector and points in the direction of the curvature at a given point. The binormal vector (B) is a unit vector that is orthogonal to both the tangent and normal vectors and points in the direction of the rate of change of the direction of the curve.</p><p>drawback 就是 inflection:</p><p>inflection 指的是右图的那个我们想改变位置的点，因为normal描述运动趋势。所以我们要是改变曲线的话那个点也会变化。为啥这是不好的，他也没说</p><p> In a Frenet frame, the tangent vector (T) points in the direction of the curve at a given point, and it does not change direction when the curvature changes sign. An inflection point on a curve is a point where the curve changes concavity, but the tangent vector does not change direction at an inflection point.</p><h4 id="Implicit-surface"><a href="#Implicit-surface" class="headerlink" title="Implicit surface"></a>Implicit surface</h4><p>在数学中，隐式曲面是欧几里得空间中由方程定义 的曲面。<br>F(x,y,z)&#x3D;0<br>隐式曲面是三个变量的函数的零点集合。隐式意味着方程没有求解x或y或z。</p><p>ep: 球体 x^2+y^2+z^2 &#x3D; n^2</p><h4 id="Parametric-Surface"><a href="#Parametric-Surface" class="headerlink" title="Parametric Surface"></a>Parametric Surface</h4><p>输出的成分是基于一些参数或参数的。</p><p>如二次贝塞尔曲线（其中A、B、C和CurvePoint是N个维度的点）。<br>CurvePoint &#x3D; f(t) &#x3D; A*(1-t)^2 + B<em>2t(1-t) + C</em>t^2</p><p>或单位圆。<br>x &#x3D; cos(t)<br>y &#x3D; sin(t)</p><p>或者像这样的曲面。<br>SurfacePoint3D &#x3D; f(u,v)</p><h4 id="explicit-surface"><a href="#explicit-surface" class="headerlink" title="explicit surface"></a>explicit surface</h4><p>比较常见的函数类型，你在左边有一个变量（因变量），右边有另一个变量（自变量）。</p><p>比如说线。<br>y &#x3D; mx + b</p><p>或高度场。<br>高度 &#x3D; f(x,y)Ackermann Ackermann </p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>An implicit equation of a surface is a mathematical equation that defines the points on the surface as the points that satisfy the equation. An explicit equation of a surface, on the other hand, is a mathematical description of the surface that defines the coordinates of the points on the surface as a function of one or more parameters.</p><p>The relationship between implicit and explicit equations of a surface is that any surface that can be described by an implicit equation can also be represented by an explicit equation, and vice versa. In other words, any surface that can be defined by an equation of the form f(x, y, z) &#x3D; 0 can also be represented by a parametric equation of the form (x, y, z) &#x3D; (x(u, v), y(u, v), z(u, v)), and any surface that can be represented by a parametric equation can also be described by an implicit equation.</p><p>The choice between using an implicit or explicit equation to represent a surface depends on the specific needs and context of the problem at hand. Implicit equations are generally easier to work with mathematically, while explicit equations are more convenient for visualizing and manipulating surfaces in computer graphics applications.</p><h1 id="week-1"><a href="#week-1" class="headerlink" title="week 1"></a>week 1</h1><h2 id="line"><a href="#line" class="headerlink" title="line"></a>line</h2><p>polyline: 连续的折线</p><p>line: 不管啥样的线都是1D的。line 包含curve。</p><center><img src="/2022/12/19/grapic-review/1_1.jpeg" width="400" height="80"> <br></center><p>左边的公式适用于在曲线上生成点（为了pipeline）</p><p>右边的公式适用于描述trajectories(轨道)。可以用来延续一条curve。</p><center><img src="/2022/12/19/grapic-review/1_2.jpeg" width="400" height="400"> <br></center><p>define 1D curve in 3D space.</p><h2 id="Speedline"><a href="#Speedline" class="headerlink" title="Speedline"></a>Speedline</h2><p>curve上取两个及以上个数的点。</p><p>tessellation : describe p(t) at discrete validity value（分离的一些点）。加更多的点让他更加接近smooth的目标曲线。</p><p>interpolation : curve经过了所有的specify points</p><p>approxmiation : curve没有必要经过所有的点</p><p>接下来提供两种speedline</p><h3 id="cubic-bezier-curves"><a href="#cubic-bezier-curves" class="headerlink" title="cubic bezier curves"></a>cubic bezier curves</h3><center><img src="/2022/12/19/grapic-review/1_3.jpeg" width="400" height="230"> <br></center><p>这种曲线总是被control points 组成的convex包裹着 </p><p>注： 曲线在endpoint 正切</p><center><img src="/2022/12/19/grapic-review/1_4.jpeg" width="400" height="260"> <br></center><p>p(t)如图所示，描述了每一个基于T的点的权重值</p><p>性质(partition of unity): 所有点相加得1 , T [0,1] .  所以被convew包裹着</p><center><img src="/2022/12/19/grapic-review/1_5.jpeg" width="400" height="150"> <br></center><p>matrix1： Geometry matrix ,  一组xy对应一个control point，里面包含所有的control points。</p><p>matrix2: coefficient</p><p>matrix3: Bernstein polynomials</p><center><img src="/2022/12/19/grapic-review/1_6.jpeg" width="400" height="300"> <br></center><p>使曲线变得更复杂。如图采取中点。给曲线由3个control points 变成7 个。 </p><p>注: 也可以不是中点 而是任意的radio。</p><h3 id="continuity"><a href="#continuity" class="headerlink" title="continuity"></a>continuity</h3><center><img src="/2022/12/19/grapic-review/1_7.jpeg" width="400" height="200"> <br></center><p>C0 : 两条curve相交点是sharp kink。</p><p>G1 : 两条curve相交点tan是同一个direction。</p><p>C1 : 两条curve相交点tan完全相同。</p><p>C2 : 两条curve相交点tan完全相同，导数也完全相同。</p><h3 id="cubic-BSP-line"><a href="#cubic-BSP-line" class="headerlink" title="cubic BSP line"></a>cubic BSP line</h3><center><img src="/2022/12/19/grapic-review/1_8.jpeg" width="400" height="200"> <br></center><h3 id="BSP-vs-Bezier"><a href="#BSP-vs-Bezier" class="headerlink" title="BSP vs Bezier"></a>BSP vs Bezier</h3><p>BSP 不经过endpoints</p><p>Bezier 经过</p><h3 id="两者转换"><a href="#两者转换" class="headerlink" title="两者转换"></a>两者转换</h3><p>B1 是 bezier</p><p>B2 是 BSP</p><center><img src="/2022/12/19/grapic-review/1_10.jpeg" width="400" height="250"> <br></center>]]></content>
    
    
    
    <tags>
      
      <tag>37111</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法-对时间复杂度的汇总</title>
    <link href="/2022/11/23/%E7%AE%97%E6%B3%95-%E5%AF%B9%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%B1%87%E6%80%BB/"/>
    <url>/2022/11/23/%E7%AE%97%E6%B3%95-%E5%AF%B9%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E7%9A%84%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="P-NP-P-SPACE"><a href="#P-NP-P-SPACE" class="headerlink" title="P,NP,P-SPACE"></a>P,NP,P-SPACE</h1><h3 id="P"><a href="#P" class="headerlink" title="P"></a>P</h3><p>Polynomial time 多项式时间内($n^c$)有正确解。n是输入规模，c是常数。ep：是否是质数，两点之间最短距离。</p><h3 id="NP"><a href="#NP" class="headerlink" title="NP"></a>NP</h3><p>Non-deterministic Polynomial time 能在多项式时间内验证是否有正确答案。返回True，False。NP问题都有“short witnesses”使其能快速验证答案。</p><h3 id="PH"><a href="#PH" class="headerlink" title="PH"></a>PH</h3><p>Polynomial Hierarchy(多层式分级) 如果一个问题开始是NP，但随后会增加额外的复杂性，该问题就是PH。ep: 给定X，是否存在一个Y，使得对于所有的Z。</p>]]></content>
    
    
    
    <tags>
      
      <tag>36111</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法5</title>
    <link href="/2022/11/07/%E7%AE%97%E6%B3%955/"/>
    <url>/2022/11/07/%E7%AE%97%E6%B3%955/</url>
    
    <content type="html"><![CDATA[<p>Log Time &lt;&#x3D; Nlog Time &lt;&#x3D; P Time &lt;&#x3D; NP Time &lt;&#x3D; P Space &#x3D;&#x3D; NP Space &lt;&#x3D; Exp Time &lt;&#x3D; NExpTime &lt;&#x3D; ExpSpace &lt; NExpSpace &lt;&#x3D; 2ExpTime</p><ul><li>if ϕ1 and ϕ2 are formulas, then so are</li></ul><p>(¬ϕ1), (ϕ1 ∨ ϕ2), (ϕ1 ∧ ϕ2), (ϕ1 → ϕ2)</p><h2 id="lecture-2"><a href="#lecture-2" class="headerlink" title="lecture_2"></a>lecture_2</h2><h2 id="SAT-amp-k-SAT"><a href="#SAT-amp-k-SAT" class="headerlink" title="SAT &amp; k-SAT"></a>SAT &amp; k-SAT</h2><p>SAT</p><p>Given: a set of clauses Γ;<br>Return: Yes if Γ is satisfiable, and No otherwise.</p><p>k-SAT</p><p>Given: a set of clauses Γ, each with at most k literals;<br>Return: Yes if Γ is satisfiable, and No otherwise.</p><h2 id="formula"><a href="#formula" class="headerlink" title="formula"></a>formula</h2><ul><li><p>proposition letters(variables): p&amp;q 的p和q</p></li><li><p>connectives:  &amp;, v, -&gt;, and &lt;-&gt;.</p></li><li><p>leteral:     p or ¬p (p is proposition letter)</p></li><li><p>opposite leteral : l 上面一个横杠</p></li><li><p>clause: A clause is an expression l1 v l2 v· · · ∨ k , where the li are<br>literals.   ep: p1 ∨ ¬p2 ∨ p3</p></li></ul><p>P &#x3D; {p1, p2, . . .}</p><p>• every element of P is a formula</p><p>• if ϕ1 and ϕ2 are formulas, then so are</p><p>(¬ϕ1), (ϕ1 ∨ ϕ2), (ϕ1 ∧ ϕ2), (ϕ1 → ϕ2)</p><h2 id="assignment"><a href="#assignment" class="headerlink" title="assignment"></a>assignment</h2><p>• An assignment is a function θ : P → {T, F}.</p><p>• we extend θ to formulas by setting</p><p>θ(¬ϕ1) &#x3D; T iff ϕ1 &#x3D; F</p><h2 id="satisfiable"><a href="#satisfiable" class="headerlink" title="satisfiable"></a>satisfiable</h2><p>• A formula ϕ is satisfiable if there exists an assignment θ such<br>that θ(ϕ) &#x3D; T.</p><ul><li>set of clauses : there exists an assignment θ such that θ(γ) &#x3D; T for all γ ∈ Γ.</li></ul><h2 id="PROPOSITIONAL-SAT"><a href="#PROPOSITIONAL-SAT" class="headerlink" title="PROPOSITIONAL SAT"></a>PROPOSITIONAL SAT</h2><p>NP time </p><p>Given: a propositional logic formula ϕ;</p><p>Return: Yes if ϕ is satisfiable, and No otherwise.</p><h2 id="SAT"><a href="#SAT" class="headerlink" title="SAT"></a>SAT</h2><center><img src="/2022/11/07/%E7%AE%97%E6%B3%955/1.jpeg" width="400" height="200"> <br></center><h1 id="Integer-Linear-Programming"><a href="#Integer-Linear-Programming" class="headerlink" title="Integer Linear Programming"></a>Integer Linear Programming</h1><p>Cramer’s rule </p><p>Ax &#x3D; b with det(A) !&#x3D; empty</p><p>xi &#x3D; det(Ai) &#x2F; det(A)</p><p>Ai is the result of replacing the ith column of A by b</p><p>｜det(A)｜ &lt;&#x3D; $2^nM^n$</p><p>no matter how many veribles（non-zero value） -&gt; still small.</p><p>LP-feasibility is NPTIME 并 co-NPTIME</p><p>P-feasibility is P-TIME</p><p>$Ax &#x3D; b   x&gt;&#x3D;b$</p><p>$x^T (A^Ty) &#x3D; b^T y$</p><p>$（&gt;&#x3D;0 &gt;&#x3D;0 &lt;0)$ 为什么这里第一个0没有下划线</p>]]></content>
    
    
    
    <tags>
      
      <tag>36111</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ux star 总结</title>
    <link href="/2022/11/04/ux-star-%E6%80%BB%E7%BB%93/"/>
    <url>/2022/11/04/ux-star-%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h2 id="Star硬件上的设施"><a href="#Star硬件上的设施" class="headerlink" title="Star硬件上的设施"></a>Star硬件上的设施</h2><p>1981年4月，施乐公司宣布推出8010明星信息系统，这是一款为办公室设计的新型个人电脑。它由一个处理器、一个大显示屏、一个键盘和一个光标控制装置组成（见照片1），是为处理信息的商业专业人士设计的。</p><p>Star是一个多功能系统，结合了文件创建、数据处理和电子归档、邮寄和打印。文档创建包括文本编辑和格式化、图形编辑、数学公式编辑和页面布局。数据处理涉及同质化的关系型数据库，可以在用户控制下进行分类、过滤和格式化。归档是利用以太网局域网络的网络服务的一个例子（见参考文献9和13）。文件可以存储在工作站的磁盘上、工作站网络上的文件服务器上或不同网络上的文件服务器上。邮件允许工作站的用户相互通信。打印利用激光驱动的光栅打印机，能够同时打印文本和图形。</p><p>正如Jonathan Seybold所写，”这是一个非常不同的产品。不同的是，它真正连接了文字处理和排版功能；不同的是，它比之前的任何产品都具有更广泛的功能；不同的是，它向商业市场引入了人类工程中的全新概念。(见参考文献15)。</p><h2 id="明确以用户为宗旨设计系统"><a href="#明确以用户为宗旨设计系统" class="headerlink" title="明确以用户为宗旨设计系统"></a>明确以用户为宗旨设计系统</h2><p>我们从Star中学到了在编写软件之前制定基本概念（用户的概念模型）的重要性，而不是事后再加上一个用户界面。</p><p> One of the most troublesome and least understood aspects of interactive systems is the user interface.</p><p>交互式系统中最麻烦和最不被理解的方面之一是用户界面。在用户界面的设计中，我们关注几个问题：提供用户可以向计算机表达他们的命令的语言；设计向用户显示系统状态的显示方式；以及其他影响用户对系统行为理解的更抽象的问题。这些问题中的许多都是非常主观的，因此经常以一种临时的方式来解决。然而，我们相信，可以开发出更加严格的用户界面设计方法…</p><p>这些设计方法都不尽如人意，其基本原因是：它们都忽略了设计任何成功的用户界面之前的一个重要步骤，即任务分析。我们指的是在引入拟议的计算机系统之前，对用户执行的任务进行分析。任务分析包括确定谁是用户，他们执行任务的目标是什么，他们在执行任务时使用什么信息，他们产生什么信息，以及他们使用什么方法。对输入和输出信息的描述应该包括对用户使用的各种对象或个别类型的信息实体的分析。</p><p>有些类型的概念对人们来说本来就很难掌握。在不太正式的情况下，我们在Star设计之前和期间的经验使我们得出以下分类。</p><p>EasyHard<br>concreteabstract<br>visibleinvisible<br>copyingcreating<br>choosingfilling in<br>recognizinggenerating<br>editingprogramming</p><h2 id="设计目标"><a href="#设计目标" class="headerlink" title="设计目标"></a>设计目标</h2><pre><code class="hljs">familiar user’s conceptual modelseeing and pointing versus remembering and typingwhat you see is what you getuniversal commandsconsistencysimplicitymodeless interactionuser tailorability</code></pre><h3 id="familiar-user’s-conceptual-model"><a href="#familiar-user’s-conceptual-model" class="headerlink" title="familiar user’s conceptual model"></a>familiar user’s conceptual model</h3><p>物理办公室</p><p>让用户不感觉陌生，方便学习。</p><p>虽然我们希望与物理世界进行类比以获得熟悉感，但我们并不希望将自己限制在其能力范围内。星际的存在理由之一是，实物并不能为人们提供足够的力量来管理 “信息时代 “日益增长的复杂性。例如，我们可以利用计算机快速搜索的能力，为其电子文件抽屉提供搜索功能，从而帮助解决长期存在的文件丢失问题。</p><h3 id="Desk"><a href="#Desk" class="headerlink" title="Desk"></a>Desk</h3><p>你可以把文件无限期地留在你的桌面上，就像在一个真正的桌子上一样，或者你可以把它们归入文件夹或文件抽屉。</p><p>Star的原则和 “通用 “命令（将在下文中讨论）被应用于整个系统，使得在一个领域学到的经验可以应用于其他领域。<br>物理办公室的模式提供了一个简单的基础，在此基础上，学习可以以渐进的方式进行。你不会一下子接触到全新的概念。你的大部分现有知识都被嵌入到这个基础中。</p><p>例如，Star的记录处理设施不能使用物理办公室模型，因为物理办公室没有名副其实的 “记录处理”。因此，我们发明了一种不同的模式，即把记录文件作为字段的集合。一条记录可以显示为表格中的一行，也可以显示为表格中填入的字段。查询是通过在记录的空白例子中填写描述所需值的谓词来完成的，这在哲学上类似于Zloof的 “逐例查询”（见参考文献21）。</p><h3 id="Seeing-and-Pointing"><a href="#Seeing-and-Pointing" class="headerlink" title="Seeing and Pointing"></a>Seeing and Pointing</h3><p>一个设计良好的系统会让所有与任务相关的东西都在屏幕上显示出来。它不会把东西藏在CODE+键的组合下，也不会强迫你记住惯例。那会给你的记忆带来负担。</p><p>在Star中，我们努力使系统中的对象和行动都是可见的</p><p>属性表可以被认为是对象的另一种表现形式。屏幕向你显示对象的可见特征，如文本字符的字体或图标的名称。属性表向你展示了对象的底层结构，因为它们使这种结构变得可见和可访问。</p><h3 id="What-You-See-Is-What-You-Get"><a href="#What-You-See-Is-What-You-Get" class="headerlink" title="What You See Is What You Get"></a>What You See Is What You Get</h3><p>“所见即所得”（或称所见即所得）指的是显示屏幕准确呈现印刷页面的情况。在具有多字体和可变行距等功能的系统中，”所见即所得 “要求使用位映射显示器，因为只有这样才有足够的图形能力来准确呈现这些特性。</p><p>所见即所得 “是文档创建系统的一种简化技术。所有的构图都在屏幕上完成。它消除了困扰文档编译器用户的反复操作。你可以在屏幕上检查一个页面的外观，并进行修改，直到它看起来是正确的。</p><h3 id="universal”-or-“generic”-commands"><a href="#universal”-or-“generic”-commands" class="headerlink" title="universal” or “generic” commands"></a>universal” or “generic” commands</h3><p> MOVE, COPY, DELETE, SHOW PROPERTIES, COPY PROPERTIES, AGAIN, UNDO, and HELP.</p><p> 无论选择什么类型的对象，每个命令的执行方式都是一样的</p><p> 每条命令都能满足各种需要，这意味着需要的命令较少。这种简单性本身是可取的，但它还有一个微妙的优势：它使用户很容易形成系统的模型。人们可以使用他们理解的东西。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs"><br>就像科学的进步来自于简单、清晰的理论一样，计算机可用性的进步也将取决于简单、清晰的用户界面。<br><br></code></pre></td></tr></table></figure><p>许多简化来自于Star的面向对象的界面。设置属性的动作也取代了无数的命令。例如，改变段落的边距在许多系统中是一个命令。在Star，你可以通过选择一个段落对象并设置其MARGINS属性来实现。(关于面向对象语言的更多信息，请参见1981年8月的BYTE）。-</p><h3 id="consistency"><a href="#consistency" class="headerlink" title="consistency"></a>consistency</h3><p>一致性主张机制在任何地方都应该以相同的方式使用。例如，如果鼠标左键被用来选择一个字符，那么同样的按钮也应该被用来选择一个图形线或一个图标。每个人都同意，一致性是一个令人钦佩的目标。然而，这也许是计算机系统中最难实现的一个特性。事实上，即使在中等复杂度的系统中，一致性也可能没有很好的定义。</p><p>第一种方案的一致性论证如下：当你把一个图标移到一个外箱时，系统会把它寄出，然后从你的桌面上删除它。当你把一个图标移到文件抽屉里时，系统会把它归档，然后从你的桌面上删除它。因此，当你移动一个图标到打印机时，系统应该打印它，然后从你的桌面上删除它。功能图标之间的行为应该是一致的。</p><p>第二种选择的一致性论据是：用户在桌面层面的概念模型是物理办公室的隐喻。图标的行为应该与它们的物理对应物类似。图标在被邮寄后被删除是有道理的，因为当你把一张纸放在一个物理的邮筒里，邮递员把它捡起来后，它就不见了。然而，打印机的物理模拟物是办公室的复印机，当你复制一张纸的时候，并没有删除它的概念。功能图标的行为应该与它们的物理对应物一致。</p><h3 id="Simplicity"><a href="#Simplicity" class="headerlink" title="Simplicity"></a>Simplicity</h3><p>在Star，我们试图遵循Alan Kay的格言：”简单的事情应该是简单的；复杂的事情应该是可能的”。为了做到这一点，有时有必要以不常见的事物更难为代价，使常见的事物变得简单。简洁性，就像一致性一样，不是一个明确的原则。</p><ol><li>使一个系统显得简单的方法之一是使其统一和一致，正如我们前面讨论的那样。</li><li>另一个实现简单的方法是尽量减少系统中的冗余度。有两种或更多的方法来做一件事会增加复杂性，而不会增加能力。</li></ol><p>一般来说，最好是引入新的通用机制，让 “专家 “可以获得加速器，而不是增加很多特殊的、只有一个用途的功能。Star的机制将在下面的 “用户可定制性 “中讨论。</p><h3 id="modeless-interaction"><a href="#modeless-interaction" class="headerlink" title="modeless interaction"></a>modeless interaction</h3><p>Star使用的一些光标形状来表示系统的状态</p><p>传统的交互式太过于强烈。文件的全部内容都被字母 “t “所取代。这说明了一个问题，也许是太强烈了，模式应该被谨慎地引入用户界面，如果有的话。</p><h3 id="Usr-Tailorability"><a href="#Usr-Tailorability" class="headerlink" title="Usr Tailorability"></a>Usr Tailorability</h3><p>无论一个系统有多么普遍或强大，它都不会满足所有的潜在用户。人们总是希望有办法加快经常执行的操作的速度。然而，每个人都是不同的。唯一的解决办法是在设计系统时，将用户可扩展性的规定内置其中。以下是Star提供的机制。</p><pre><code class="hljs">你可以通过各种方式定制你的系统的外观。最简单的是选择你想在桌面上使用的图标，从而定制你的工作环境。在更复杂的层面上，可以购买带有或不带有某些功能的工作站。例如，不是每个人都想拥有方程式设施。施乐公司将此称为 &quot;产品保理&quot;。</code></pre><p>你可以用文本、段落和页面布局的默认值来设置空白文件。</p><p>你可以通过改变文件抽屉和文件夹的分类顺序来定制你的归档系统。</p><p>你可以通过定义任何数量的 “视图 “或它们来定制你的记录文件。</p><p>你可以通过用CUStomer编程语言CUSP编写程序来定义 “元操作”。</p><p>每个用户都有一个用于识别系统的唯一名称，通常是用户的全名。</p><h3 id="summary"><a href="#summary" class="headerlink" title="summary"></a>summary</h3><p>在20世纪80年代，影响计算机使用普及程度的最重要因素将是降低成本、增加功能、改善可用性和服务，以及也许是最重要的，用户界面设计方面的进展。仅仅前三个因素是必要的，但还不足以实现广泛的使用。降低成本可以使人们购买计算机，但改进的用户界面可以使人们使用计算机。在这篇文章中，我们提出了一些原则和技术，希望能带来更好的用户界面。</p><p>用户界面设计仍然是一门艺术，而不是一门科学。在Star的设计过程中，很多时候我们都对用户界面问题的深度和微妙性感到惊讶，甚至连一致性和简单性这样所谓的直接问题也是如此。通常没有一个 “正确 “的答案。很多时候，没有科学的证据来支持一种选择而不是另一种，只有直觉。几乎总是存在着权衡。也许在这十年结束时，用户界面设计将成为一个更加严格的过程。我们希望我们已经为这个进步做出了贡献。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>graphic 4-5</title>
    <link href="/2022/11/03/graphic-4-5/"/>
    <url>/2022/11/03/graphic-4-5/</url>
    
    <content type="html"><![CDATA[<h1 id="simulation"><a href="#simulation" class="headerlink" title="simulation"></a>simulation</h1><h2 id="rigid-body-simulation"><a href="#rigid-body-simulation" class="headerlink" title="rigid body simulation"></a>rigid body simulation</h2><h4 id="6DOF"><a href="#6DOF" class="headerlink" title="6DOF"></a>6DOF</h4><p> 3个用于物体中心点的xyz轴，3个用于xyz三个轴的旋转角度</p><h4 id="常见词汇"><a href="#常见词汇" class="headerlink" title="常见词汇"></a>常见词汇</h4><ul><li>Force and torque: 力与扭力</li><li>Impulse-based collisions: 计算速度用的动量</li><li>Rest in contact: 碰撞过程中需要等待一下</li><li>Stacking: 两个物体之间如果任何一个物体收到很小的影响，物体之间发生了变化</li></ul><h2 id="articulated-（关节）"><a href="#articulated-（关节）" class="headerlink" title="articulated （关节）"></a>articulated （关节）</h2><p>articulated rigid body simulation</p><p>两块骨头&#x2F;中间链接的部分叫做： joint constraint</p><p>原本两块骨头分别6个DOF。但可以通过以下两种方式减少DOF。</p><ol><li>由于链接，在一个面，所以关节处-2个rotate。</li><li>因为链接，一个物体必定在另一个末端，所以关节-3个坐标点。</li></ol><p>总体来说12-5 &#x3D; 7 个。</p><p>例子： 人的骨头，车的轮子。。。etc</p><h2 id="Finite-Element-Method-FEM"><a href="#Finite-Element-Method-FEM" class="headerlink" title="Finite Element Method (FEM)"></a>Finite Element Method (FEM)</h2><p>一个模型，处理受损物体的。</p><p>Tetrahedralization(四面体)</p><p>把物体变成很多四面体。</p><p>rest shape。  deformed shape。</p><p>deformed shape 可以通过 FEM 变成rest shape。</p><h2 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h2><p>Mass-Spring System.</p><p>Particle-Based Fluid Simulation.</p><p>Grid-Based Fluid Simulation.</p><p>Hybrid Fluid Simulation.</p><h1 id="Collisions"><a href="#Collisions" class="headerlink" title="Collisions"></a>Collisions</h1><p>position velocity age color.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-笔记3</title>
    <link href="/2022/10/09/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B03/"/>
    <url>/2022/10/09/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B03/</url>
    
    <content type="html"><![CDATA[<h1 id="flow-network"><a href="#flow-network" class="headerlink" title="flow network"></a>flow network</h1><center><img src="/2022/10/09/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B03/1.jpeg" width="400" height="200"> <br></center><p>The quantity f (e) is called the flow of edge e.</p><center><img src="/2022/10/09/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B03/2.jpeg" width="400" height="200"> <br></center><h4 id="flow"><a href="#flow" class="headerlink" title="flow"></a>flow</h4><center><img src="/2022/10/09/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B03/3.jpeg" width="400" height="200"> <br></center><ol><li>除了s和t，所有的节点进入等于出去，比如 v3： 1+2+1 &#x3D; 2 + 2 </li><li>[f]&#x3D;10的意思就是s发出了10，t接受了10。</li></ol><h4 id="maximum-flow"><a href="#maximum-flow" class="headerlink" title="maximum flow"></a>maximum flow</h4><center><img src="/2022/10/09/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B03/4.jpeg" width="400" height="200"> <br></center><p>这种使用flow network 更加有效率。</p><h2 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h2><h2 id="Ford-Fulkerson-algorithm"><a href="#Ford-Fulkerson-algorithm" class="headerlink" title="Ford-Fulkerson algorithm"></a>Ford-Fulkerson algorithm</h2><p>求解maximum flow的方法。采用了贪婪。但只采用贪婪得不到最优解，会在图右边堵住。</p><ul><li>优化方法：把边（无论满没满）往两侧推，推到那些有空余的边上。也就是： 可以在有剩余容量的边上正向增加，并在已经承载了流量的边上反向增加，以将其分流到不同的方向。</li></ul><center><img src="/2022/10/09/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B03/5.jpeg" width="400" height="200"> <br></center><h2 id="Maximum-Bipartite-Matching"><a href="#Maximum-Bipartite-Matching" class="headerlink" title="Maximum Bipartite Matching"></a>Maximum Bipartite Matching</h2><p>一个两个集合一一对应的图。</p><center><img src="/2022/10/09/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B03/6.jpeg" width="400" height="200"> <br></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ux</title>
    <link href="/2022/10/09/ux/"/>
    <url>/2022/10/09/ux/</url>
    
    <content type="html"><![CDATA[<h1 id="week-3"><a href="#week-3" class="headerlink" title="week 3"></a>week 3</h1><p>参与收集数据以形成对系统或界面应该如何工作的理解。不管个人项目的重点是什么，用户体验专家主要关注的是人以及他们与计算系统的互动方式。</p><p>理解人类如何接受信息、理解并从这些信息中学习，并利用这些信息来指导他们对外界的控制，是理解人类经验的关键[Weinschenk, 2011]（见图中的PET扫描：葡萄糖代谢的PET研究）。在这里，我们并不直接关注这些过程的解剖学、生理学或心理学方面（有许多深入的论述涉及这些领域），而是从用户与软件或设备的结合点来看待它们。在这种情况下，我们可以简单地认为，人类感觉和感知外部环境（系统或界面），处理和存储这些知识，直接或在未来使用这些知识。此外，基于过去和当前的知识，对外部环境（同样，在这种情况下，系统或界面）施加控制[Bear等人，2007]。</p><h2 id="Inattention-blindness-amp-amp-attention-blindness"><a href="#Inattention-blindness-amp-amp-attention-blindness" class="headerlink" title="Inattention blindness &amp;&amp; attention blindness"></a>Inattention blindness &amp;&amp; attention blindness</h2><p>那么，这个现象只是理解用户、他们的感知和他们的注意力所涉及的复杂性的一个例子。这种现象被称为 “注意力盲”、”注意盲 “或 “感知盲”，与我们的期望、感知和注意力的位置有关。简单地说，”不注意盲 “描述的是我们注意到在明处且已被看到的东西的能力。这通常发生在我们不期望刺激物发生的时候–为什么大猩猩会在篮球比赛中进行月球漫步？如果我们认为它不应该在那里，我们的大脑就会通过不在认知上登记该刺激物来补偿知觉输入。然而，有很多其他的测试也显示了这种现象。此外，对于为什么会出现这种现象，也有一些不同的解释。正如你刚刚读到的，我更喜欢 “期望 “的解释，但其他人建议：显眼性，刺激物可能是不显眼的，因此不被视为重要。心理负荷，我们可能忙于关注另一项任务而没有注意到一个刺激，或者说这确实是注意力位置的解释；正如我们将在后面看到的。在现实中，我希望每一种解释都有一些组合在起作用，但问题是，这种现象本身并不是我们所期望的，而且我们并不确切知道它为什么或如何发生。当你阅读更多的内容，当你开始在用户体验领域工作时，请记住这种不确定性的程度。</p><h2 id="visual-channel"><a href="#visual-channel" class="headerlink" title="visual channel"></a>visual channel</h2><p>视觉交互设计是由界面上的元素或细节的安排决定的，这些元素或细节可以通过现有的资源促进或阻碍用户。这是因为界面内到达我们眼睛的信息量远远大于我们的大脑所能处理的信息量，正是由于这个原因，视觉通道，也就是视觉注意力是好设计的关键。</p><p>通过对视觉通道的理解，我们可以看到与视觉设计相关的颗粒度的水平。这种颗粒度使我们能够通过分割成更小的、更容易管理的片段或组件来理解一个大的视觉效果图。我们的注意力根据我们的视觉注意力与这些组件的关系在这些组件之间移动，正是这种关于视觉通道如何运作的知识，作为设计的最佳实践，使设计师能够建立起用户觉得有趣和容易使用的界面。设计师为观察者建立的视觉叙事是由每个视觉组件的视觉外观（以及，因此，吸引力）暗中创造的。观察者的注意力，或者说我们将看到的注意力的位置，使得这种视觉叙事能够被讲述。</p><h4 id="Selective-visual-attention"><a href="#Selective-visual-attention" class="headerlink" title="Selective visual attention"></a>Selective visual attention</h4><p>由大脑中的意识和潜意识过程组成，用来快速有效地寻找和关注相关信息。有两个一般的视觉注意过程，即自下而上和自上而下，它们决定了人类下一步将注意力放在哪里。自下而上的视觉注意模型表明，低层次的突出特征，如对比度、大小、形状、颜色和亮度与视觉兴趣有很大的关联。例如，一个红苹果（营养的来源）在视觉上比它周围的绿叶更突出，因此也更有吸引力。另一方面，自上而下的模型解释了由语义或关于环境的知识驱动的视觉搜索：例如，当被要求描述图片中一个人的情绪时，人们会自动看向这个人的脸。</p><h4 id="Bottom-up-processing"><a href="#Bottom-up-processing" class="headerlink" title="Bottom-up processing"></a>Bottom-up processing</h4><p>自下而上的处理方式使人们能够迅速地发现一些项目，如粗体字和图片，这有助于解释界面的组织方式。它还能帮助人们将信息分为 “部分”，如文本块、标题和菜单。</p><h4 id="Top-down-processing"><a href="#Top-down-processing" class="headerlink" title="Top-down processing"></a>Top-down processing</h4><p>自上而下的处理方法使人们能够利用已有的知识和启发式方法来解释信息。例如，人们可能会在界面的顶部和两侧寻找菜单，而在中间寻找主要的界面组件。</p><h4 id="gaze-hotspots"><a href="#gaze-hotspots" class="headerlink" title="gaze hotspots"></a>gaze hotspots</h4><p>从眼动研究中可以看出，用户的注意力会依次集中在界面的不同部分，计算机图形学中已经成功地采用了计算模型，将图像分割成用户最可能关注的区域。这些模型是基于对人类视觉行为的了解和对有关图像的理解。事实上，有一些研究记录了用户在特定的交互任务中的眼球运动，以找出界面设计中那些被访问的特征，其顺序和 “凝视热点 “被发现的地方。在这些数据中，我们可以看到界面组件和眼睛注视之间的关联，但不是 “用户看了视觉上最明显的界面特征 “这样简单。事实上，有时候，在一个吸引人注意的特征（如图片）旁边的大字体也会被固定下来。然而，我们可以推断出，比如说，一些文字中的信息本身可能并不能吸引用户的注意力，但最好是附近有一些特征可以吸引用户的注意力。这一观点得到了其他研究的支持，这些研究试图建立界面设计指标来预测一个界面在视觉上是否复杂。这些研究与界面设计的复杂性有关，解释了交互被感知的方式取决于界面本身的设计方式和所使用的组件。</p><h2 id="Auditory-channel"><a href="#Auditory-channel" class="headerlink" title="Auditory channel"></a>Auditory channel</h2><p>听觉渠道是信息输入的第二大渠道，与视觉渠道高度相关，然而，听觉输入有一些经常被忽视的优势。例如，在某些情况下，对听觉刺激的反应要比对视觉刺激的反应快。其次，使用听觉信息可以在一定程度上减少屏幕上的视觉信息量。在某种程度上，这减少了来自界面组件和目前正在进行的交互方面的可能的信息过载。视觉需求的减少意味着注意力可以被释放到最好的视觉处理的刺激上，也意味着听觉刺激可以被定制到最适合的互动部分。</p><h4 id="drawback-of-auditory-channel-and-solution"><a href="#drawback-of-auditory-channel-and-solution" class="headerlink" title="drawback of auditory channel and solution"></a>drawback of auditory channel and solution</h4><p>事实上，与标准的界面组件相比，听觉通道往往使用不足。在某些情况下，这是由于需要在环境中不存在噪音污染的缘故。我们可以看到，在同一个大环境中，一致的声音或断断续续的声音往往会让计算机用户感到沮丧和分心；而对于可以专门针对主要用户的视觉刺激来说，情况并非如此。最后，在某些情况下最重要的是，声音可以移动用户的注意力，并将其集中到一个特定的空间位置。由于人类听觉处理系统的性质，研究发现，使用类似于白噪声的不同频率在吸引注意力方面是最有效的。这是因为人类的语言和交流是使用多种频率进行的，而单一频率的转换，如警报器或可听音调，不会使人感到不安，但更难在空间上定位。</p><h4 id="Earcons"><a href="#Earcons" class="headerlink" title="Earcons"></a>Earcons</h4><p>非语音听觉输入的一个更有趣的方面是听觉图标和 “Earcons”。目前，许多系统都有某种听觉图标，例如，从特定目录中删除文件时，往往伴随着用来表达删除的声音，如纸张被揉碎。耳朵图标稍微复杂一些，因为它们涉及到非语言音频信息的传输，向用户提供有关某种计算机对象、操作或互动的信息。与听觉图标相比，Earcons使用的是更传统的音乐方法，通常是由单独的短节奏序列构成，并以不同的方式组合。在这种情况下，听觉部分必须学习，因为Earcon和它所代表的内容之间没有直观的联系。</p><h2 id="Somatic"><a href="#Somatic" class="headerlink" title="Somatic"></a>Somatic</h2><p>体感一词涵盖了在环境中体验到的所有类型的物理接触，无论是感受表面的纹理还是力的冲击。触觉描述了用户在接触物体或其他用户时如何体验力或皮肤反馈。触觉交互可以作为提供输入和接收输出的手段，并被定义为 “个人通过使用其身体对其身体附近的世界的感受性”。触觉是由由覆盖在皮肤上的受体和大脑中的处理中心组成的各种感觉系统所产生的触觉刺激所驱动的，以产生触觉和温度等感觉模式。当感觉神经元被特定的刺激所触发时，神经元会传递到大脑中的一个区域，使经过处理的刺激在正确的位置被感觉到。因此，可以看出，使用触觉通道进行控制和反馈，特别是作为其他感官输入或输出的辅助手段，是很重要的。事实上，触觉和触觉的优势在于使互动看起来更真实，这也是触觉设备在虚拟和沉浸式环境中大量使用的原因。</p><h2 id="The-Olfactory-System"><a href="#The-Olfactory-System" class="headerlink" title="The Olfactory System"></a>The Olfactory System</h2><p>嗅觉系统使我们能够感觉到气味。因此，对于许多研究用户体验的人来说，可能会感到惊讶，因为已经有一些工作在研究使用气味作为一种与交互直接相关的感官输入形式（特别是来自[Brewster等人，2006]）。虽然这是一个研究不足的领域，但某些类型的界面可以使用气味来传达一个额外的支持成分，而不是一般的、更好理解的声音和视觉的刺激。嗅觉的主要好处之一是它与记忆有着密切的联系，在这种情况下，嗅觉可以被用来帮助用户找到他们已经去过的地点，或者在互动环境中认出他们已经去过的地点。事实上，似乎嗅觉和味觉[Narumi等人，2011]在与图像识别相关联时特别有效，并且可以以抽象的气味，或者代表特定线索的气味的形式存在。然而，作为一个UX’er，气味不太可能在你设计的系统中被大量使用，尽管如果你在用户忘记以前学过的交互方面有特别的问题时，记住气味可能是有用的。</p><h2 id="Explicit-and-Implicit-Communication"><a href="#Explicit-and-Implicit-Communication" class="headerlink" title="Explicit and Implicit Communication"></a>Explicit and Implicit Communication</h2><p>信息可以通过多种不同的方式传输，这些方式可以是隐式的（隐蔽的）或显式的（公开的）。在这种情况下，让我们将信息传输称为通信；将信息传达给用户，然后通过输入和控制机制将用户要求传回计算机。明确的交流通常被很好地理解，并且集中在文本和图像（或声音）的视觉或听觉传输以供用户消费。然而，隐式通信有点难以定义。在这种情况下，我指的是在某些方面是无形的视觉或听觉用户体验的那些方面。我的意思是诸如审美或情感反应 [Pelachaud, 2012] 等方面对交流的各个方面。</p><h4 id="explicit-commuication"><a href="#explicit-commuication" class="headerlink" title="explicit commuication"></a>explicit commuication</h4><p>沟通和复杂度密切相关，复杂度直接影响到用户和界面或系统之间沟通的便利性。沟通主要是通过界面的视觉布局和用户必须阅读的文字标签来进行的，以了解与他们的互动沟通。人们通过使用生硬的眼球运动（称为’Saccades’）来阅读文本，然后停止并固定在一个关键词上大约250毫秒。这些固定的动作各不相同，在更复杂的文本中持续的时间更长，而且集中在向前的固定上，当阅读变得更加困难时，倒退（向后）的固定只发生在10-15%的时间。人们在快速阅读时，通过扫描寻找适当的信息，往往固定的频率较低，时间较短。然而，他们只能记住所读信息的要点；而不能对所遇到的信息进行全面的论述（见图：视觉化文字）。这意味着，对于用户来说，在快速扫描一个互动功能时，对界面的全面描述并没有被用于用户的决策过程中。事实上，在浏览大型互动资源时，认知过载是一个关键问题。如果互动是非线性的，并且可能会意外地切换上下文，那么这种过载就会增加。通过摘要进行预览是提高用户在复杂界面中的认知的关键，但是复杂的提示也会使读者的不相干的信息过载。</p><h4 id="implicit-communication"><a href="#implicit-communication" class="headerlink" title="implicit communication"></a>implicit communication</h4><p>美学通常被定义为对美丽或愉悦的欣赏，但这个术语仍有争议。视觉美学是 “关于如何通过感官认识事物的科学”，指的是用户的感知和认知。具体来说，’美观的’界面通常被用来描述那些被用户认为是干净、清晰、有组织、漂亮和有趣的界面。这些术语只是描述美学的众多不同术语中的一个例子，这些术语在交互设计中普遍使用。人机交互工作大多强调性能标准，如学习时间、错误率和完成任务的时间，而较少关注美学。然而，用户体验工作试图扩大这种狭隘的（”还原论”）体验观，试图理解美学和情感如何影响观看者的感知–但是界面的美学表现和用户的交互之间的关系仍然没有被很好的理解。</p><p>最新的科学发现表明，情绪在决策、感知、学习等方面起着至关重要的作用–也就是说，它们影响着理性思维的机制。不仅是太多，而且太少的情绪都会损害决策[Picard, 1997]。这现在被称为 “情感计算”，其中生物识别仪器，如皮肤电泳反应（GSR），凝视分析和心率监测被用来通过用户的生理变化来确定其情感状态。此外，情感计算还寻求改变这些状态的方法，或者根据这些状态表现出对技术的控制。</p><h2 id="input-and-output"><a href="#input-and-output" class="headerlink" title="input and output"></a>input and output</h2><p>在讨论 UX 时，最后一个难题是输入信息以供计算机使用的能力。通常，这通常是通过使用与键盘和鼠标结合使用的 GUI 来完成的。然而，这还不是全部，确实有很多种入口设备可用于信息输入、选择和目标获取[Brand，1988]。在某些情况下，在其他凝视和眨眼检测中使用了专业设备，例如头部操作的鼠标，但是，在大多数情况下，鼠标和键盘将是事实上的组合。但是，作为 UX 工程师，您还应该了解可用的不同类型的设备以及它们之间的关系。通过这种方式，您将能够在指定非标准系统时做出准确和合适的选择。</p><h4 id="The-Written-word"><a href="#The-Written-word" class="headerlink" title="The Written word"></a>The Written word</h4><p>书面文字，草书，长期以来被视为将文本输入计算机系统的最自然方式。 因为它依赖于使用已经学过的技能。</p><h4 id="Pointing-Devices"><a href="#Pointing-Devices" class="headerlink" title="Pointing Devices"></a>Pointing Devices</h4><p>在大多数情况下，用于绘图和目标获取的指针设备由无处不在的鼠标处理。</p><h4 id="Text-entry"><a href="#Text-entry" class="headerlink" title="Text entry"></a>Text entry</h4><p>通过键盘输入文本是标准计算机系统的主要数据输入方式。</p><h4 id="Haptic-Interaction"><a href="#Haptic-Interaction" class="headerlink" title="Haptic Interaction"></a>Haptic Interaction</h4><p>触觉交互并没有在沉浸式或协作环境领域之外广泛使用。为了与虚拟世界进行触觉交互，</p><h4 id="Gesture-Recognition"><a href="#Gesture-Recognition" class="headerlink" title="Gesture Recognition"></a>Gesture Recognition</h4><p>手势识别最初被视为主要用于研究和学术调查的领域。然而，最近有两种产品改变了这种看法。其中第一个是流行的游戏机 Nintendo Wii，它使用游戏控制器作为手持指点设备，并检测三个维度的运动</p><h2 id="SUM-of-Week-3"><a href="#SUM-of-Week-3" class="headerlink" title="SUM of Week 3"></a>SUM of Week 3</h2><p>了解我们如何使用我们的感官：视觉（视觉通道）、听觉（听觉通道）、嗅觉（嗅觉通道）和触摸（触觉通道）使我们能够了解如何通过界面传达有关系统状态的信息。 对心灵自然过程的了解：注意力、记忆和学习、探索和导航、情感交流和复杂性以及美学，有助于理解我们传输的信息如何更好地适应用户的心理过程。 最后，了解输入和控制是如何制定的，可以让我们从多种输入设备中进行选择，这些输入设备可用于信息输入、选择和目标获取。 但是，我们必须记住，有许多不同类型的人，这些人有许多不同类型的感官或身体要求，在施工过程的各个阶段都必须考虑到这些要求。</p><h2 id="Digital-Phenotyping"><a href="#Digital-Phenotyping" class="headerlink" title="Digital Phenotyping"></a>Digital Phenotyping</h2><p>数字表型(Digital Phenotyping)是指 “利用个人数字设备（尤其是智能手机）的数据对个人层面的人类表型进行现场量化。</p><p>这些数据可以分为两个子组，即主动数据和被动数据，前者是指需要用户主动输入才能生成的数据，而被动数据，如传感器数据和手机使用模式，是在不需要用户主动参与的情况下收集的。</p><h2 id="User-Centred-Design"><a href="#User-Centred-Design" class="headerlink" title="User Centred Design"></a>User Centred Design</h2><p>在现实中，这意味着在开发任何软件之前都有一个很长的用户咨询期，这样设计者就可以更准确的表达这些用户的要求–”什么”。可以说，有许多不同的子风格，我现在称之为以用户为中心的设计（UCD），本节中列出的文本和标准是很好的第一步[9241-210:2010, 2010]。然而，有许多首要的问题和原则适合于它们，并且在某些方面可以不严格参照特定的UCD方法。作为一个训练有素的UX’er，你不应该死记硬背任何特定的方法，而是应该了解每一种方法的长处和短处，并在你目前的设计过程中选择最适合你具体要求的工具4。</p><h4 id="UCD-user-centred-design"><a href="#UCD-user-centred-design" class="headerlink" title="UCD (user centred design)"></a>UCD (user centred design)</h4><p>UCD代表了一套技术，使参与者能够在评估和设计过程中获得某种形式的所有权。人们通常认为，这些参与者在某种程度上对所调查的系统和过程有一定的了解，因此对整个组织所需要的系统和界面有一定的洞察力。UCD方法与 “大声思考 “协议密切相关，但不是完全专注于评估，而是鼓励用户根据他们对系统或界面的了解，扩大他们的观点，提出改进建议。事实上，我们鼓励参与者对提议的系统进行批评，以达到真正的要求。这意味着–在某些情况下–在用户体验设计开始之前就已经创建了一个系统设计，以便参与者有一个起点。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>game_note</title>
    <link href="/2022/10/05/game-note/"/>
    <url>/2022/10/05/game-note/</url>
    
    <content type="html"><![CDATA[<h1 id="Lecture-3"><a href="#Lecture-3" class="headerlink" title="Lecture 3"></a>Lecture 3</h1><h2 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition 2"></a>Definition 2</h2><ol><li>game of perfect information: 一个抉择树每个节点都有一个条件。也就是说任意玩家在任意时间都知道自己所在的位置。反之则是imperfect information。</li><li>zero-sum: 每一个叶子上所有用户的总和payoff是0。也就是说用户不会从中得到什么。</li><li>without chance： 节点没有被自然控制。 反之是game with chance。</li></ol><p>ep: 棋类是 2-person zero-sum games of perfect information without chance.<br>ep: Poker is a zero-sum1 game of imperfect information with chance.</p><h2 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition 3"></a>Definition 3</h2><p>fully specified strategy : 对一个特定的玩家，有多少种战略。把所有可能性走法加起来。</p><h4 id="Generating-all-strategies-for"><a href="#Generating-all-strategies-for" class="headerlink" title="Generating all strategies for"></a>Generating all strategies for</h4><ul><li><p>如果玩家i第一步先走的话： Ni(t) &#x3D; Ni(t1) + Ni(t2) + · · · + Ni(tn).</p></li><li><p>如果玩家i第一步后走的话： Ni(t) &#x3D; Ni(t1) × Ni(t2) × · · · × Ni(tn).</p></li></ul><h1 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h1><h2 id="Nash-Equilibrium"><a href="#Nash-Equilibrium" class="headerlink" title="Nash Equilibrium"></a>Nash Equilibrium</h2><h4 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h4><p>Definition: A strategy profile (s1,s2,s3…sk) for a game with k<br>players, is a Nash equilibrium if each strategy is a best<br>response to all of the others.</p><ul><li>It is not a strategy; it is a choice of strategy for all players in<br>the game.</li><li>If the players are playing the Nash, no player has any<br>incentive to change its strategy unilaterally</li></ul><h2 id="Mini-max-approach"><a href="#Mini-max-approach" class="headerlink" title="Mini-max approach"></a>Mini-max approach</h2><center><img src="/2022/10/05/game-note/2.jpeg" width="400" height="200"> <br></center><center><img src="/2022/10/05/game-note/3.jpeg" width="400" height="200"> <br></center><p>解释上图： </p><ol><li>寻找Amelia的min ， 1，2，3，1</li><li>寻找Scott的max， 7，3，5，6</li><li>找Amelia的min中的max 和 Scott的max中的min 的那个点。</li></ol><h2 id="Dominance"><a href="#Dominance" class="headerlink" title="Dominance"></a>Dominance</h2><center><img src="/2022/10/05/game-note/4.jpeg" width="400" height="200"> <br></center><h2 id="Dominance-can-be-used-to-eliminate-some-strategies"><a href="#Dominance-can-be-used-to-eliminate-some-strategies" class="headerlink" title="Dominance can be used to eliminate some strategies"></a>Dominance can be used to eliminate some strategies</h2><center><img src="/2022/10/05/game-note/5.jpeg" width="400" height="200"> <br></center><h2 id="mixed-strategies"><a href="#mixed-strategies" class="headerlink" title="mixed strategies"></a>mixed strategies</h2><p>A mixed strategy is a strategy for a player in which:</p><ul><li>I plays probabilistic combination of pure strategies;</li><li>I receives a probabilistic combination of payoffs</li></ul><h4 id="Extensive-form"><a href="#Extensive-form" class="headerlink" title="Extensive form"></a>Extensive form</h4><p>一个路径上有权重比例的树</p><p>At each node where the player has a<br>decision, assign a probability function to each<br>of the possible choices.</p><h4 id="con"><a href="#con" class="headerlink" title="con"></a>con</h4><ol><li>Only for a special class of games do strategies which beat<br>all opponents always exist (two-player, zero-sum, perfect<br>information, no chance).</li><li>A Nash equilibrium is a collection of strategies for all<br>players such that each player is playing best response to<br>all the others.</li><li>For a zero-sum, two-player game in normal form, a<br>strategy pair which is maximal in its columns and minimal<br>in its rows is a Nash equilibrium.</li><li>Dominance can be used to reduce the number of<br>strategies.</li><li>Nash equilibria also exist in general-sum games.</li></ol><h1 id="Week4"><a href="#Week4" class="headerlink" title="Week4"></a>Week4</h1><h2 id="The-minmax-rule"><a href="#The-minmax-rule" class="headerlink" title="The minmax rule"></a>The minmax rule</h2><p>• MAX nodes are trying to maximise the payoff to player 1.<br>• MIN nodes are trying to minimise the payoff to player 1.</p><p>The value V(J) of a node J is</p><ol><li>If J is a terminal node, V(J) is equal its payoff U(J).</li><li>If J is a MAX node, V(J) is the maximum value of its<br>children.</li><li>If J is a MIN node, V(J) is the minimum value of its<br>children.</li></ol><center><img src="/2022/10/05/game-note/1.jpeg" width="400" height="200"> <br></center><center><img src="/2022/10/05/game-note/2.jpeg" width="400" height="200"> <br></center><h3 id="suppose-multi-players"><a href="#suppose-multi-players" class="headerlink" title="suppose multi players"></a>suppose multi players</h3><p>Can not approach an equilibria : </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-笔记2</title>
    <link href="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/"/>
    <url>/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/</url>
    
    <content type="html"><![CDATA[<h1 id="fast-and-slow"><a href="#fast-and-slow" class="headerlink" title="fast and slow"></a>fast and slow</h1><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/1.jpeg" width="400" height="200"> <br></center><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/2.jpeg" width="400" height="200"> <br></center><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/3.jpeg" width="400" height="200"> <br></center><p>n! —&gt; singly  </p><ul><li>2^n &lt;&#x3D; n &lt;&#x3D; 2^n^2</li></ul><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/4.jpeg" width="400" height="200"> <br></center><h1 id="Ackermann-Function"><a href="#Ackermann-Function" class="headerlink" title="Ackermann Function"></a>Ackermann Function</h1><p>用来描述递归时间复杂度的方程。</p><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/5.jpeg" width="400" height="200"> <br></center><p>k-fold就是在表示递归，下图描述的更加直观。</p><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/7.jpeg" width="400" height="200"> <br></center><p>注意A3是大于等于，要推到A2才能算出精确值</p><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/6.jpeg" width="400" height="200"> <br></center><p>上面的推导过程</p><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/8.jpeg" width="400" height="200"> <br></center><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h4 id="The-Pattern-Matching-Problem"><a href="#The-Pattern-Matching-Problem" class="headerlink" title="The Pattern Matching Problem"></a>The Pattern Matching Problem</h4><p>找子字符串</p><p>Example 23.1: Suppose we are given the text string<br>T &#x3D; “abacaabaccabacabaabb”<br>and the pattern string P &#x3D; “abacab”<br>Then P is a substring of T . Namely, P &#x3D; T [10..15].</p><p>Σ :  alphabet</p><h2 id="Brute-Force-Pattern-Matching"><a href="#Brute-Force-Pattern-Matching" class="headerlink" title="Brute-Force Pattern Matching"></a>Brute-Force Pattern Matching</h2><p>暴力遍解 也叫 naive algorithm </p><p>Running time O(T*P)</p><p>T P 一个substring 一个 string</p><h2 id="Rabin-Karp-algorithm"><a href="#Rabin-Karp-algorithm" class="headerlink" title="Rabin-Karp algorithm"></a>Rabin-Karp algorithm</h2><p>先check substring的numbers 再check它是否匹配。</p><p>Worst-case Running time O(T*P)</p><p>O(n+m+m(n&#x2F;q))</p><ul><li>q: modulo (always prime)</li></ul><h2 id="The-Boyer-Moore-Algorithm"><a href="#The-Boyer-Moore-Algorithm" class="headerlink" title="The Boyer-Moore Algorithm"></a>The Boyer-Moore Algorithm</h2><p>相比于暴力遍解，只需要加两个启发式。</p><ul><li><p>Looking-Glass Heuristic: 当第一个字节匹配，我们也同时检测最后一个substring是否匹配。</p></li><li><p>Character-Jump Heuristic: 如果string中有一个字符substring都不存在，直接跳到这个字符串后面。</p></li></ul><h4 id="Worst-Case-Analysis-of-the-Boyer-Moore-Algorithm"><a href="#Worst-Case-Analysis-of-the-Boyer-Moore-Algorithm" class="headerlink" title="Worst-Case Analysis of the Boyer-Moore Algorithm"></a>Worst-Case Analysis of the Boyer-Moore Algorithm</h4><p>The worst-case running time of the BM algorithm is O(nm + |Σ|). Namely, the computation of the last function takes time O(m + |Σ|) and the actual search for the pattern takes O(nm) time in the worst case, the same as the brute-force algorithm. An example of a text-pattern pair that achieves the worst case is</p><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/9.jpeg" width="400" height="200"> <br></center><p>这个方法的shift不是很好。所以有下面方法。</p><h2 id="Knuth-Morris-Pratt-Algorithm"><a href="#Knuth-Morris-Pratt-Algorithm" class="headerlink" title="Knuth-Morris-Pratt Algorithm"></a>Knuth-Morris-Pratt Algorithm</h2><p>KMP 是线性复杂度。</p><p>longest prefix of the good prefix is also a proper suffix of the good prefix 。</p><p>增添回溯的Boyer-Moore Algorithm。不像之前一个个字符的判断。而类似于贪婪，检测substring和string的匹配关系直到遇到不匹配的字符。通过咨询失败函数来判断新的索引。</p><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/10.jpeg" width="400" height="200"> <br></center><h4 id="compute-π："><a href="#compute-π：" class="headerlink" title="compute π："></a>compute π：</h4><p> Using a similar reasoning, the running time of compute-π(P)<br>is O(|P|).</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">begin naiveCompute-π(P)<br>π(<span class="hljs-number">0</span>) ← <span class="hljs-number">0</span><br><span class="hljs-type">for</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> to |P| − <span class="hljs-number">1</span><br>π(i) ← −<span class="hljs-number">1</span> <br><span class="hljs-type">for</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> to |P| − <span class="hljs-number">1</span><br>j ← <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i + j &lt; |P| and P[i + j] = P[j]<br><span class="hljs-keyword">if</span> π(i + j) = −<span class="hljs-number">1</span><br>π(i + j) ← j + <span class="hljs-number">1</span><br><span class="hljs-type">if</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>π(i) ← <span class="hljs-number">0</span><br>j ← j + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><h4 id="remove-unnecessary-shifts"><a href="#remove-unnecessary-shifts" class="headerlink" title="remove unnecessary shifts"></a>remove unnecessary shifts</h4><center><img src="/2022/10/03/%E7%AE%97%E6%B3%95-%E7%AC%94%E8%AE%B02/11.jpeg" width="400" height="200"> <br></center><p>better: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">begin naiveCompute-π(P)<br>π(<span class="hljs-number">0</span>) ← <span class="hljs-number">0</span><br><span class="hljs-type">for</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> to |P| − <span class="hljs-number">1</span><br>π(i) ← −<span class="hljs-number">1</span><br>i ← <span class="hljs-number">1</span><br>j ← <span class="hljs-number">0</span><br><span class="hljs-keyword">while</span> i &lt; |P|<br><span class="hljs-keyword">while</span> i + j &lt; |P| and P[i + j] = P[j]<br><span class="hljs-keyword">if</span> π(i + j) = −<span class="hljs-number">1</span> <span class="hljs-comment">// match</span><br>π(i + j) ← j + <span class="hljs-number">1</span><br>j ← j + <span class="hljs-number">1</span><br><span class="hljs-keyword">if</span> j &gt; <span class="hljs-number">0</span> <span class="hljs-comment">// mismatch</span><br>i ← i + j − π(j); j ← π(j)  <br><span class="hljs-keyword">else</span><br>π(i) ← <span class="hljs-number">0</span>; i ← i + <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>线性复杂度的原因是在循环之中不是 i 就是i+j increases。</p><p>The running time of KMP(T,P) (ignoring the construction of π is O(|T|).</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>NeRF论文总结</title>
    <link href="/2022/10/02/NeRF%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <url>/2022/10/02/NeRF%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1"><a href="#1" class="headerlink" title="1"></a>1</h1><p>NeRF: Representing Scenes<br>as Neural Radiance Fields<br>for View Synthesis</p><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>通过优化底层的连续体积场景函数来合成复杂场景的新视图。</p><p>在这项工作中，我们以新的方式解决了长期存在的视图合成问题。</p><ul><li>视图合成是指从一组给定的输入图中渲染场景的新视图的问题和它们各自的相机姿势来渲染场景的新视图。从新的视角产生逼真的输出需要正确处理复杂的几何形状和材料反射属性。</li></ul><p>之前提及过很多方案，但这是第一次实现。</p><h4 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h4><p> 提出了第一个continuous neural scene(连续的神经场景表征)，能够从在自然环境中捕获的RGB图像中呈现出高分辨率的逼真的真实物体和场景的新观点。自然环境中捕获的RGB图像，呈现出真实物体和场景的高清晰度的新观点。</p><h4 id="怎么做："><a href="#怎么做：" class="headerlink" title="怎么做："></a>怎么做：</h4><p>我们将一个静态场景表示为一个连续的5D函数输出每个方向(θ, φ)上的辐射度。在空间的每个点（x，y，z）的辐射度，以及每个点的密度。在每一点上的密度就像一个不透明度，它控制着通过(x, y, z)的光线所积累的辐射量。<br>我们的方法优化了一个没有任何卷积层的深度全连接神经网络通过回归来表示这个函数。<br>从一个单一的5D坐标（x，y，z，θ，φ）到一个单一的体积密度和取决于视图的RGB颜色。</p><p>为了生成一个特定视角的NERF。做法以下步骤：</p><ol><li>将相机光线穿过场景，生成一个采样后的神经辐射场。</li><li>使用这些点和它们相应的2D viewing directions 作为神经网络的输入，产生一组颜色和密度的输出。这些密度累积起来也就是一个视角的二维图像。</li><li>因为有些观测不到，所以优化。用梯度下降法。</li><li>神经网络模型并没有收敛到我们想要的分辨率。我们通过对输入的5D坐标进行位置编码来解决这个问题，从而使MLP能够表示更高的频率函数。</li></ol><p>note: 后两点是在模型提出之后作者引用自己在reference 13 中进行对神经网络场的改进。</p><h4 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h4><p>其输入是一个单一的连续5D坐标:</p><ul><li>(spatial location (x, y, z) and viewing direction (θ, φ))</li><li>换句话说也就是一组已知相机姿态的图像和摄像机的位置</li></ul><h4 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h4><p>其输出是体积密度和视图。</p><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><p>通过沿相机射线查询5D坐标来合成视图，并使用经典的体积渲染技术来投射输出。</p><p>描述了如何有效地优化神经辐射场来渲染具有复杂几何和外观的场景的逼真的新观点。<br>描述了如何有效地优化neural radiance fields，以呈现具有复杂几何形状和外观的场景的逼真的新观点。</p><p>和其他现代模型进行比较</p><ol><li>[SRN] 几何深度学习通常需要明确的三维监督。新兴的神经场景表征只能用摆放的二维图像进行训练，但现有的方法忽略了场景的三维结构。<br>提出了场景表征网络（SRNs），这是一种连续的、具有三维结构意识的场景表征，对几何和外观都进行编码。SRNs将场景表示为连续的函数，将世界坐标映射到局部场景属性的特征表示。SRNs可以仅从二维图像及其相机姿势中进行端到端的训练，而不需要访问深度或形状。</li></ol><ul><li>与之前的变化： SRNs可以仅从二维图像及其相机姿势中进行端到端的训练，而不需要访问深度或形状。</li></ul><ol start="2"><li>[NV] 我们规避了这些困难，提出了一种基于学习的方法来表示动态物体，其灵感来自于断层成像中使用的整体投影模型<br>该方法是在多视角捕捉环境中直接从二维图像中监督出来的，不需要对物体进行明确的重建或跟踪。</li></ol><ul><li>比较新兴的点： 为了克服基于体素的表征的内存限制，我们在射线行进过程中学习了一个用翘曲场实现的动态不规则网格结构。</li></ul><ol start="3"><li>[LLFF] 首先将每个取样视图扩展到 首先通过多平面图像(MPI)场景将每个取样的视图扩展成一个局部光场。表示，然后通过混合相邻的局部光场来渲染新的视图。用户可以自定义调节需要对图像的采样率。</li></ol><ul><li>扩展了传统的全光采样理论，得出了一个界限，精确地规定了用户在使用我们的算法时应该对一个给定场景的视图进行多么密集的采样。</li></ul><center><img src="/2022/10/03/NeRF%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/1.jpeg" width="400" height="200"> <br></center><h4 id="用基于物理的渲染器生成的新合成数据集的场景在测试集上的比较"><a href="#用基于物理的渲染器生成的新合成数据集的场景在测试集上的比较" class="headerlink" title="用基于物理的渲染器生成的新合成数据集的场景在测试集上的比较"></a>用基于物理的渲染器生成的新合成数据集的场景在测试集上的比较</h4><p>能够恢复几何和外观上的细节，如船舶的索具、乐高的齿轮和踏板、麦克风的闪亮支架。</p><ul><li>LLFF在麦克风支架和材料的物体边缘出现了带状伪影。</li><li>SRN在任何情况下都会产生模糊和失真的渲染。</li><li>NV不能捕捉到麦克风格栅或乐高齿轮上的细节。</li></ul><center><img src="/2022/10/03/NeRF%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/2.jpeg" width="400" height="200"> <br></center><h4 id="对真实世界场景的测试集视图的比较"><a href="#对真实世界场景的测试集视图的比较" class="headerlink" title="对真实世界场景的测试集视图的比较"></a>对真实世界场景的测试集视图的比较</h4><ul><li>比LLFF更一致地表现精细的几何形状，如Fern的叶子所示<br>以及T-rex中的骨架肋骨和栏杆。</li><li>SRN捕捉到的是低频几何和颜色变化，但却无法再现任何精细的细节。</li></ul> <center><img src="/2022/10/03/NeRF%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/3.jpeg" width="400" height="200"> <br></center><h3 id="OPTIMIZING-A-NEURAL-RADIANCE-FIELD"><a href="#OPTIMIZING-A-NEURAL-RADIANCE-FIELD" class="headerlink" title="OPTIMIZING A NEURAL RADIANCE FIELD"></a>OPTIMIZING A NEURAL RADIANCE FIELD</h3><p>第一个改进是对输入坐标进行位置编码。<br>输入坐标的位置编码，协助MLP表示高频函数。第二项是一个分层采样</p><h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>我们的工作直接解决了先前工作中的不足之处，即使用MLP来表示物体和场景的连续性。使用MLPs来表示物体和场景的连续函数。我们证明了将场景作为5D神经辐射场产生更好的效果。产生了比以前主流的训练深度CNN的方法更好的渲染。</p><h1 id="2"><a href="#2" class="headerlink" title="2"></a>2</h1><p>UNISURF: Unifying Neural Implicit Surfaces and<br>Radiance Fields for Multi-View Reconstruction</p><h3 id="目的-1"><a href="#目的-1" class="headerlink" title="目的"></a>目的</h3><p>NeRF的估计体积密度不允许精确的表面重建。我们的关键见解是，隐含的表面模型和辐射度场可以以统一的方式制定，从而可以使用同一模型进行表面和体积渲染。这种统一的观点使新的、更有效的采样程序成为可能，并且能够在没有输入掩码的情况下重建准确的表面。</p><h3 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h3><p>在重建质量方面优于NeRF，同时 在不需要equiring mask的情况下，表现与IDR相当。</p><p>我们提出了UNISURF（UNIfied Neural Implicit SUrface and Radiance Fields）一个原则性的隐含表面和辐射场的统一框架，其目标是从一组RGB图像中重建实体。我们的框架结合了曲面渲染和体积渲染的优点。重点是不需要equiring mask且表现不错。</p><p>note： 注意是实体</p><h3 id="IDR"><a href="#IDR" class="headerlink" title="IDR"></a>IDR</h3><p>引入了一个神经网络架构，它同时学习未知的几何体、相机参数和一个神经渲染器，该渲染器近似于从表面反射到相机的光线。几何图形被表示为a zero level-set of a neural network，而从渲染方程中导出的神经渲染器能够对广泛的照明条件和材料进行建模。我们在DTU MVS数据集中具有不同材料属性、照明条件和噪声相机初始化的物体的真实世界二维图像上训练我们的网络。我们发现我们的模型能够产生具有高保真度、高分辨率和细节的最先进的三维表面重建。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p>。相对于NeRF也适用于非实体场景我们把重点限制在可以由三维表面和视线相关的表面颜色表示的实体物体上。<br>由三维表面和视线相关的表面颜色来表示。我们的方法既利用了体积辐射表征的力量来学习粗略的场景结构，又利用了表面渲染的力量来学习粗略的场景结构。作为一种归纳偏见，用一组精确的三维表面来表示物体，从而导致精确的重建</p><h3 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h3><p>无需输入掩码。作者认为，神经隐含曲面和先进的可微分渲染程序在未来的三维重建方法中发挥着关键作用。我们统一的表明了在一个比以前更普遍的环境中优化隐含曲面的路径。<br>模型只限于表示实体。此外，在图像中很少可见的区域，重建的准确性较低。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Specular Reflection from Woven Cloth 论文总结</title>
    <link href="/2022/09/29/Specular-Reflection-from-Woven-Cloth%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/"/>
    <url>/2022/09/29/Specular-Reflection-from-Woven-Cloth%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-这篇文章干了啥"><a href="#1-这篇文章干了啥" class="headerlink" title="1.这篇文章干了啥"></a>1.这篇文章干了啥</h1><p>特定织物的外观是由大尺度反射率和小尺度纹理的变化产生的，因为整个表面的观察角度和光照角度都在变化。</p><p>This article presents a study of the reflectance and texture of woven cloth that aims to identify and model im- portant optical features of cloth appearance. </p><ol><li>New measurements are reported for a range of fabrics including natural and synthetic fibers as well as staple and filament yarns.</li><li>A new scattering model for woven cloth is introduced that describes the reflectance and the texture based on an analysis of specular reflection from the fibers.</li></ol><p>procedural model 特点： Unlike data-based models, our procedural model doesn’t require image data. It can handle a wide range of fabrics using a small set of physically meaningful parameters that describe the characteris- tics of the fibers, the geometry of the yarns, and the pattern of the weave. </p><p>最后： The model is validated against the measurements and evaluated by comparisons to high-resolution video of the real fabrics and to BTF models of two of the fabrics.</p><h2 id="梗概"><a href="#梗概" class="headerlink" title="梗概"></a>梗概</h2><h3 id="cloth-在-cg-中重要性"><a href="#cloth-在-cg-中重要性" class="headerlink" title="cloth 在 cg 中重要性"></a>cloth 在 cg 中重要性</h3><p>Cloth is an important material to render convincingly because it is so often important in computer graphics scenes, especially those involving virtual humans in everyday environments. </p><h3 id="作者想要实现的"><a href="#作者想要实现的" class="headerlink" title="作者想要实现的"></a>作者想要实现的</h3><p>Our goal is to develop a simple, easy-to-use procedural model for the appearance of cloth that efficiently captures the important features of its appearance based on physically meaningful parameters.</p><h3 id="贡献"><a href="#贡献" class="headerlink" title="贡献"></a>贡献</h3><p>This work makes two contributions: a set of measurements and a model to fit them. </p><ol><li>We present new, detailed measurements of the anisotropic Bidirectional Reflectance Distribution Function (BRDF) of six fabrics representing four textile fibers and the three most common weave patterns, as well as texture measurements for some of the fabrics. To study the appearance of the fabrics in con- text, we also took high-resolution video of the fabrics in a draped configuration under controlled conditions.</li><li>Our second contribution is a new reflection model for woven fabrics. The model is based on an analysis of specular scattering from fibers that are spun into yarns and then woven into fabric based on a given weaving pattern. Its parameters are all physically meaningful, describing the scattering properties of the fibers and the geometry of the yarns and weave. The model predicts both BRDF and, by a simple mapping of specular highlights onto the cloth surface, the texture of specular highlights. It defines a spatially varying BRDF that fits into standard realistic rendering systems and can be integrated over incident light using standard methods.</li></ol><h3 id="和传统Bidirectional-Texture-Functions的区别"><a href="#和传统Bidirectional-Texture-Functions的区别" class="headerlink" title="和传统Bidirectional Texture Functions的区别"></a>和传统Bidirectional Texture Functions的区别</h3><p>We present new, detailed measurements of the anisotropic Bidirectional Reflectance Distribution Function (BRDF) of six fabrics representing four textile fibers and the three most common weave patterns, as well as texture measurements for some of the fabrics. </p><p>While physics-based models are derived from analysis of first principles, data-based models gather the reflection data by taking many pictures of the material to be modeled, store those data in a database, and query the database for the appropriate reflection data at render time. </p><h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>We validate our model against our measurements and compare to renderings using BTFs. While the resulting appearance is not per- fect, lacking some shadowing&#x2F;masking effects and the irregularities of real cloth, our model predicts many key features both of the direc- tional reflectance distribution and of the evolution of texture with viewing and illumination angle. Its accuracy compares favorably with BTFs in many respects. Because all the directional variation in the model is due to specular reflection, an implication of this work is that specular reflection plays a more important role in the appearance of even quite matte fabrics than previously appreciated.</p><h2 id="关于不同织物我们需要考虑的物理变量"><a href="#关于不同织物我们需要考虑的物理变量" class="headerlink" title="关于不同织物我们需要考虑的物理变量"></a>关于不同织物我们需要考虑的物理变量</h2><center><img src="/2022/09/29/Specular-Reflection-from-Woven-Cloth%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/1.jpeg" width="900" height="200"> <br></center><h4 id="1-编织模式"><a href="#1-编织模式" class="headerlink" title="1. 编织模式"></a>1. 编织模式</h4><p>织布是由两组平行的纱线（称为经线和纬线）以直角相互交错而成的。在织造过程中，经纱被提升或降低，纬纱（也称为填充物）被插入所产生的空间中。经线和纬线交错的模式差异很大。<br>但大多数织物是以三种最简单的编织模式之一制成的：平纹、斜纹和缎纹</p><h4 id="2-织布中不同的纺织纤维"><a href="#2-织布中不同的纺织纤维" class="headerlink" title="2.织布中不同的纺织纤维"></a>2.织布中不同的纺织纤维</h4><p>天然纤维（例如：棉、羊毛和丝；合成纤维（例如：聚酯、尼龙和丙烯酸）；以及纤维素纤维（例如：人造纤维和醋酸纤维）。这些纤维可分为两种类型：短纤维<br>和长丝纤维。</p><ul><li>短纤维被相互缠绕，使它们通过摩擦而固定在一起。We use the term “staple” to refer to twisted staple yarn.</li><li>长丝纤维–如丝绸和许多合成纤维–是非常长的。因此，长丝纱线不需要捻在一起，就能保持在一起。 We use the term “filament” to refer to untwisted filament yarn.</li></ul><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h4><p> 纱线的作用力使纱段弯曲成弧形，向可见一侧凸起。弯曲的程度对外观很重要，它取决于纱线的硬度、纱段的长度、纱线的张力以及与之相互作用的其他纱线的张力。</p><h1 id="2-关于测量"><a href="#2-关于测量" class="headerlink" title="2.关于测量"></a>2.关于测量</h1><h2 id="测量BRDF"><a href="#测量BRDF" class="headerlink" title="测量BRDF"></a>测量BRDF</h2><p>To measure the BRDFs of our materials, we illuminated them with a light source of small solid angle and measured the reflected radiance by photographing them with a scientific CCD camera.</p><p>We measured datasets consisting of 225 incident directions for each of seven exitant directions. The incident directions are on a grid covering the hemisphere out to approximately 75 degrees, and the viewing directions coarsely cover the hemisphere (with the assumption of 180◦ rotational symmetry) out to 60 degrees.</p><h2 id="测量结果"><a href="#测量结果" class="headerlink" title="测量结果"></a>测量结果</h2><ol><li>there is an obvious difference between filament yarns, which produce a pair of fairly claffssic anisotropic linear highlights (one from the warp yarns and one from the weft)</li></ol><h2 id="测量Texture"><a href="#测量Texture" class="headerlink" title="测量Texture"></a>测量Texture</h2><p>但使用了放大倍数的微距镜头，使纱线能够被清楚地辨别出来。（这里我觉得是对model的两种模式进行铺垫)</p><h1 id="3-关于model"><a href="#3-关于model" class="headerlink" title="3.关于model"></a>3.关于model</h1><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><h4 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h4><p>简单来说：如何把从一个方向接收到的能量反射到另一个方向去。</p><p>是一个比例，一个area 从某一个方向接收到的radience乘以入射角后得到它的irridence。在反射成radience出去。<br>BRDF定义如何去分配向各个角度反射的光强弱。这也就区分了镜面反射还是漫反射。如果是漫反射各个方向大致相同。镜面反射的话会有一个着重点光线很强。</p><center><img src="/2022/09/29/Specular-Reflection-from-Woven-Cloth%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/2.jpeg" width="500" height="250"> <br></center><p>我们给yarn模拟成图2的样子。线的表面我们假设是镜面反射。为了得到镜面反射对BRDF的总贡献，我们可以沿着纱线段（u方向）或围绕纱线段（v方向）整合反射。<br>镜面反射曲线上某一点的反射光量是GufcA或GvfcA。</p><ol><li>几何系数Gu or Gv.这是由纱线段的几何形状决定的 （6.4）</li></ol><p>计算公式（1）或公式（2）中的几何因子需要评估（φ,v）或（φ,u）相对于ωi和曲率R的雅可比矩阵。<br>对于雅可比矩阵，我们首先观察到ωi的允许变化只在与单位球体相切的方向上（因为ωi是一个方向矢量，不能改变长度）。此外，φ因ωi垂直于反射锥的微小变化而不变，而u或v因ωi沿锥体的微小变化而不变。所以导数的行列式是两个方向性导数的乘积</p><center><img src="/2022/09/29/Specular-Reflection-from-Woven-Cloth%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/5.jpeg" width="500" height="250"> <br></center><ol start="2"><li>相位函数fc。这个函数描述了纤维的局部行为，它应该根据被建模的纤维的实际<br>行为来选择。 （6.5）</li></ol><p>相位函数是一种特定类型纤维的物理属性。请注意，所需的相位函数不是单个纤维的相位函数，而是描述在纱线附近发生的多个散射事件的影响的相位函数，这些散射事件都与同一纤维的切线相抵。由于纤维共享同一切线，多重散射光仍将停留在镜面锥体中，但将更多地分散在锥体周围。<br>调查单独的纱线和纤维的散射特性以发现和模拟它们的行为是一个重要的研究课题，超出了目前工作的范围。相反，我们使用一个具有适当的一般属性的通用相位函数，它可以被调整以模拟不同的纤维。对单纤维散射的初步测量，以及将模型与数据进行拟合的经验表明，相位函数应该主要是前向散射，而均匀成分较小。为此，我们使用了一个相位函数，它是一个常数和一个前向叶的总和；我们使用Von Mises分布[Evans等人，2000]，对入射方向和出射方向之间的角度进行评估，对叶进行评估</p><ol start="3"><li>衰减函数A。这个函数描述了光在进入和离开纱线的过程中被其他纤维的衰减；它取决于纤维的特性以及它们的微观排列。 （6.6）</li></ol><h3 id="二"><a href="#二" class="headerlink" title="二"></a>二</h3><p> 有两种模式：</p><ol><li>the reflectance model</li></ol><p>我们不需要关注纹理只需要考虑BRDF的时候采用的model。</p><ol start="2"><li>the texture model</li></ol><p>我们需要关注细节纹理的时候采用的model。</p><p> 这两种方法具有相同的BRDF。这使得两者之间可以无缝切换。(ωi是入射方向，ωr是出射方向，（x，y）是布表面的一个点）。</p><h3 id="reflectance-model"><a href="#reflectance-model" class="headerlink" title="reflectance model"></a>reflectance model</h3><h4 id="BSDF-Bidirectional-scattering-distribution-function"><a href="#BSDF-Bidirectional-scattering-distribution-function" class="headerlink" title="BSDF (Bidirectional scattering distribution function)"></a>BSDF (Bidirectional scattering distribution function)</h4><p>双向散射分布函数（BSDF）从辐射角度描述了从一个表面散射的光辐射，作为入射光束和散射光束的角度位置的函数。根据定义，它是散射辐射度与入射辐射度的比值：单位是反立体度。术语双向反射率分布函数（BRDF）是在专门提到反射散射时使用的。同样，双向透射率分布函数（BTDF）指的是通过材料传输的散射。<br>在不考虑相关的阴影遮挡或相互反射的情况下，我们可以从fs中得出fr，方法是假设光根据fs从一个区段散射出去，而不管它在哪里击中该区段，同时也假设散射光有相同的概率逃离表面，而不管它在哪里离开该区段。我们将入射辐照度均匀地分配给所有的区段，因此每个区段收到的平均辐射度为Li (ωi ) (ωi )z，其中(ωi )z是ωi的z分量。逃逸的光的部分也被假定为与(ωi)z成正比，并且由于它逃逸的投影面积与(ωi)z成正比，辐射度与各段的强度成正比。<br>这使得fr和fs之间的关系非常简单：fr(ωi,ωr)直接与fs(ωi,ωr)成正比，而且比例常数可以被吸收到镜面系数中。因此fs将直接作为我们反射率模型的镜面分量。</p><center><img src="/2022/09/29/Specular-Reflection-from-Woven-Cloth%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/3.jpeg" width="900" height="200"> <br></center><p>BRDF（irradiance argue , radiance argue) &#x3D; integration (几何系数 x 相位函数 x 衰减函数A)</p><h3 id="texture-model"><a href="#texture-model" class="headerlink" title="texture model"></a>texture model</h3><p>为了使织物看起来逼真，当以足够高的放大倍数渲染织物时，必须再现单个纱线反射的独特纹理。要取得好的效果，只需要非常粗略地预测高光的位置和形状；如果放大率高到足以解决纱线内部的细节，就必须使用更详细的模型。</p><p>由于我们的反射率模型已经计算了高光环。（v 和 u 那个参数）<br>因为我们之前积分得到了高光环。所以我们现在我们可以利用这些信息将积分 “解卷 “到texture中，以满足纹理空间的平均亮度等于BRDF值的约束条件。我们通过将u和v线性地映射到布面上的片段矩形来做到这一点。片段矩形的参数为-w&#x2F;2≤x≤w&#x2F;2和-l&#x2F;2≤y≤l&#x2F;2。</p><h2 id="5-几何"><a href="#5-几何" class="headerlink" title="5 几何"></a>5 几何</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li><p>一块织物可以被认为是一段矩形的集合 （织物表面可见的短的纱线段）。 不同排列组合模式对应着不同种类的编制方式正如我们之前所提到。</p></li><li><p>半径为a。一个半径为a的圆形截面沿着y-z平面上从u&#x3D;-umax到u&#x3D;umax的脊柱曲线x0(u)垂直扫过；这里，umax是最大倾斜角。我们将在后面几段讨论参数u。</p></li><li><p>通常情况下，脊柱是一个圆弧。</p></li><li><p>重要的假设：纱线是由相对较长的纤维组成的，这些纤维可能被扭曲在一起。当短纤维纱线是直的，我们假设纤维以螺旋状围绕纱线轴线排列，靠近纱线表面的纤维的切线矢量都与纱线轴线成相同角度。当短纤维纱线被弯曲成弧形结构时，我们假设它呈现出具有弧形脊柱和圆形截面的管子形状。我们假设纤维的方向随横截面旋转，与脊柱保持相同的角度。由于长丝纱线没有加捻，纤维只是与纱线轴线平行。</p></li></ul><p>一个完整的织物描述从一组单纯的纤维参数和漫射系数开始。然后，对于织造图案中每一个不同类型的纱线段，我们需要一组纱线和织造参数以及一个镜面系数。本文中的所有例子都有两种不同的纱段类型，一种是经线，一种是纬线。<br>这些模型被定义为每段的漫反射分量和镜面分量之和</p><center><img src="/2022/09/29/Specular-Reflection-from-Woven-Cloth%E8%AE%BA%E6%96%87%E6%80%BB%E7%BB%93/6.jpeg" width="900" height="200"> <br></center><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p>我们在MATLAB中实现了用于数据拟合的反射率模型，在用Java编写的蒙特卡洛光线追踪系统中实现了用于渲染的纹理模型。在渲染器中，布料模型作为一个空间变化的BRDF。它接收纹理坐标、阴影框架以及入射和出射方向，并使用纹理模型计算出BRDF值，然后返回给系统。</p><h2 id="F15"><a href="#F15" class="headerlink" title="F15"></a>F15</h2><p>从最小压缩的6561个图像采集的BTF（左边）、参考照片（中间）和我们的分析模型（右边）的渲染结果之间的比较。捕获的BTF数据产生了更多的照片外观，特别是对于丝绸山东面料，但它产生了平滑的高光，错过了一些细节，并且在掠过的观察和照明角度下，外观相当错误。(颜色不能直接比较，因为BTFs是用不同的相机和颜色处理管道捕获的）。</p><h2 id="last"><a href="#last" class="headerlink" title="last"></a>last</h2><p>这项工作提出了对编织品的光反射的广泛研究。我们的反射率测量显示了各种现象，从尖锐的各向异性亮点到不对称的非朗伯斯漫反射图案，我们的模型表明，一旦考虑到材料的结构几何，大多数这些特征都可以解释为由镜面反射产生的</p><p>可以使用更复杂的衰减模型。为了集中研究镜面反射，我们忽略了纱线间的相互作用，但这些相互作用的一些影响在数据中是可见的。例如，牛仔布的白色纬线点在掠过角度的转盘照片中消失了，</p><p>使用我们的模型的一个主要优点是它不需要任何数据，因此可以用来对任意一块织物进行建模，甚至是没有的或没有生产过的织物</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>exp 笔记1</title>
    <link href="/2022/09/26/exp-%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/09/26/exp-%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>算法-笔记1</title>
    <link href="/2022/09/25/ag-%E7%AC%94%E8%AE%B01/"/>
    <url>/2022/09/25/ag-%E7%AC%94%E8%AE%B01/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="ddbd9e14d3ea8c4ee9038a70c7de199de90c115e079594739224095a85ff250d">3a0bc4641647d2340c9f1dc98f043c380c8c53990d7de4f8cd160186461d0beca860b68419bb200bb33d0fc96d535e52c1565327abcba45dee00a4b74bcfe18aa45aa2abeb1f36b422ef10d38e8b4cdea324ed2c4d2d1e38af1881eeb927854974c276fe0b4774b5b87821fcbd2643bf1b8e007f47403fd6a9215adcb21071236adb5fad756e0fd11bb12f5aac706b57febcc340ce6af5de859881263a1b505f94324f56d5da5edbb75cdea22e22634bad63960167f8ff392c2701fb0c582b8fbbb9a97ec0a1198d77e380bae67a4dfb5a1a09cca26f7ea2ab35a9f9db1714914d35865eb8ee7ce5d54ee312decdafef5997b5a400638a80582e9a93079f36c5c426374d70045e05d34dad50197a203892a78b88ea062c3f8e93550a50062fe8e66e424f096feed53bfe54ce0cd81917d7d64e54864234d200a5b24e7756d5f2a97a9d4e84ee5e8290d2da8d7a08834694d7c3c2144e1b8f77e5c3194e88550074ee5ee7b8613e4901e5495da4b88f0febd97558fc87ef8edcafe4e61269608d39861c4b9014f4dc31fbc252b3a0bc624dccfa40d880ed77890317b8ad3db625e7b3689e331e39bb1229b561aa66a348b6d5c13d846f16ecc894e945f71a3401d6c5c745b9eeecde7454d9e3750b6e8029879d7d50b78084f75c02622bc2a22979f8aa5db207c5f33330d81145131188a2f3d4649093ec2a5121ce2c0d2b78fbab17fd49f58ba15c48e17de2facc5f241c25e554c5ea48ff7e3a1737d9c669fa6819145d262581c772abd6dec5ea18fd880523a6f97cbe4eea1a4967866c5fb5b9ac18f420d81dcbc626584b3615d25cac37d57aff31e8c285be7a95d7ed1256826ac03dcc1e3659e616cc1d1dddbc87605cab9e40932a107737a91b656c5617e13ce4416c5560994d3907b1ccb49114b6dfcce3db5607389532f93b222193857173afe8ce02110c95df3771e689e073ce2740cdf9e2ed2fd068608c0215ce48e13a72a4751ea188017ff3ddf1627c027d7493719375ecc86ac5e9f9f3210df40421ce9fa18eec1426b48421573c99814eca2e5c65ea2a44e6413fbc8e87ebd2418b86c2554046183d97f7164882fb33f3874b7b143a4dd3fb5d4318342a5f2f31f19ef1d5b2eb03d7b3b3d55fa807e62706012f2ba91636a5a29d74b9f67505b41431e762e891631c870942fdea1eeff8d824359ce60a010f3b0689b406b9fdf0a15ef999c6b3f4d927e297ca2e27840ad8a231fa7a9a919b55da7d1180c61891d4413e2ab18f4fdc18f45fdb7aca9a5b6565d8324b962ef23b488ecccfcc3bab24c4c86f0adb2e5382b1c254785ae9974f703f7bc74a1fcff59c7c9d93e6f749e95720715b679a13e94bf844970b5dded43bd6a5833296afad56601eae15b8ebe6250cd75fd6d3e0ef5b0898c75c628ad564bc0066846863e4bfa05709f891e0b0d125be659f5934de940dc568286589b5b20d25625aa76f133cbac3093988b0f44471cb395f21f4df50ad462485480cec6d8f901b5e702947a0ea2e2ceffbe72b8453d2fbff0ac2ed6b95b986780e1cac3e746cf6c3bdd407bef222d9e0254e9f152985423d3fa27d9bb59b8cc0f05473ea389421de7ea96e86ed89c73bbd1fb8d071d5011e46e12604ce708b92ece2acc9a89a54ea8c5f598ee2019435165745cd3b529880100954381c552387c39a2bab48da843f7f769dda2598fd09e17c042326da14eae307db44f60f45cbd7cacc7524bd203393327e557e5d0d14c88df3171f63b9df1c94cea3d1e2ded20db139db1c3feef7e3a4ecf0fa1fa8d871b5af2dc4048b8c8e3edc3a2ff8f71541bffb2992700327cb7ca6e9f99f78ed203fb287380efee8617e50ce78bda8543696ff554cf1d16d436f14c59ffbc95f8a848172f88fbf1ac8b9a5f17bf90f27918d3a0b2381e8eaea12e593481b2ce0242180dfa24428f1b7afd3160451cac8b3580543a771069fb0fb75f36c109e8a19c2c3727a144cebd88ba3fb6ec16ce2bcbd77e44e484b4883f849819e0a28c7d6fea6b154e3f4e8e21f79075d807c3c1ed76f1cce1bfea834d19a4fb7ea96c0189960bc13ab9091d9dcb892b206f11c4252f65f84e587fb4164a5a3d620cc0acf707077abfd6736ca6cf15c94710b27ddf8b5d51eed8cd68b90edfe2408f8fd7290f89e8852cb140646a069afa9a9b9b6f10f44ef9dd37a67d1ff4fcaf1f001c970a89d99791522310fdfa8447a905e096786e6f135fafde94ddcbbaa8621aeb28331c388fdc640e7013ba3872153082ce758907553f70a3e6e8ea571f5868786179003114339cdd5ebcca042ac1285e075676b24f219323f613f395b45e36402d7a4363e28ac41dbc4102bfafe1563879a8ba7c500cf748150c77a822a586324cb99cc0427de396ef2596f495b03f090419a755e8e5c518b715f1d4866f3d246a7111467b9e08763520f87c4912d93d2f50d261732cda22856f50e742a4a3079a8fd8a19bbb5646bf94dfdc4916270ffc71556556b977625a93ed714e6517d87ef1229c7ad44e381264d8e5af7c0a399cb900044e8e4c897618eda9218c584ae4ba06c47f80ebe359403f31a1b853450dd9aee3b08d37436fc34ef730481a9a4eebb5b343f4dc86877ff3ab4b35781fac86ce660a805cb6e3093ab7fca0680c9e4f519a0d2849b5a3c37dcb7d9cf7e933b2aeaabe18d86306cdab4b8c666921d32e85f3e3ffd9c92f986604dafb365171e26d1fdd43fd9ea630758d0eb8f73a61dafaded271a39d5654c662e9fff1dbc905229cb53ea1a1b2d0ff08de7e20edef52ac9176cd431057afbc0740b7a77b8128fe95a2949242542b59dcba1f09da5ccc46d1a7a07c83644e485766d6b7b440c55c67b6cdb686465898b7e7f5df54bbb4390e278d46309059ea08da14519cdbcda1057fff634efaf705d997ebe5e326b9e3418ea6a8ce92a326cfa6e622cab0a2829313959736dd3a93c4abc0599f02a4ee82b9117dd8407d058f2585549e4c5ab0224738c9c161fc4b527ad954a1e6594c730f8ed904de8e39029af045be5a06a26c57bee29dc320f8e4749475637ede94414f80a245e1ffc0b5a6c59a79dbdc1312aec51aead77edcfffa2ba45ae91c22149431e0f29401bcc8204ade3e87cc68eefc7219ecb9e27dc4cf39a3cf67c4da4e2797328814f3476ccfa694308cf23248f6933ab420d79108c6f1cfdc95558243337f3ce0ba3c80f6547aae21b5025fe5293be4aed26ff8445325b73859528b205967ea29202fc2c845890bb009e548eb8ad6b8fef63537f755aabda75fe80b1f02c5e7142944de1a64c4f3defcc6d1f5af8105fba3c22a53f0656c3a25391b794d6a8a1b2cdf03e27573f66fa14df2e4ff55eacd87a876d995dee6cb8ef40da53c8d0a9af623df309c6b0ff544b28d761a2e1d2cf8f3f58e32d3be9b9e9a26b2fc64f2fdf13e529a552dbdc7327b3d18d4798ab417b01ce3bb5c02b781014d217db3a4f1b9cb84b333855cad1a17c66d99c910bf99bec559960640f6b7a5883f855dd3758641a07d9d67193d0100035ac479ff6385db20ec234aedb3d25fc556b461f52991a87bc5f7de61b9b7b15d3ca5442245fd6f32ad3bcc97b4b0d37dde9cb060d21de0664b5508f98156bbf3c09647a1f8586c7223c64f5416315411a6852036366809d2577781ff42f4a84a5ebd100a887a8fd18d3eb2ef8878250af326bb4c31cc736e6fae73a007a4943841d96b55bb4427b44085645ccb5ea55b1f26d26671e81c5225d374e3d47a7c3a152969dad92dadc93f3529a9cb1be1ba78cc10242ed3cd7018f758e30d86604062b4a11c4ac6700cf6d943b6f181bcfad4f93e0f0af8f3a928698b2250d850152aa01e4928b41e3c3b088f514cf04498fb6a98e65aa4004b7a6613f9a3a4198374b5a1ce437fd1657a6d9e8d2e6145d0892cbffd557d2a7ac0f301740a6a3f1579f29bf5b3007367c943a9ed63ce9ae7216f3647c8bacc5d72461e5c0760c4c67eef1d2d0ebc70bf9858be335157c0cf1d628221c1e3c7420a4b64fdf71b609b1e8e4cbcf2ef902dd04be41d4464988a4ddef02bd16be36198ddb2c97676043c327aab04f317716244fc79b83f71ecf2ac85d893163064cb98b035688832378b45d152b18b32af4be4915247cae3c2f87b9df554df66b86abb18c82746a7abc9337324a889ed55c13fef31a03bb090c31d6014be59fbf852f5bf000fd43a13392f87ce549822139c41707a3e7c78b692921852639292d16fea15a53805408e411cc4ee46a8d5b3b161de5835ea2e311222186fc53b3f27da79b4c02040cb12d037c6b4534b56ea21240d607e82aaa720b8aaab4d88f347fb79794bd90e6931f1999af3c87a9530cf6797e79648dce85caa9ecb41e1e366747479c2223fb687db8fc967f9f256feb1cdf875c413adc25c611723948b3901450a5d039b93e0e218cc19f799ce2ee2f3441508c0dd68a2096e5e0ba8cb2dfaff32eea75a3ca17110282deec63bddb568c5890d5aac136f3b0b33b13c742b3ca60bda77598706ee4c0ecc7a3d03e0e563067715a5c979e0c48bbf6a3b4cd14f5e47ac08a18bf806cf742c5671e2acc2b306504c93ad203d53ddb6bbea603392132b84f9bc2660297354d73561115e438cecbd1ab3d6a5846b063c33faa95692e788b6af00bd91b36f94b4d4f1ace978b497a62257d89454f52c6e2610496484291e34bfdf02a774b28b03187988cad63ed8c388e60c9af3ecba1aab893f732dd874ae38a9f8e11d9def06efefbfbedef45c870d58e530ef8d1c674e1750b4f861c1be37b022ad292dd51e02dec496a728f697e206217cbc48a369355ac5a5f3259651b46bb23f6c0eb473b4091a06d02be6744a4b62757ab6adf610ec92529d1f75ef7c3c62815646e5498d658350192e2507e6d2002acf6ccb8ecaa8d8778e297007b184ae816235aa5505a89fd169b70fc75d95be8e9308475de1e132dfe427da690a4c1ab33f904d5b7b09b5a0be80cc17076beea12790bd7abb54def5745dbaa05ade42cd2433e6dfbbf432522086bc87bca6f7ba91609128e8763f721b26ca435ea53c64861ad2b1e2aa31c0f9fcf1ab1ff645b062cc3d8357b0e4e2698fdcbd185aafe638bfe0c5f848a80d3e916416a459c85ede671fe3b2347d2b1fe2488cd98890439338b878d78b1f4371f5948b840f1417983c6369daa4f758cd279ac82220110009bf0822aad91dc8126af882b2ca8c9cc0e6ccb4accaae4559b871c5805235cdca842e822d01bc981636769300f6529fa439a54c7fc3b052dd0d760b79951b3aaa6d3fabfbec852f489e26be20ed96b9776363df14ce056473d0459058766ab4156c8c5427ec19615372217e5aa55e7e4703004abda565b350c7fbe35acfdd79d74cf70af5ef44ba4ef41d00d46a4ed5d60f48b5d84ec4e5d673ff7b3390b44a6573e2a9d7414a247aa816265c73e751b50b39929425e379469a67c4810587af2381db131ec406dedc9ff60c689d0f579c83c293fec5da8c1aade4566e987dc1070ccb07a80d04eaa28590f6f964ac76e8019c8eb1ee590dcf79e1ef04446e2a92229aba87178e110a6dd895347be0644a323b9b31ea592b0093219bca0d607ca485b7ffed26bfe42869f401539955da03fb8a2f37b92beb237fa149d995459b617b7211d1f65d6d72f02d7d9d671547ce6cd1cdc5a24a71032f9c91eee1597c31d2147e699539263166a1fa0ad4a8eca212f7e05427605f939d32bbb79d152ef277f821a6b00ce11dd3bd5be837df0d47439f83c1cb6130089cdb827581200e43c3f8e719aacf313c37e90e554518293136db028dc9e5879e8ac2c90773ee4c130e4219d76a1eb7a7e5c23db9824c1e68428b376eadfb030ebf746eaeca9315b3fdd485e7c0987099c382bffe0993da170ca57f80fd2411852d359b41353a65d9a6f5e38b1dd5bf8ad7691b75c99af2b953656c24005d53ca01393c4778a855e28b9676b5c9f70d4641d886f7df8f2ae2badf6da99b74b619edef97f0ca78356bcb9d7068168af9c97835d46b44aaca8496753989cbe718bb00561841fe50bedf31e4d409f950340c5cca3aa8739999dd57ecb60e82482783576183056118e09026ab84cf355ace53b2fcf89f6ac8f71dd0740df805a3b153fc80107f9dafd5f2aa7f161afcb16fe3e85aba6a14d952ad0378e88ccf929e956a2bb5e45e60382a4d486903969bce84a40a35f336de27ea3489e30bd9bf3e27c61acd2762804f32daa8b5ec3f18d000bc5811961166bce372a6aef756355c25ace475a03e72048518e907a38ae91e6557f486dc70be54164ee7a420e03942424da1455963a93976adfa33f8bd05fdbc08397885c09fca682275c19e0878e94eb9c3984f86150586b06eb44c1ee501d5f2bed2267c067dc4af33203e6176d0e472948e32f67dfd7bd10d69c3d3aa127c33e7c6a59762ad8129f48291325c082f92431eacea94dafc13c77dadcb6a6af0855f29883069ebb82d7a262a36e9b8e080b15e9b091377defcbb4920b0c5297be5a08b224e9c9e009be66f6410435a18881a39b89547be725ab5d957f696aac55d441ee522a6364ca3ec99a8c0e6102a5f9b9c113df9bc8f809e937a75811172747f69b389efe6822edb76bbfcb052c3b620fc089247b87b87fc8eacf32eaefdfc9b70035150f0c83b4e6559b208e4d7b2aebbdc64cd2e5faa368821b22e64ac7a3fd6c2bc881ddea907864a5fcd27f9ac5715417208c2f3a9d3202863999941359f92ef66a1d4b87212845cdb6ecc632cb896e4e8a26d041acc1c67166ba259c5870a351fae386ab4acee055c700411d1568c923077fa8e672c9a458bb2f7aa92083bf763e19f29cb8c2fdde5645509c0219d4e5e07f4c21aab9a51b5a7f0d1f56c9bc92fd39ed31950f6e10bcdcb1aa8f543baa7d3d8879b596f74bb8957ed3aa197bf4546a075ea285281e04a2cbdd47d8889d792960295003a54136c471031f620d921af2c1ba929a3f36edcd9195e0979c3e0934859e29e030740e41f26c56a799ffec6579ffcf8a26c599a912dc6a3ea78c69c645fa9c88004e30ccf6ce5407126978285390d30fbe1c05ce54958992993d660db4bc84cfcded85dc28ad0bf6914279aa777ff6e87e9b467c7aa7d24b323c2e213c3a6e1ca41557c536d5b8ead6795b384070c44128f8c8b2c6b73445b1f22f1904ba6e9868cd8f7435b761eae95f47e5dcf57f1c450b769d5e8c812f917e430d42c5b47344b9f303a941d2304908bbb55841cbf8762ec40f3185e4b0c4dbd06542fd0835ed2b28bd571a5d0ba715e13dcb73b6c8daa0cb23d5072d171871a653e663ffe96767dbefafec91e4897c387c9a04b472f2c2fc8313c1282c5e37aebcf9115a7c83828b89eacad78a4a56e06704dcaca3b53e56e6412aadd729f407332afeb15fc8b1e6c04aa25ce048c69db4f39667016c61fc90885639e277d4f3920519165525f62184c6330d09e9072a58b301e3c48d04d28ac8128180a95bf3c04547562b0cf3534b902feb62a068ecc139234ab18f36353c8a7e5408e1341fa9d0cb75754cc0c041e0136e9b7ffebc2fae3f24c314634ce9bd31b3ce2cb2e6148e3bd545e8afa3b30722aecce26c0656656d8c6ee017c7c00484477a88edcd4f1b1db1e2ee3bd7b001de4820e3259667fdb9ce4ab21b6e4a5e6df6cd4f47380a02fec9fb836cede5c8d5c2e4f44314ba16fc1e8f6b9b3cd3626dd7ff732880525480759e5ee7eb5628d3cc14437ca149e6a88b4ca9f5866fa628779008426eee21c9402465a4b95c9c98cfff9f63a0853a9d1ec1ff83b67a19e702bf9b8ae0526efddab5d045cb349e7e6e8a5ac7b90889a732e1a0e18efed8ca2ed2c3eb869d7043b10ae80a2cf3c53843f86d1986349c57e0d775bf6820b2dc341c5b0352fcfe26b2d30c43ac102b3aae89146eed9cfbd76b20e541adfcbbf944d3b1ae7b682788c21f5344a85584ea6db05f0b5ec770cf5dae11e511ed0e93e4d3503adf2482c2dbcef8607a5d7ee9cac26b236408fd97586aaeda275758346fefddd1eae139aa737bed69de42807b457f134a40ad9c248d860ab60b617dde8f58e42dd3a24563e8d999b41573edd800ab5212cdbc3d1592a513b55c2b25375ec8eac7e9174ac25be5922fe867fbb33143631efebd044fcef97c1bc75c888ab5da008ef780385b4e9684ed6519e08347297554c2469b24556b8ff68e0054f0e12100dfa6a2bc1d27749183b44419b6e156af7c1ff8d4f7b05e3130b6ac7fda8b249f8643d9e0398af6452c17605cb465f07dadf0da2e1629fa87f778ecf6671d96d08cf30b490a6db82d823ab2f08166172898575bc76ba07142715ef65a25e322a2b4097560b39cbbb68395569a24503e6c6643cb5e9720b761b790203455d6b4a28289ad8b18ed2f3363ce2e15506cfd5fac27cee5e77a00ca4555d2e9e02f2a17a35e0121435fa5a4f932f8ad81476871f9e27ee37b889a643ca1e3bdf7229d607914f51c09479790bdf6756182be22f67a3a7c9ec6009040bc85fd227183bd7fde451bd60d4c3a8bd07ea269aa5929ec3250805e02e3699d24ca177c32927ce427c1261d93982b6394cf070b2f61a5a638c44412216ebaeec6a5503eb82a4ed9137f25bc993650830f716931f5af207be0b261b8a7b4359998421096f8e03755370e845c43a4edb37fed3dc00e79e15b4ce51dd04bf1d13261b050d519d185cd2051bf1061909d06119b948203a55361ccf1be8f6ed04b4c93d18d391a448b7089f99ee45daf26a33bc7d7e72e5410c4e18ee7ccb7384e229b05f839c9c1d571e74a3764b64ae6deabfd8df180554d3e538c7de481736c198bb49691b755db5119cf4afd77e13d77166e179dcd850966fe247abdb2fa82de46a25b629917fc7af5892500578779db4eea3f441e956a647ed0d7fd105bcd36fa0de7f68ea31ff5f931766694d78c190b227c732ce7e285662b316323651cbd6d7cdf2b9683992e3a91c3705d378911e7cf9032ecc68930ad6e965f08f7ff168ee5a73423bfc2c0b794698fe4bd7551e50eaa8f8fca0729c478eb9a9b608b2f5d0082280a26f2b6f9eb324ce64a1e3df1a1f277e99edc392c67a2c3ec4c9e1715e6d028b9ad9efe931cec6b32275f9274547408cc6095f898accf0b9fc853816a8d5ba0b87dfea7d5b8428ca468890032497d930f95ee5a4f261dc441f8a603a66eb09cfba2e395b46fdcf2ca9b5fbeabd7dedcc1cc3794b4c5d6d70f77451ab67b2b3db780d207338aaed60792733f9aaf5b4274bd1db9c56eaf474a3165f9d6b483c282c88c90ef79c87cb47602b9b9ca3a65ae84ff1bdcef486afee9a5c4c04fc9f78200fe978ca50ecfe8ac9e6cc90a2c62a31eee0931cfaf2fe019f37001c8e4e8c58bf8280e6b0cd8db48ad46eab8e2c65d86adc3e54e3db50824c7f1f8ed9f08ffd150441a669e3986b795deefb36d49159a051ceca9333b6d827df5ad7915ef7ed6a174ae78d834e2e4b3936cc1628b2a87da35421337d55f519702965e505ae086cfb6531c76368b4c2ff34cfcd78fc789bb62f2c46a5e5663f6544a8471fad9d8ddc2d8deb83117c386d8d995f17e402223d9cefab722825d6398be1adb473b57b467d1727b6cdeade370312d3192da502c5cdfb63b00de40091f41fecb101ccc2d4c13466bfe1c68e2f9da951ecf73066d8cb1546933b1553ae080e7c16ceeeecb2d0fd9aca808858b88b13a495a4b156639b6facf0c05c199c27023e0ade6e8a4d3d394319fe8d628c9fa4adf396043b8ffe9a106e38b22d6235f01ccd17a802acb705ee8af79235ae197c05639ee546b6e0244bd0f7c796cd0668692e2caaa4e526bccedb4157cc00626273e4efdb0cdc06f9862c3939b21fe5987419d4782a016ddd13fadeea9369bbce7e82f81d2e80beadbf883a4d7c15c1f41cbc6492c33cb85810d74b6ca8a16babf0dadd2740fe7b2450a5ce1b769209c33146cb7e44efa985fdc3c96b5e2283ec642719003d6a65b47f8333517852180d418b1c91944539330a454054b9dad893ee6d8dd811b48d76df09c84f7f568395634e2dd67297c059abc10e33272fb4d08b2d2fc1b55e228200549fe73beb0d2f6edfa9609d100101e51a6918ef478e8be195961b5d40d4d4536103dc8edd8c8b425c02576f2e2b6510db79ea611b83ca90085a221dc841e76dde6968948cf7faa1e278d6fbc688c300cddc16940359ca6e3e71c286302427c3fd770d4003a7473fb58098414136a570c3ed1c900b9d90305cb80d48c8f0d6cb5cfab0ba3eda14a1be0afb6448a013f7dcbeb0d3740c5613f0bccbda51bed5c2758a0847bff68f3ec487f6dfeb64748bf6ff76b56791de7c0d447f35db492e55aa756ccf86309974ffdae42a6ba85c94b2d5d3fb09a0bd27377611efc23f5541322c56554031b26f368b94d22ae2ff3ad730f3d39bb900c279486a47005570aabf8f8ffdf6040ffe8180ccd1331b02c2db936707a75e69f93fd954e66b21f9894e6322d4a59b059fd52fa64f44446b7d2b0a723708e85a0ffddf6a85e58fe9301ec1f989c3e179e7c3632f9dbc085c1f1363af1321312722b9bc6ab13e90600ab3f48b7c58f51b39415748d8bcc96599b1770c58f31b0c7e43572d40664129a548431a4b86b13de8c0c01c78359496d622a2aa107687564a8fe84622d77102eb1dd06aab89a7cad09cb6a976688320ea46eb3e24243a1af8b90db7e8e24f6784a6ce79a5423d30bab4c6793927f4acb73670a2cda62e0d62efe20cce0d7188f640ace5ce4e54584e5ef5b0492bcd1708c9d2446c5b1de50918719e58ebaca551027de02ae68c0ae3fa1b66f2ffdeb0dd7fee2476f1344f452b253d329ddcb807f28c62105a43ce43ade7db8fde56fec493ceb1b82fd7a5a23d867c54442e66a219bca72db85cdb71a2fdf3b2b1b7483c80b2a6d063f7a26caa77ab65fe5e04304e0c2e9ba7f6d51db4ccd31d9a995c9be98cd9e1cc8c56a1a478920b9264a240a9a148aff79e421a23faa42e5b53d05a97c5b8d9efd2cf0c37c119c362dbac509a7770282b87d9e09cb421673b209c8dc69ff83dd069192526ae44bb6cf8e011dccf78dcef934e0777b21a3117f681f79753a7d19cfd4409468b942ebf0f202dbd71769fcf4a95f3929ad11ac44d9dd39c74762aef71e12c90ccc0bd61bc0ece6136eaade5380602590204c3c9be3d1bf101fbc2ec40d34febb740e32145de768367da83de72b25b044f4f90e04a6f550a829b47841e6249c0f0855ebc3057fb15d37a634c84f9285e6bca25835b9657d03a9e975d543178e97b46d58f29990fa313171e11de35890683c95231eda27b92245f15fdfa628d3b68d952818622fdce602f003f72e48a505c17c335fc76ef995e34667ff5e58a9aec10732948793dac08663955e18ae011798e2b6417079149c25302610dd7f5b874ffde7d7d9e9f417fddda0b954c82831bf19dad78b14c56bea63787214c5e1132443805a2c8bbac7921921a221abc4d47553b19f06d01871571cb2a7d4c64ea016b2232e1253105579b5f5706b9204868a4db90b685c6b2ed13f4961104f004e4806f53e10d7f76992455ac61bfe14a660b392fbf72c2d2b0de00c74d2eeac16c31b589f9839b8b3284d823780bcc030df1c30cd4b4b8151ffb0f8bd7e8214b00e9c4b754850cdc5bbe816a4caead336246e1b7bcab6c3f5ebd8d679cf4b57b08c7ac83218531970eee46e97aa0ac4b6733490db8c5237fd65ad4f3c371bdd33b9241886fcc4e724a45cee449ed07b9fa258fcd0eac1e8174f73da2a996a14f3c5a978eb76e168920a3edf109d5b50b0de3d066644dc93a0785e9a039fecaa8821d800c7f1c481f0f1238ad639927ee6560e713865a38f3ee78f0394a809bdb2f8bcea6e63980d01345ffafb82b8ba76711392b7a6e84018562cdcda425a73b12b8c93507d966d41b4c74ff9a4aae3a745f9aa28d2ae93511123fd42005e2ea794a045ed5ced0f42727c72828e01ac36afe8b7c115f59a833b5cfc6e5fbe2bccff1d70e64e2e2b3f2cdcbfb25a7ad797a2bcee89cd431a6916b906e89330c052d2e7d03591c4a9cb1058d099611df47b529a587cba42bbdda7748409ba10029d88a3e0e1cf54fb49d71fc92f50e71177d01e1391e9dd612fd30e9009ba253d5672ee92be83502e99ceca964850e61b909f8b6de2500cb608e4aafa8230c41eea9f4018ed56c298e64ca9ad9dee093974d20fa74c3af08272f3e0bbef8e39d403ce0c8026c6ef1c59caeb3a44969f22d32e350ca5e9286ad79aeb6d81d3016a01643f89faa005098583dc192cea4e4ab50d4a428e5b25b97dd5b45bd9a7fe9044065ce5ed10a3bcc38d03e7e71995832d2635f185eb8eee17ad65c02721fe6e2968752b717529de4bc6d588b5f9a4bc23076478ac2883968561c7ed79bdc827dc2469ef944b578ff0a4c12438c67ccee0c1c96d042ad65a17fc1c90531ed3e6d8a137872293145a0096f06151ee674e89be2f9dcc2f41a0d06d6d564612fc4531b56def4aa3d654ba9c0adf3480f32f528de75b86397475210b72178c210852341f11c0a52eeb316c0c2a73470d39a8611f5749aa950d32312ff919edd6364cb83fcc3a769a582dae5c9fb0a5c2d847f365d5c6d4512237b8887ce0866c07a10d9ed4b26a38b43ce6742cebcf63a3109d0a8f42abe9a143a32ce1408aadfe6783fecfd409f8a6199483c59ef52b21c35b9735aeff200d0532ca1f238c1d0df56520c56530540904d10ee66746ffd8005f521c1416a5791b057989e8709cbfe450ef30ecf151cfaf8e533530640d9fc2720ae78f776506f59afff6720abe942dfdfcf5a5de56aacf1c36e03037fb8ab1215b2fb97150831a5355cdcff61e85dab4a780950f9f41a18ff2361e73ea87fc2f3fecba73756de40b67ec4dff3dd72bb4302ca2a7387c8f8bdc03d32c007686676c9b603ceb54c793573b673d204d3dce7acc72ee42d3cfd1c6cd771dd9b78435f50b3f9d8ff1bb4a5ed75447328e679832be668e287bd545c5725c456308507f0433c76077fafd5300116fabb17c23cb26d70f9284569bdfff79d155b8ced1ab4c09bc951929cc11e0f89e306e26f7d6aab8d53afc89ab2fde3d52a788b69780857eaf0c85350095437960ea934150579823b26a8cd7a91ca26c0cfc1a0c6b3703783b82c4e2cb4272798cc94b6d66c1e094f928f224d40f6f023a32f88c757c8d63fbfd3762725ac0a551080244b0b7f982cfe880a151890ab383a4f33dbdfe4d2d58913971c79817268197e4510ad96b67545951c004cc641e8844f140f6882f811311c0600b1fe4d1d27ff6f3cd7aa1f8aaaf87c5af5c622adae7eacbc41e4f5147349208afdc86a65f5b449931c858f89fef48e69f9d5e3aaac049d1f5100aa857be41ee78d9c038857a6ddaad806f4b2dc7f824fff892c2c348c2827eaf9bae62e94793ff94bffa29a8da91b82cd2f0e8400152ca883a31686862c7d930bc4070c9adbaec0a149ef234f3ed4be6b8e233c95f05582894111a8d576708f54679e09371d51abd5a57315126fb4d152f194e4225e44b2e9bce3330577d97b4b2cbf0bdfd26f941d117154a1717ab98b5132b167b3ffe0ca45fa5396ff71020f51775a3009556dca624a3fa14ec185ddb08b715fedf98fea662dbc33f7675747528000cba5852553b21b4acaa1b77e46f189acc32cbdba4b54250f017ddd73d80b368768c9718027667375511e7017971cc4e663bc04da0447434a49033b11902c0692202c8fb60b562d06513ba95b0197eaef70efa39334fc1ce35c0de570aa60781b8c48a2290cf29760ed5f5ec1a94e89fa3410d21376620677d5e2d8a7d5b07e882600f1bd15f347f2bba92233c51b91fc0b49f5b42f9b6710777ae58d0542a29967be743363bfd427f53f37910a6effcc6ecf1392554e0fcc325d702d78d326572e354885ad9eba14558bca3c26c065344c054d1e7e6cacfda23bb84f422fcbbf9c0df6c455bb894030d03d4d8251a9bac151319e47134cb9e204719b2d01ae3ba09dbd32c1341d27aaa6fe838652d2369954a54f0e4e31a61bd4737c2fcbf51c8c075e7ca6167376462ba3d422b72f047c5375d3721ee04b616199ff052c85ae0fea18acb678c7bff476ce40dbe25d566b1a7487c24505ffdfd39476dcd8f68c9b16f78dd34c33086f7780b5d2f14f04c7ce3da631706ef18c76ab4c84bf8bc7c3735b88967f3f9143e4fd348a048c463657507d807a241631e98b9bf93e5a40dc3fe92dfcae43fc565bdea9cd34ac6e4c6f56b7f22e8d2007584541dc582e56e36ff36d481a06f4013f97820ea069837c442cc72c27a3549abf39cefa775ca1ef57d08881fad277c52654f85466426c5effe83b6b9368e1dd7c16957503b092eff5668f50715afc8b76a2fcdc6f9217d91b3e2755ffa849771323b432891e470a5488214301a01a2f90be144e15897f67b690c14cdc4da9390a202cb2a0937d0403149e236a917a3d80a4276cbcfa27655d00d0b94bb11c86f2353ff25cc8f277c8eef5fe8b14b43956482ac6fa7256804108ca7cc0e140445edfd758294e2a0dbd016be68d4dbcc2d57b8ca7ba01818959d690383fffe5b58c4c484cfeed601b7feebcdb2d2d384e05e38d6e3c90c24a7d2540ba0dd27e7d93385bb8b2a58950e1bc8f2995306c9e78355b6be5919b6edf43f96010584cfea35db5505dcd45e2c11db29735b087ebe4435f52928703b40936f77e4d260fcaa5aa31a8a2f68d7a1d061f818c7e57e6c6dfadbe579b42ddbdd215049870ec10883c020b2a95ec69a82706a13c53c7445033a8f4462b2cc9c401cd9cf8210fe32be1c22bea801114867c8382e1146b166c4340850024a56a80f88267f472050480ec828ebdd2435fa02cd96213dba816a8f324b366cdfcc7a9b963fa90b7ca9e8a0ecfea098907e8e96d81249a7db890eb28759700bd5be58c210aa9fd163f1f5ae60b1316d4bc194a35bc5cab5f3a1f5561c4c1b4301b5275d6eaedf64210eae38c7f3eabf6d83318ac9a5bfcf4840322dd00cfdff363bec1097705fd7b1c9352902fb7d01cd010382a081e74134b601beef12339b5fc63d65aa9763e5b94de35659c3a50ddf72313f6c98052f156a34f477e9056f4af7682cc03374cc9ff9e639bde72b1cd2f7bf8fd1abb2f255182f733b97ac65be37a709a9bf9c504087d45e3e4f8d1516ecb3f6f341c6be79caa63375cc7c600ee0f1666af6b5256a7044c5e74c994741343732b787a3bdc7ad8a40584791e7d4d6dc2011be19bad1538784205cc20728050cd0714724f3355dba3eca4e6ff63ce8d167508c81f6d362fdc1936a2c15c3814445b9035b321950366379a69fda335e035ba56082079cf051863d30e0442535426805913f46da6d9bdbaa3e9575d7e73002cc0c29b63dafd90fd3694551f0622b0e918028050ab45fde7353390a24d5283011b020d2865da123a3aeb886b4d5e655c32962048431936835caeddf8e10f7f1be6986642e79c1e931699690cca7b82f83c6628936e95c508008a1bfc12653c2b289ff26a1cf2312120677e40e1d4d4113fe6e42b2e15a12f696022e6f3b55112d2f4df01d24736c6d6aaf897f39df39fb5e531388f6a33fdce9d650af7441b427e80fd5412a17e84c79e27166d9fd635b30c7b2abf1a49c20738a8ba26b676a8055a19e022062beab7093e6bb921ab14257f74b8cf933a0dbae3c56f8a2220dee56a5e31ecefb2dd25cb8e6f2b1135eec20f432b0153006577a5c3a584a4d3a410538aa89ead2ecaeb7f55243713ca04b6720061e84e632d794f291039e0f110ed3d4d56eda3ba2b4293cd819444be155e33835a8ce5c671edbace4bae2c4782eb4c3b4ab38434021a6084a25d834a233fde4356b90c2b6b90bf7a1628006f2211396ff0e990d276aa887def2b93328bbe94c34c341c27861845148a185b926a2a3afe48628e0141a9db793c5243ac274124bf1b2487d46e94bb3112b4daf7b4bc4963c006251dff4832dc435879f169b2b0365d0e9c3649f3cdd06984387298e6ea389abd7fbc5d26f6d8f144cfd98861f8ca2702b3b47cfaec014bf6ae11ee5e7b0f1274a44b161367d586134eaa2e2d149f75a92d580b6bb454ef94c2dfd7c7f8a8de510505a6e65c341034775cb7aaa093160706d4501ee96cbd84be99be592c6ef8c450f0e52af10fd115e393fea4715e3c35ce85b92f2dbd8ccf37f982c5423f95c6cd7acd6d09be0e002c50d9a5c81a2a547e2370a13d4d311ddeefb96f894ace43738f9bcb1085d0e84af8c2da9eeaee125d49b0efdcee12f8bc12181e5d39267c859548bc95dc5b957fe73312ab08ed82c736da7d77f3ec2d8b4fbdd6c4f84edc48e105183ed0e966521768ecbf3b23d74d6ffcd76975d0ec597c4bfcef20012bf096da265a96ecd9f483b6305e05fe46a0cbbc7aa83d36fedde0a3bb31e4961d0e456709b3dd021b26dff6bf7bdfa7566facef6589799ef01512c0f4b4d25cdf5b3eda5ea63d2f1a2312b24d5093c56d4a710ca836fc55640b055e7967dd389edca92ca7c0ac0790a4019641a66ba3027c02d216de9d5d83c30c5584d742527e44d2352521b47d5d5339b1ce8b2f6c52e6b3db23cd771e72bba79b8eb8382f0fe2ef0faffcbc186f4de435c747a4a3edaf3a24c80302198629368d08942d84e9894b8b21fa3f5a2ea96f7df43b329632ad22400e1922cc9f675c5071cb5c228527c2a0aadf48791564bf93acf9b834db66389d67677bdd0d330a2c691541501db60065d4267e5619f035d607fdf237ac483bd0c8d0154c8258db5263b4efc9e239ed319f6722305ed3164d346a6ab1a11b3b662b5de13212b0413f580152c8d2933fab5d56c3390fa18a0b7199a7d284486923aaf0f26081c3e7dedba2a99cb4fa01d73f01adcc61cea526401a656c2a9186d95180b5c5a7b8bfde5dced53ff7ed61dccb1aa3b3e07b849c13701d6c6421124ff7a3c73a49038d38395916e55669bcadabae01d314c63b5c46a7fb94069c361824bab1ba210cb9d2ee3eff819e8b7e8532edb75c2c6dac6d53baa7e897606de6608a092ace8219133334f76c5ca1887c153cfcb590b8d761faff752c82fa107c734a850ea4ea90641fb5dcb7bdd0d54152f8a4ce432704efce72374f37957a2eab3c0b95f5054ac350d7c9cbd317646b0307cda7f910a76ec4603fa9deef9a8842bc4baad6fbd0977ae03e8b0d0f88d0ec095b8f72c064558f2c45d7f5d91306e6e7075bf5f6515e1a531cf902b3315db3cf8e365f8810f484633f4abb3e9a28981f115c9cf2dec884d0b307a52707a03721e510954f483ae35b41f685cacdf95f593d9e7e067ed977a340c137d8415b642c65eb8cca97559303d790a16aa550ce8e59b0644b62ed97fc7132d9b846cc9901abd37a1d38066defbe19af4d9b89eabb70f7339a4cedf52d9b9faf7d36374bae8047eb17076a97eac4d748e3d2d626b51e0f8940a8cc3e86486802a9b2a11d62a581a6135eb763ca09507b8de154616f4c5ead781c315740445b475749dcf5fa56c294804a96e6a909197dbb4653691f67149ebb9936297c6ea722cc1b5a48585fd620d842808e34de504b3d61b20c151a35f81b05c5ee04d4beb95092bbe7f1d3d55fdaaabf55bdc31a50b6f5cc0a4d31495e096b1fc7058f4773cb628694a7718183bf0b5ee6e2b545bc666dc139b36c94c3d166bafc5cf8391cd3ff5a2efc4665fc52ddb578cab888c92c351927d211df2eb3ef84be5843b251ae2276fb3b7bcd2493c8605dd768a0e0dc0f8b0bb7f7d7825d160c715ca7c8a7f6b2d9d810564740a7727f4599ede7a3888208d44eb8a9d9a052aceb590cc2866d749da734f4e191fe5885952f4ad3a3a0b809e3893bdf6e9fb07fa603f61b34d17cbaf70c00142ed456be2bad109edbe2d8120edc9af05ee5e7c8d886202592ca9d04a07608fd87c6fa79016a9ca13bb552dae572780557e98b2c9ff710f42797550c3f2ff64dbf98bbe8005fab72bc128409e630264943fe47a508401cf13a08aeebc9b96f245db8cdaeca7cdfb3fa91ecf3bbe9a6e0d703787d0d94d67aa255b62a7dfe071b399e4709a739f9be18761212f35e058f4365ebae1af01a3ebbe80cfe31c6b03622d94dce16c0075a524c401b6cf30c038c43a9aa30c6ac53c8bb651684584f9ff666b1a63b55f147aaa861b995c74365c6abd74e3848c05150b168b6f5a376714ec183242bab227f9672d86749b6be4401761ca5d086f69290bc6a15e72d80857649ff24ff6aa419b035f0c128767bad7e7398ca84872d55c4455cdef5a68a48da6bf6a7ff8f37127c007a42dd7ba8abe65119e127f7af27951a324c0c011819cca6541b91967a3e3890df0d72dc2dca87f1d59f5911dfd77d9c9b38e466506aaa713218ef22e6632d1e1adfac9a6fabce751f23a8415e8e881b2be628bcc2039cbcbfad82d372c830839378e68f6ece5478e4c3d61d2d746ee3ef32bc13c3f6722144109380a4a23dc81870089df07c78f2dc9caaebc747eccbe42334f18ba7cab12a1169fc23bf7321dee8cbfc84a9673c8b118c858a54173864f1111da480a50f32ec61e0e9c633eeab8934d614107788a7edecd7eedfd56b576d888471fdf4594a14d083ee0a64e3c7eb890a454fb81c179b4b607923ebd7215f5da21edac9f4314a5545ffc82af7cd72d45580ca8a957abfa85d35962c303b495a8769dbaaa6c35610e7ab85501eddd7599e8e41bd153fc9af4ec4e5dba9baefa00046c8f7488420235f8e42756b62a7a19e87377d688c386622bceee410a5612de0d7715e4dac6a7d0a584baf25ed6d52aebe9a26b3c7c4b4f39a6cce8291f78254c97eb42fe85bfb67df7ab77eb010700bf38ec7c7f0edfae7106b33e87f8c7a0bc4bb6d6d07d74b95cf39987becf9970ae6c43fe050f0831f505d3b132f9ff73df501ceb3c5fa2609f1926e8002f6780481014632fdcbf70c37c01a3fbc2dacf3f81a89965308c113017508da90ace59716f805f025c20751ac9799efc36d06ff7790b395f5f79b4d5da2597f1f6667a5d2e1c9a20e3429aac1609c4fed0a39ecd4600bcf18cf9a1f1cfcf800c24b4294320486e374b233a34b84ba2decd5e85e492593b47c21aaa556c3122e0db61371bc3768205d126</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">password</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>modeling 笔记</title>
    <link href="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="line"><a href="#line" class="headerlink" title="line"></a>line</h1><p>polyline: 连续的折线</p><p>line: 不管啥样的线都是1D的。line 包含curve。</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/1.jpeg" width="400" height="50"> <br></center><p>左边的公式适用于在曲线上生成点（为了pipeline）</p><p>右边的公式适用于描述trajectories(轨道)。可以用来延续一条curve。</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/2.jpeg" width="400" height="50"> <br></center><p>define 1D curve in 3D space.</p><h2 id="Speedline"><a href="#Speedline" class="headerlink" title="Speedline"></a>Speedline</h2><p>curve上取两个及以上个数的点。</p><p>interpolation : curve经过了所有的specify points</p><p>approxmiation : curve没有必要经过所有的点</p><h2 id="cubic-bezier-curves"><a href="#cubic-bezier-curves" class="headerlink" title="cubic bezier curves"></a>cubic bezier curves</h2><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/3.jpeg" width="400" height="200"> <br></center><p>这种曲线总是被control points 组成的convex包裹着 </p><p>注： 曲线在endpoint 正切</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/4.jpeg" width="400" height="200"> <br></center><p>图像描述了每一个基于T的点的权重值</p><p>性质: partition of unity : 相加得1 ; T [0,1] .  所以被convew包裹着</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/5.jpeg" width="400" height="50"> <br></center><p>matrix1： control points</p><p>matrix2: coefficient</p><p>matrix3: Bernstein polynomials</p><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/6.jpeg" width="400" height="200"> <br></center><p>使曲线变得更复杂。如图采取中点。给曲线由3个control points 变成7 个。 </p><p>注: 也可以不是中点 而是任意的radio。</p><h2 id="continuity"><a href="#continuity" class="headerlink" title="continuity"></a>continuity</h2><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/7.jpeg" width="400" height="200"> <br></center><p>C0 : 两条curve相交点是sharp kink。</p><p>G1 : 两条curve相交点tan是同一个direction。</p><p>C1 : 两条curve相交点tan完全相同。</p><p>C2 : 两条curve相交点tan完全相同，导数也完全相同。</p><h2 id="cubic-BSP-line"><a href="#cubic-BSP-line" class="headerlink" title="cubic BSP line"></a>cubic BSP line</h2><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/8.jpeg" width="400" height="200"> <br></center><h2 id="BSP-vs-Bezier"><a href="#BSP-vs-Bezier" class="headerlink" title="BSP vs Bezier"></a>BSP vs Bezier</h2><p>BSP 不经过endpoints</p><p>Bezier 经过</p><h1 id="surface"><a href="#surface" class="headerlink" title="surface"></a>surface</h1><center><img src="/2022/09/25/modeling-%E7%AC%94%E8%AE%B0/9.jpeg" width="400" height="200"> <br></center><p>给一个线拉成平面</p><h4 id="Implicit-surface"><a href="#Implicit-surface" class="headerlink" title="Implicit surface"></a>Implicit surface</h4><p>在数学中，隐式曲面是欧几里得空间中由方程定义 的曲面。<br>F(x,y,z)&#x3D;0<br>隐式曲面是三个变量的函数的零点集合。隐式意味着方程没有求解x或y或z。</p><p>ep: 球体 x^2+y^2+z^2 &#x3D; n^2</p><h4 id="Parametric-Surface"><a href="#Parametric-Surface" class="headerlink" title="Parametric Surface"></a>Parametric Surface</h4><p>输出的成分是基于一些参数或参数的。</p><p>如二次贝塞尔曲线（其中A、B、C和CurvePoint是N个维度的点）。<br>CurvePoint &#x3D; f(t) &#x3D; A*(1-t)^2 + B<em>2t(1-t) + C</em>t^2</p><p>或单位圆。<br>x &#x3D; cos(t)<br>y &#x3D; sin(t)</p><p>或者像这样的曲面。<br>SurfacePoint3D &#x3D; f(u,v)</p><h4 id="explicit-surface"><a href="#explicit-surface" class="headerlink" title="explicit surface"></a>explicit surface</h4><p>比较常见的函数类型，你在左边有一个变量（因变量），右边有另一个变量（自变量）。</p><p>比如说线。<br>y &#x3D; mx + b</p><p>或高度场。<br>高度 &#x3D; f(x,y)Ackermann Ackermann </p><p>L * R &#x3D; C </p><p>The color gets less saturated as gets closer to white.</p>]]></content>
    
    
    
    <tags>
      
      <tag>37111</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>games 笔记1</title>
    <link href="/2022/09/24/game-%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/09/24/game-%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="Week-1"><a href="#Week-1" class="headerlink" title="Week 1"></a>Week 1</h1><h1 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h1><p>考虑移动成本的搜索。文明中单位经过不同地形移动的举例不同。 用一个 priority queue。</p><p>优先队列里存放着各个地点。因为有可能多个路径经过同一个地点，所以如果当前loop中该地点在queue中已经有值，则只存放相对较好的值。</p><p>注： 相对于 Dijkstra ， BFS 就无法判断成本，只能寻找最短路径。</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">priority</span> <span class="hljs-operator">=</span> new_cost<br></code></pre></td></tr></table></figure><h1 id="Heuristic-search-（Greedy-Best-First-Search）"><a href="#Heuristic-search-（Greedy-Best-First-Search）" class="headerlink" title="Heuristic search （Greedy Best First Search）"></a>Heuristic search （Greedy Best First Search）</h1><p>经典的贪婪。 Dijkstra 可以寻找多个路径，但我们往往只需要一个。优先队列，但不加入cost so far 改为distance to goal （两点间距离公式）。</p><p>也不判断成本，且结果不一定最好，不适合复杂路径，但速度快很多。</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">priority</span> = heuristic(goal, next)<br></code></pre></td></tr></table></figure><p>在这里用property queue </p><p>注： </p><ol><li>heuristic(启发式)这里采用了距离公式，每种类型的图启发式是不一样的，需要自己寻找。</li><li>有可能找不到解，甚至是一个。</li><li>没有backtrack，有可能stack。</li></ol><h1 id="A"><a href="#A" class="headerlink" title="A*"></a>A*</h1><p>A* will tell you to move from one location to another but it won’t tell you how.</p><p>把前两个合起来。比Dijstra快且结果是正确的。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs haxe">priority = <span class="hljs-keyword">new</span><span class="hljs-type">_cost</span> + heuristic(goal, next)<br></code></pre></td></tr></table></figure><h3 id="good-heuristic-monotoic"><a href="#good-heuristic-monotoic" class="headerlink" title="good heuristic - monotoic"></a>good heuristic - monotoic</h3><center><img src="/2022/09/24/game-%E7%AC%94%E8%AE%B0/1.jpeg" width="400" height="300"> <br></center><h1 id="week-2"><a href="#week-2" class="headerlink" title="week 2"></a>week 2</h1><h2 id="Chapater-2"><a href="#Chapater-2" class="headerlink" title="Chapater 2"></a>Chapater 2</h2><h3 id="Best-response"><a href="#Best-response" class="headerlink" title="Best response"></a>Best response</h3><p>玩家找到最好的返回值</p><p> Let si be the strategy of player $i, i &#x3D; 1, . . . , k.$</p><p>$s_{i^*}$  is a best response to the collection of<br>opponent strategies if and only if<br>I no other strategy which player i can play gives a higher<br>payoff.</p><ul><li>有可能有不止一个最好解（best response strategy）</li><li>有可能没有最好解，比如两个玩家比较谁说的数字最大</li><li>有限集合(Finite strategy space)一定会有最好解。</li><li>无限集合不一定。</li></ul><h3 id="Nash-Equilibrium"><a href="#Nash-Equilibrium" class="headerlink" title="Nash Equilibrium"></a>Nash Equilibrium</h3><p>A strategy profile $(s_{1^*},s_{2^*},…s_{k^*})$ with k players, 所有玩家的战略都是对他们来说最好的就是Nash均衡。</p><h1 id="Lecture-3"><a href="#Lecture-3" class="headerlink" title="Lecture 3"></a>Lecture 3</h1><h2 id="Definition-2"><a href="#Definition-2" class="headerlink" title="Definition 2"></a>Definition 2</h2><ol><li>game of perfect information: 一个抉择树每个节点都有一个条件。也就是说任意玩家在任意时间都知道自己所在的位置。反之则是imperfect information。</li><li>zero-sum: 每一个叶子上所有用户的总和payoff是0。也就是说用户不会从中得到什么。</li><li>without chance： 节点没有被自然控制。 反之是game with chance。</li></ol><p>ep: 棋类是 2-person zero-sum games of perfect information without chance.<br>ep: Poker is a zero-sum1 game of imperfect information with chance.</p><h2 id="Definition-3"><a href="#Definition-3" class="headerlink" title="Definition 3"></a>Definition 3</h2><p>fully specified strategy : 对一个特定的玩家，有多少种战略。把所有可能性走法加起来。</p><h4 id="Generating-all-strategies-for"><a href="#Generating-all-strategies-for" class="headerlink" title="Generating all strategies for"></a>Generating all strategies for</h4><ul><li><p>如果玩家i第一步先走的话： Ni(t) &#x3D; Ni(t1) + Ni(t2) + · · · + Ni(tn).</p></li><li><p>如果玩家i第一步后走的话： Ni(t) &#x3D; Ni(t1) × Ni(t2) × · · · × Ni(tn).</p></li></ul><h1 id="week3"><a href="#week3" class="headerlink" title="week3"></a>week3</h1><h2 id="Nash-Equilibrium-1"><a href="#Nash-Equilibrium-1" class="headerlink" title="Nash Equilibrium"></a>Nash Equilibrium</h2><h4 id="Def"><a href="#Def" class="headerlink" title="Def"></a>Def</h4><p>Definition: A strategy profile (s1,s2,s3…sk) for a game with k<br>players, is a Nash equilibrium if each strategy is a best<br>response to all of the others.</p><ul><li>It is not a strategy; it is a choice of strategy for all players in<br>the game.</li><li>If the players are playing the Nash, no player has any<br>incentive to change its strategy unilaterally</li></ul><h2 id="Mini-max-approach"><a href="#Mini-max-approach" class="headerlink" title="Mini-max approach"></a>Mini-max approach</h2><center><img src="/2022/09/24/game-%E7%AC%94%E8%AE%B0/2.jpeg" width="400" height="200"> <br></center><center><img src="/2022/09/24/game-%E7%AC%94%E8%AE%B0/3.jpeg" width="400" height="200"> <br></center><p>解释上图： </p><ol><li>寻找Amelia的min ， 1，2，3，1</li><li>寻找Scott的max， 7，3，5，6</li><li>找Amelia的min中的max 和 Scott的max中的min 的那个点。</li></ol><h2 id="Dominance"><a href="#Dominance" class="headerlink" title="Dominance"></a>Dominance</h2><center><img src="/2022/09/24/game-%E7%AC%94%E8%AE%B0/4.jpeg" width="400" height="200"> <br></center><h2 id="Dominance-can-be-used-to-eliminate-some-strategies"><a href="#Dominance-can-be-used-to-eliminate-some-strategies" class="headerlink" title="Dominance can be used to eliminate some strategies"></a>Dominance can be used to eliminate some strategies</h2><center><img src="/2022/09/24/game-%E7%AC%94%E8%AE%B0/5.jpeg" width="400" height="200"> <br></center><h2 id="mixed-strategies"><a href="#mixed-strategies" class="headerlink" title="mixed strategies"></a>mixed strategies</h2><p>A mixed strategy is a strategy for a player in which:</p><ul><li>I plays probabilistic combination of pure strategies;</li><li>I receives a probabilistic combination of payoffs</li></ul><h4 id="Extensive-form"><a href="#Extensive-form" class="headerlink" title="Extensive form"></a>Extensive form</h4><p>一个路径上有权重比例的树</p><p>At each node where the player has a<br>decision, assign a probability function to each<br>of the possible choices.</p><h4 id="con"><a href="#con" class="headerlink" title="con"></a>con</h4><ol><li>Only for a special class of games do strategies which beat<br>all opponents always exist (two-player, zero-sum, perfect<br>information, no chance).</li><li>A Nash equilibrium is a collection of strategies for all<br>players such that each player is playing best response to<br>all the others.</li><li>For a zero-sum, two-player game in normal form, a<br>strategy pair which is maximal in its columns and minimal<br>in its rows is a Nash equilibrium.</li><li>Dominance can be used to reduce the number of<br>strategies.</li><li>Nash equilibria also exist in general-sum games.</li></ol><h1 id="Week4"><a href="#Week4" class="headerlink" title="Week4"></a>Week4</h1><h2 id="The-minmax-rule"><a href="#The-minmax-rule" class="headerlink" title="The minmax rule"></a>The minmax rule</h2><p>• MAX nodes are trying to maximise the payoff to player 1.<br>• MIN nodes are trying to minimise the payoff to player 1.</p><p>The value V(J) of a node J is</p><ol><li>If J is a terminal node, V(J) is equal its payoff U(J).</li><li>If J is a MAX node, V(J) is the maximum value of its<br>children.</li><li>If J is a MIN node, V(J) is the minimum value of its<br>children.</li></ol><center><img src="/2022/09/24/game-%E7%AC%94%E8%AE%B0/6.jpeg" width="400" height="200"> <br></center><center><img src="/2022/09/24/game-%E7%AC%94%E8%AE%B0/7.jpeg" width="400" height="200"> <br></center><h3 id="suppose-multi-players"><a href="#suppose-multi-players" class="headerlink" title="suppose multi players"></a>suppose multi players</h3><p>Can not approach an equilibria : </p><h1 id="Week-6"><a href="#Week-6" class="headerlink" title="Week 6"></a>Week 6</h1><h2 id="Trajectory-based-approaches"><a href="#Trajectory-based-approaches" class="headerlink" title="Trajectory-based approaches"></a>Trajectory-based approaches</h2><h2 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h2><p>就是根据行为的后果来加强或减弱行为。如果后果是好的，则加强行为，如果后果是坏的则减弱行为。通过这种方式来获得趋利避害的能力。公式后一部分是对后果的估值。<br>q-training就是个建立“操作性条件反射”的过程</p><p>Q(s, a)</p>]]></content>
    
    
    
    <tags>
      
      <tag>34111</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>games101-笔记-光栅化</title>
    <link href="/2022/08/30/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E6%A0%85%E5%8C%96/"/>
    <url>/2022/08/30/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E6%A0%85%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<p>orthographic projection（正交投影）:</p><p>忽略深度信息。相机无限远</p><p>perspective projection （透视）:</p><p>有近大远小的效果</p><p>先变为正交投影。然后透视。</p><p>早期的屏幕：（Cathode Ray Tube）阴极射线管。电子打出来射到屏幕上。工作原理是每一行每一行从上往下打电子。隔行扫描（raster scan）我第一帧扫描1，3，5行。第二帧扫描第2，4，6行。问题：对于高速运动视频会造成严重的画面撕裂。</p><p>中期：（Liquid Crystal Display）液晶显示器。<br>(LED) 发光二极管。 只有发光和不发光。之前灯已经确定好颜色了。</p><h3 id="三角形："><a href="#三角形：" class="headerlink" title="三角形："></a>三角形：</h3><ol><li>最基础多边形且三个点肯定在一个平面内。</li><li>任何多边形都可以拆解成三角形。</li></ol><h3 id="判断："><a href="#判断：" class="headerlink" title="判断："></a>判断：</h3><p>像素的中心点与三角形的位置关系。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>蒙特卡罗积分</title>
    <link href="/2022/08/26/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%A7%AF%E5%88%86/"/>
    <url>/2022/08/26/%E8%92%99%E7%89%B9%E5%8D%A1%E7%BD%97%E7%A7%AF%E5%88%86/</url>
    
    <content type="html"><![CDATA[<p>给任何一个函数，求定积分（面积）。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>games101-笔记-辐射度量学</title>
    <link href="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/"/>
    <url>/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/</url>
    
    <content type="html"><![CDATA[<h2 id="intro"><a href="#intro" class="headerlink" title="intro"></a>intro</h2><p>radiant energy : energy of electromagnetic radation.<br>Q(J)</p><p>radiant flux（power） : energy emitted per unit time. P &#x3D; Q&#x2F;t (W) , lm (流明)</p><h2 id="Intensity"><a href="#Intensity" class="headerlink" title="Intensity"></a>Intensity</h2><p>power per unit solid angle (立体角对应的能量)</p><p>I &#x3D; P&#x2F;w (P&#x3D; power , w &#x3D; 立体角)</p><h4 id="solid-angle"><a href="#solid-angle" class="headerlink" title="solid angle :"></a>solid angle :</h4><p>angle:</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/1.jpeg" width="200" height="200"> <br></center><p>solid angle:</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/2.jpeg" width="200" height="200"> <br></center><h2 id="Irradiance"><a href="#Irradiance" class="headerlink" title="Irradiance"></a>Irradiance</h2><p>power per unit area (面积所对应的能量)</p><p>E &#x3D; dP&#x2F;dA (P &#x3D; power  , A &#x3D;area) </p><h4 id="Irradiance-Falloff"><a href="#Irradiance-Falloff" class="headerlink" title="Irradiance Falloff"></a>Irradiance Falloff</h4><p>光在传播路程中会衰减。radient Intensity 不会衰减。因为立体角的光就那些不会变。 但是Irradiance 会衰减。因为随着光传播越来越远。area 越来越大。单位面积对应的power越来越小。</p><h2 id="Radiance"><a href="#Radiance" class="headerlink" title="Radiance"></a>Radiance</h2><p>power per unit solid angle, per unit area. </p><p>做两次微分。跟立体角和单位面积都有关系。</p><ol><li>radiance &#x3D; Irradiance per soild angle</li><li>radiance &#x3D; Intensity per projected unit area</li></ol><h4 id="incident-radiance"><a href="#incident-radiance" class="headerlink" title="incident radiance"></a>incident radiance</h4><p>从一个方向过来而被吸收的能量叫做incident radiance。</p><p>irradiance 和 radiance的区别就是是否有方向性。我们描述一块区域上面有多少的能量是irradiance，但一个区域上面的能量可以是从四面八方吸收而来的，我们只考虑在这个区域中能吸收多少能量从特定角度而来的就是incident radiance。</p><h4 id="exiting-radiance"><a href="#exiting-radiance" class="headerlink" title="exiting radiance"></a>exiting radiance</h4><p>从一个方向出去的光强度从特定的区域和特定的角度。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/3.jpeg" width="500" height="200"> <br></center><p>如下图所示如果我们想判断所有方向射入目标面的光只需要积分即可。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/4.jpeg" width="500" height="300"> <br></center><h2 id="BRDF"><a href="#BRDF" class="headerlink" title="BRDF"></a>BRDF</h2><h3 id="step-1-BRDF"><a href="#step-1-BRDF" class="headerlink" title="step 1 (BRDF)"></a>step 1 (BRDF)</h3><p>简单来说：如何把从一个方向接收到的能量反射到另一个方向去。</p><ol><li>是一个比例，一个area 从某一个方向接收到的radience乘以入射角后得到它的irridence。在反射成radience出去。</li><li>BRDF定义如何去分配向各个角度反射的光强弱。这也就区分了镜面反射还是漫反射。如果是漫反射各个方向大致相同。镜面反射的话会有一个着重点光线很强。</li></ol><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/5.jpeg" width="500" height="300"> <br></center><h3 id="step-2-refection-equation"><a href="#step-2-refection-equation" class="headerlink" title="step 2 (refection equation)"></a>step 2 (refection equation)</h3><p>刚才只考虑了一个方向现在考虑所有方向了。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/7.jpeg" width="500" height="300"> <br></center><h3 id="step-3-rendering-equation"><a href="#step-3-rendering-equation" class="headerlink" title="step 3 (rendering equation)"></a>step 3 (rendering equation)</h3><p>如果当前物体自己会发光。反射方程+自己的发光项</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/8.jpeg" width="500" height="300"> <br></center><h3 id="step-4-进一步运算"><a href="#step-4-进一步运算" class="headerlink" title="step 4 (进一步运算)"></a>step 4 (进一步运算)</h3><p>如果有多个光源。 反射方程递归。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/9.jpeg" width="600" height="300"> <br></center><p>如果光源并非点光源而存在面光源，积分上面的公式。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/10.jpeg" width="600" height="300"> <br></center><p>还需要考虑从其他物体上反射过来的光线（我们在这里就可以给其他物体上反射过来的光线当成是一种光源）。并且这是一个位置量。从下图可以看到。目前我们有两个未知量。所以采用递归。</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/11.jpeg" width="600" height="300"> <br></center><p>简写渲染方程。最终得到：</p><p>我们想求的能量 &#x3D; 本身光源的能量 + K（反射能量符，可以讲能量反射掉）* L（能量）</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/12.jpeg" width="600" height="300"> <br></center><p>我们讲公式简化得到。</p><p>不弹射：   自己的光</p><p>弹射一次： 直接光照</p><p>弹射两次： 间接光照</p><p>弹射三次： 全局光照</p><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/13.jpeg" width="600" height="300"> <br></center><center><img src="/2022/08/22/games101-%E7%AC%94%E8%AE%B0-%E8%BE%90%E5%B0%84%E5%BA%A6%E9%87%8F%E5%AD%A6/14.jpeg" width="600" height="300"> <br></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>基于图形学中渲染的光线追踪算法综述</title>
    <link href="/2022/08/19/%E5%85%B3%E4%BA%8E%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/"/>
    <url>/2022/08/19/%E5%85%B3%E4%BA%8E%E5%85%89%E7%BA%BF%E8%BF%BD%E8%B8%AA/</url>
    
    <content type="html"><![CDATA[<h3 id="abstract"><a href="#abstract" class="headerlink" title="abstract:"></a>abstract:</h3><p>Ray tracing is a method which could approximates real-world light sources.  With the rapid development of graphic cards , ray tracing is become p </p><p>光线追踪是一种可以模拟出近似与现实光照的方法，相较于传统光栅化它消耗的算力更为巨大但模拟的光源也更接近于现实。 近些年来随着硬件发展的迅速，计算机的算力已经可以允许我们大规模使用复杂的光线追踪进行渲染。把光线追踪分为。。。。 本文列举一些当前比较主流的光线追踪算法，并且详细描述了不同方法的优缺点与对整个CG领域的贡献。并在结尾总结了光线追踪的未来发展趋势。</p><h3 id="introduction"><a href="#introduction" class="headerlink" title="introduction:"></a>introduction:</h3><p> To compare it with rasterization , it cost more time to render.</p><p>关于现实生活中的光线得到历史。。</p><p>关于ray tarcing 的历史 。。最早的ray tracing 模型 LINKS-1 Computer 的简要介绍。。 </p><p>目前主流的ray tracing model 介绍 ： whitted-style。。 通常ray tracing 需要大量的算力进行计算。 但我们可以用一些加速方法。 比如BVH 。。。。</p><p>总的来说ray tracing 的基本流程是。。  我们首先有一个model 首先选用合适的加速方法。。 然后进行光追渲染。。。</p><h3 id="light-in-CG-VS-light-in-real-life"><a href="#light-in-CG-VS-light-in-real-life" class="headerlink" title="light in CG  VS light in real life"></a>light in CG  VS light in real life</h3><p>尽管光追能做到拟真是世界光源，但光线追踪和物理上光的反射不太一样，在cg中我们这么定义：</p><ol><li>光沿直线传播</li><li>光线相交互不影响</li><li>光路可逆，光线传入眼睛可以当作眼睛发出光线。</li></ol><p>但现实中的光源特点：</p><ol><li>接近于无限反射。直到电磁波消耗殆尽。</li><li>现实中的光是由一种电磁波。</li><li>不可能被计算机模拟。</li></ol><h3 id="光栅化-VS-光线追踪"><a href="#光栅化-VS-光线追踪" class="headerlink" title="光栅化 VS 光线追踪"></a>光栅化 VS 光线追踪</h3><p>因为光栅化没法做到很真实的物理效果，所以我们尝试使用光线追踪， 因为光追会显现出来更加真实的物理效果，反之会消耗更多的时间去渲染。</p><ol><li>光栅化只能反射2次。但光线追踪可以反射任意多次。</li></ol><h3 id="第一种类别的model-（whitted-style）"><a href="#第一种类别的model-（whitted-style）" class="headerlink" title="第一种类别的model （whitted-style）"></a>第一种类别的model （whitted-style）</h3><p>（在这里应该写出来这种model 属于那种类别。 对此类别进行分析 。 距离处whitted-style的优缺点）</p><p>就是将单一的pinhole camera model 进行递归 ，从而模拟出光线多次反射的效果 ，命名为recurive ray tracing 。但需要注意以下两点：</p><ol><li>光线强度会随着反射次数的增加而逐渐衰减。 </li><li>每个三角形的光都有可能是由很多个光源复合而成的。这里就涉及到了权重值问题，比如黄色光和红色光同时射入，这个三角形应该被渲染成橘色。但由于入射光的亮度可能不同，橘色的深浅也有不同。通过不断的累加颜色最终得到像素应该呈现的颜色。</li></ol><p>优点是：</p><p>缺点是：</p><h3 id="第二种类别的model-（）："><a href="#第二种类别的model-（）：" class="headerlink" title="第二种类别的model （）："></a>第二种类别的model （）：</h3><h3 id="关于model的加速结构-："><a href="#关于model的加速结构-：" class="headerlink" title="关于model的加速结构 ："></a>关于model的加速结构 ：</h3><p>BVM: </p><p>Oct-Tree (八叉树): 有不同的分法。比如不停的划分，直到其中有一块包围盒不包含物品位置。</p><p>KD-Tree(二叉树): 拼多多树，先横砍一刀沿物品切线。再每个包围盒竖直砍一刀。 目的是保持包围盒的均匀。三纬xyzxyz不断重复切。</p><p>BSP-Tree(二叉树): 也是不断砍。但是不好计算。之前我们提到的包围盒AABB就是因为沿着xyz轴的包围盒好被计算。</p><p>其他加速结构：</p><h3 id="应用辐射度量学来增强光线追踪的真实性："><a href="#应用辐射度量学来增强光线追踪的真实性：" class="headerlink" title="应用辐射度量学来增强光线追踪的真实性："></a>应用辐射度量学来增强光线追踪的真实性：</h3><p>\</p><h3 id="神经网络用于-ray-tracing-加速"><a href="#神经网络用于-ray-tracing-加速" class="headerlink" title="神经网络用于 ray tracing 加速"></a>神经网络用于 ray tracing 加速</h3><p>面临问题： 算法过于复杂。无法解决 。但我们可以引入机器学习model来加速</p><h3 id="总结与展望："><a href="#总结与展望：" class="headerlink" title="总结与展望："></a>总结与展望：</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>dragon_model</title>
    <link href="/2022/08/19/dragon-model/"/>
    <url>/2022/08/19/dragon-model/</url>
    
    <content type="html"><![CDATA[<center><img src="/2022/08/19/dragon-model/1.mp4" alt="GAM GLM ..." width="900" height="300"> <br></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>games101_笔记(光追)</title>
    <link href="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/"/>
    <url>/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/</url>
    
    <content type="html"><![CDATA[<h2 id="intro-："><a href="#intro-：" class="headerlink" title="intro ："></a>intro ：</h2><p>因为光栅化(rasterization)没法做到很真实的物理效果，所以我们尝试使用光线追踪(ray tracing)， 因为光追会显现出来更加真实的物理效果，反之会消耗更多的时间去渲染。</p><h2 id="step-1-light-rays-："><a href="#step-1-light-rays-：" class="headerlink" title="step 1 (light rays)："></a>step 1 (light rays)：</h2><p>尽管光追能做到拟真是世界光源，但光线追踪和物理上光的反射不太一样，在cg中我们这么定义：</p><ol><li>光沿直线传播</li><li>光线相交互不影响</li><li>光路可逆，光线传入眼睛可以当作眼睛发出光线。</li></ol><h2 id="step-2（pinhole-camera-model"><a href="#step-2（pinhole-camera-model" class="headerlink" title="step 2（pinhole camera model):"></a>step 2（pinhole camera model):</h2><p>每一个像素（pixel）投射一个光线，寻找这条光线所经过的路径，并判断与光源之间有没有被遮挡。如图所示，从light source返回一条光束，在之后通过镜面反射进入人眼。<br>但这个模型只有一次反射，和光栅化区别不大。于是whitted提出下面的模型。</p><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/1.jpeg" alt="GAM GLM ..." width="450" height="300"> <br></center><h2 id="step-3-whitted-style"><a href="#step-3-whitted-style" class="headerlink" title="step 3 (whitted-style):"></a>step 3 (whitted-style):</h2><p>就是将单一的pinhole camera model 进行递归 ，从而模拟出光线多次反射的效果 ，命名为recurive ray tracing 。但需要注意以下两点：</p><ol><li>光线强度会随着反射次数的增加而逐渐衰减。 </li><li>每个三角形的光都有可能是由很多个光源复合而成的。这里就涉及到了权重值问题，比如黄色光和红色光同时射入，这个三角形应该被渲染成橘色。但由于入射光的亮度可能不同，橘色的深浅也有不同。通过不断的累加颜色最终得到像素应该呈现的颜色。</li></ol><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/2.jpeg" alt="GAM GLM ..." width="450" height="300"> <br></center><p>如上图所示，</p><ol><li>primary ray: 最终到达像素的光线。</li><li>secondary ray: 中间所有一系列反射的光线。（我不确定是不是只限定于第二次反射）</li><li>shadow ray: 从光源处发出的所有光线。</li></ol><h2 id="step-4-equation"><a href="#step-4-equation" class="headerlink" title="step 4 (equation):"></a>step 4 (equation):</h2><ol><li>Ray: r(t) &#x3D; o + td, 0 &lt;&#x3D; t &lt;&#x3D; ♾️</li></ol><p>任何光线上一点，可以用光线初始强度o + 时间t * 方向d 来表示。</p><ol start="2"><li>Sphere： p: (p-c)^2 - R^2 &#x3D; 0</li></ol><p>球上任何一个点p 到球心c 的距离为 R。</p><ol start="3"><li>联立上面两个公式得到：p: (o + td-c)^2 - R^2 &#x3D; 0</li></ol><p>公式之中只有t 是未知量。 直接可以求得。</p><ol start="4"><li>Plane Equation: p: (p - p’) . N &#x3D; 0</li></ol><p>通过法线N 和 平面上确定一点p‘ 来确定一个平面。 判断目标点p 到 p’的 向量是否垂直于法线N 来判断p 是否在目标平面上。</p><ol start="5"><li>把plane 和 ray equation 结合起来呢？</li></ol><p>我们得知光线上任意一点可以用r(t)来表示。如果这个点在我们的平面上， 也就是r(t)&#x3D;p。我们可以通过这个等式求得光在什么时间(t)能打到平面上进行折射。联立可以得到：t &#x3D; (p’ - o) . N &#x2F; d . N</p><p>注意： 我们需要检查一下t是不是非负数。</p><h2 id="step-5-Moller-Trumbore-Algorithm"><a href="#step-5-Moller-Trumbore-Algorithm" class="headerlink" title="step 5 (Moller Trumbore Algorithm):"></a>step 5 (Moller Trumbore Algorithm):</h2><p>所消耗时间更短。</p><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/3.jpeg" alt="GAM GLM ..." width="450" height="300"> <br></center><h2 id="step-6-（bounding-volumes）："><a href="#step-6-（bounding-volumes）：" class="headerlink" title="step 6 （bounding volumes）："></a>step 6 （bounding volumes）：</h2><p>如果一束光不与包围盒相交，那么他也不与物品相交。</p><p>我们需要尽可能的避免不必要的运算。方法是给每个物体装进一个长方形里面。如果光无法碰触到这个长方形。则我们不需要考虑这个物体余光的碰撞。我们通常设置这种长方形的长宽高沿着xyz轴。</p><p>如果光于包围盒相交：<br>包围盒里面有很多小包围盒。因为计算包围盒与光线是否相交的时间复杂度是高于光与物品相交的。如果光与小包围盒相交。然后进行反射计算。</p><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/4.jpeg" alt="GAM GLM ..." width="300" height="300"> <br></center><h2 id="step7-划分包围盒空间的结构"><a href="#step7-划分包围盒空间的结构" class="headerlink" title="step7 (划分包围盒空间的结构):"></a>step7 (划分包围盒空间的结构):</h2><p>Oct-Tree (八叉树): 有不同的分法。比如不停的划分，直到其中有一块包围盒不包含物品位置。</p><p>KD-Tree(二叉树): 拼多多树，先横砍一刀沿物品切线。再每个包围盒竖直砍一刀。 目的是保持包围盒的均匀。三纬xyzxyz不断重复切。</p><p>BSP-Tree(二叉树): 也是不断砍。但是不好计算。之前我们提到的包围盒AABB就是因为沿着xyz轴的包围盒好被计算。</p><center><img src="/2022/08/12/games101-%E7%AC%94%E8%AE%B0-%E5%85%89%E8%BF%BD/5.jpeg" alt="GAM GLM ..." width="900" height="300"> <br></center>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于NeuralTalk2</title>
    <link href="/2022/07/17/%E5%85%B3%E4%BA%8ENeuralTalk2/"/>
    <url>/2022/07/17/%E5%85%B3%E4%BA%8ENeuralTalk2/</url>
    
    <content type="html"><![CDATA[<h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>参考的步骤进行配置</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/karpathy/</span>neuraltalk2<span class="hljs-regexp">/tree/</span><span class="hljs-number">3</span>c81602809b8b9e5bd3e9e213bf955986485dda7\<br></code></pre></td></tr></table></figure><p>我的环境是macOS + M1</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs text">$ curl -s https://raw.githubusercontent.com/torch/ezinstall/master/install-deps | bash<br>$ git clone https://github.com/torch/distro.git ~/torch --recursive<br>$ cd ~/torch; <br>$ ./install.sh      # and enter &quot;yes&quot; at the end to modify your bashrc<br>$ source ~/.bashrc <br></code></pre></td></tr></table></figure><p>接下来</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs text">$ luarocks install nn<br>$ luarocks install nngraph <br>$ luarocks install image <br></code></pre></td></tr></table></figure><p>在上面进行luarock安装的时候报错</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs awk">Installing https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/torch/</span>rocks<span class="hljs-regexp">/master/</span>nn-scm-<span class="hljs-number">1</span>.rockspec...<br>Using https:<span class="hljs-regexp">//</span>raw.githubusercontent.com<span class="hljs-regexp">/torch/</span>rocks<span class="hljs-regexp">/master/</span>nn-scm-<span class="hljs-number">1</span>.rockspec... switching to <span class="hljs-string">&#x27;build&#x27;</span> mode<br>正克隆到 <span class="hljs-string">&#x27;nn&#x27;</span>...<br>fatal: 无法连接到 github.com：<br>github.com[<span class="hljs-number">0</span>: <span class="hljs-number">140.82</span>.<span class="hljs-number">121.4</span>]: errno=Operation timed out<br></code></pre></td></tr></table></figure><p>我的解决方案有两个步骤</p><ol><li>(我觉得这个问题和这个步骤没关系) 我首先安装了lua</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> <span class="hljs-built_in">curl</span> <span class="hljs-literal">-R</span> <span class="hljs-literal">-O</span> http://www.lua.org/ftp/lua<span class="hljs-literal">-5</span>.<span class="hljs-number">4.3</span>.tar.gz<br><span class="hljs-variable">$</span> tar <span class="hljs-literal">-zxvf</span> lua<span class="hljs-literal">-5</span>.<span class="hljs-number">4.3</span>.tar.gz<br><span class="hljs-variable">$</span> <span class="hljs-built_in">cd</span> lua<span class="hljs-literal">-5</span>.<span class="hljs-number">4.3</span><br><span class="hljs-variable">$</span> make<br></code></pre></td></tr></table></figure><ol start="2"><li>还是stackoverflow好用（不是 ，加这个命令行就好了。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">git config --global url.https:<span class="hljs-regexp">//gi</span>thub.com<span class="hljs-regexp">/.insteadOf git:/</span><span class="hljs-regexp">/github.com/</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>openGL学习笔记(1)</title>
    <link href="/2022/07/08/openGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
    <url>/2022/07/08/openGL%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
    
    <content type="html"><![CDATA[<h1 id="“GLShaderManager-h”-和-“GLTools-h”"><a href="#“GLShaderManager-h”-和-“GLTools-h”" class="headerlink" title="“GLShaderManager.h” 和 “GLTools.h”"></a>“GLShaderManager.h” 和 “GLTools.h”</h1>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>openGL的学习笔记</title>
    <link href="/2022/07/02/openGL%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/07/02/openGL%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>模型的透明度</title>
    <link href="/2022/06/24/%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6/"/>
    <url>/2022/06/24/%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6/</url>
    
    <content type="html"><![CDATA[<h1 id="explainable-AI-（XAI）"><a href="#explainable-AI-（XAI）" class="headerlink" title="explainable AI （XAI）"></a>explainable AI （XAI）</h1><h3 id="XAI"><a href="#XAI" class="headerlink" title="XAI"></a>XAI</h3><p>指的是让人们明白这个模型是为什么得到这个结果的。因为AI有可能会作弊。比如通过看图片是否有copyright里面是不是有马的字段来判断图片是不是马。</p><p>XAI 我们就可以不断的人为优化模型。</p><p>black-box AI， 与XAI相反。 我们不知道模型通过什么得到的结果也不知道如何优化。</p><h3 id="各种learning"><a href="#各种learning" class="headerlink" title="各种learning"></a>各种learning</h3><p>监督学习(supervised learning):<br>  每个数据都有对应的label。良性肿瘤和恶性肿瘤。</p><p>无监督学习(unsupervised learning):<br>  数据没有labels。我们不知道每一个数据对应的什么意思。比如google有上千个新闻。我们没发给每一个加上label。我们就可以通过”聚类”的形式来将相似的定为一个专栏，达成新闻分类。</p><p>表示学习(representation learning):<br>  不同方法来表示学习。比如hsv和rgb都可以表示颜色。</p><center><img src="/2022/06/24/%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6/1.jpeg" alt="各种学习的精准度和可解释度" width="256" height="256"> <br>各种学习的精准度和可解释度</center><h3 id="各种model"><a href="#各种model" class="headerlink" title="各种model"></a>各种model</h3><h4 id="Interpretable-Models"><a href="#Interpretable-Models" class="headerlink" title="Interpretable Models"></a>Interpretable Models</h4><p>• Decision Trees, Lists a ,Sets and rules <br>基本的if else</p><p>• GAMs <br>• GLMs <br>• Linear regression <br>• Logistic regression \</p><center><img src="/2022/06/24/%E6%A8%A1%E5%9E%8B%E7%9A%84%E9%80%8F%E6%98%8E%E5%BA%A6/2.jpeg" alt="GAM GLM ..." width="1300" height="150"> <br>GAM GLM ...</center><p>• KNNs</p><h3 id="End-to-End-XAI"><a href="#End-to-End-XAI" class="headerlink" title="End-to-End XAI"></a>End-to-End XAI</h3><p>比传统的represtation learning 多了更多的不同等级的特征。 比如：<br>simple feature -&gt; complex feature -&gt; more complex feature。<br>这种结构对模型参数的调节空间更大。</p><h3 id="Shapley-Additive-Explanation"><a href="#Shapley-Additive-Explanation" class="headerlink" title="Shapley Additive Explanation"></a>Shapley Additive Explanation</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>BIG-bench</title>
    <link href="/2022/06/24/BIG-bench/"/>
    <url>/2022/06/24/BIG-bench/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
    <tags>
      
      <tag>我的笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>学习如何使用openai</title>
    <link href="/2022/06/20/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8openai/"/>
    <url>/2022/06/20/%E5%AD%A6%E4%B9%A0%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8openai/</url>
    
    <content type="html"><![CDATA[<h3 id="text-davinci-002"><a href="#text-davinci-002" class="headerlink" title="text-davinci-002"></a>text-davinci-002</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>never ending learning 笔记</title>
    <link href="/2022/06/07/never_ending_learning/"/>
    <url>/2022/06/07/never_ending_learning/</url>
    
    <content type="html"><![CDATA[<p> NELL 早期采用 Carlson et al. 模型。它的作用是阅读Web来获取信息。<br></p><p>输入：<br></p><ol><li>一个初始的 ontology 里面存放着很多categories （运动，运动员）。一个二原组的realtion 表示着 categories之间的关系。 比如：  哪个运动员在玩什么运动（x,y）。<br></li><li>每一个relation 或者是 categories 都有差不多12个labels， 比如运动有足球篮球一类的名词。<br></li><li>Web 从ClueWeb（一个有着1亿个网页的数据集）中获得。并且Google授权了NELL 10万个搜索问题的api。<br></li><li>偶尔会有人为参与。<br></li></ol><p>做什么：<br></p><ol><li>抓去更多的信息从web 并且移除老的不正确的信息。在这个过程中数据集不断的增长并且每一个information都有着出处和可信度。</li><li>每天学习如何比昨天读得更好</li></ol><p>总体来讲，NELL软件层面上的架构是：beliefs通过NEIL，OntExt 等一些辨别手段来选出一些候选的beliefs 再通过knowledge integrator 来对原有的beliefs 进行更新。</p><p>期望最大化算法（EM）:在概率模型中寻找最大似然<br><br>似然 (likelihood):对于模型的不同参数出现目标样本的概率是多少<br><br>知识整合 (Knowledge Integration): 就是将多个知识模型转化为一个公用的模型。像是通过多种角度判断一个游戏的好坏，比如画面模型，剧情模型。 将这些模型整合起来来得到一个评判游戏的好坏程度的模型。</p><p>NELL 的学习过程类似于EM用于半监督学习。每一次循环都有E-like step 和 M-like step。<br></p><ol><li>E-like step : 所有的beliefs 都需要重新被估计。在NELL中的每一个reading和inference 模型 都需要更新到KB之中（曾加或者减少一些beliefs）。通过知识整合（KI）我们将一大堆独立的建议转化为对每一个潜在kb 里面的 belief 的可信度。<br></li><li>M-like step :对上面更新的每一个模型都做一个针对于他们的学习算法。得到了一个上千个互相关联的学习任务。<br></li></ol><p>NELL因为做不到完全EM算法。所以我们在进行E-like的时候设置一个upperbound。那些有高可信度的新的belief才会被我们考虑并更新到KB之中。<br>并且当我们更新的时候，采用limited-radius fashion的方式。简单来说就是我们只考虑当前更新的belief直接相关的beliefs的更新，不再做进一步的考虑。</p><h2 id="Knowledge-Integrator"><a href="#Knowledge-Integrator" class="headerlink" title="Knowledge Integrator"></a>Knowledge Integrator</h2><p>KI只考虑类别类型一致的beliefs。比如他只检验在relation triple中的实体类型是不是与realtion一致。而不是考虑用一个新的triple作为一个触发器来更新beliefs在同一次循环之中。</p><h2 id="新增学习任务和实体"><a href="#新增学习任务和实体" class="headerlink" title="新增学习任务和实体"></a>新增学习任务和实体</h2><h3 id="OntExt"><a href="#OntExt" class="headerlink" title="OntExt"></a>OntExt</h3><p>OntExt 创建新realtion。他通过寻找像所有已经有的实体，去寻找那个最新最经常被考虑的relation，把他用于链接两个实体。实现这个过程分为三步：</p><ol><li>一个句子中如果有已经存在的category pair了。就将它直接提取出。像是&lt;动物，食物&gt;。狗在吃肉。 狗和肉就被提取出来了。</li><li>把一个文章构建出一个2D矩阵用来寻找新的relation。</li><li>OntExt自动发现新的relations。发现了之后立刻做为一个触发器用来适应于新的句子。</li></ol><h3 id="VerbKB"><a href="#VerbKB" class="headerlink" title="VerbKB"></a>VerbKB</h3><p>动词和动词短语经常用于表达名词之间的关系。有点像是一个动词的模式，用来分析主语，宾语还有动词短语之间的关系。作为一个三元组。&lt;主语category，动词短语，宾语category&gt;。NELL已经有6.5w个动词了。覆盖了ClueWeb2010的98%。现在正在寻找扩大这个动词规模的方法。</p><h3 id="关于自我评估和自我反思"><a href="#关于自我评估和自我反思" class="headerlink" title="关于自我评估和自我反思"></a>关于自我评估和自我反思</h3><p>期望NELL可以针对于他应该着重学习的地方进行学习而不是像现在这样只会检测没有。目前的研究目标就是把未标记的数据用作数据集。我们可以这么来做：通过Platanios et al.32我们知道如果我们有三个或者更多的funciton用来求解。我们判断是否所有的函数得到的都是同一个名词，因为他们判断成功与否是独立的。所以可以通过他们的精准度来判断模型的好坏。通过这种方式精准度在逐年增加。<br>NELL对于不同种类的词语表现相差很多。比如对河流，身体部分这种精准度能到95% 但是对于国家的首都精准度就很低。原因有两种：</p><ol><li>有可能我们的目标得到的结果并不在我们想要的集合里面，我们就给他新定义一个集合。可能这个集合只能被他自己所用，并且会误导别的我们想要测试的目标的正确性。</li><li>可能NELL已经弄错了，由于错误的传播谓语。就比如我们目前的NELL他判定所有的星球名字都以什么什么球为结尾。如果我们拿出来一个不是以球结尾的他就没法正确判断了。</li></ol><p>有一些很简单的词汇被复杂化了。比如开心 -&gt; 难以置信的开心。这使得学习任务变得越来越多。未来的研究就是让他有自我反思的能力。</p><h2 id="汇总"><a href="#汇总" class="headerlink" title="汇总"></a>汇总</h2><p>NELL 作为一个早期的案例有很多我们吸取教训的地方：</p><ol><li>coupling constraints限制了后续学习其他任务。</li><li>允许去学习新的coupling constraints。</li><li>现阶段模型是a-b c-d ， a-b-c-d是一个全新的模型。未来需要做到的是把a-b 作为一个谓词短语 来使用。 已达成（a-b）- (c-d)的目的。</li></ol><p>NELL的限制：</p><ol><li>没有反思。他不会意识到自己做错了很久且没有任何进展。也没有监控自己性能的能力。</li><li>有些方法是固定的。可塑性很差。比如寻找名词或者名词短语这种方法。我们是无法进行学习或者更改的。</li><li>目前NELL只用了一个简单的frame base。 他没有框架去推到时间和空间。<p></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>我的笔记</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
